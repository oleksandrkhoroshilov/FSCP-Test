<?xml version="1.0" encoding="utf-8"?>
<AxTable xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocAzureStorageAccount</Name>
	<SourceCode>
		<Declaration><![CDATA[
using UL = Docentric.AX.Framework.Utilities;
using Docentric.AX.Security.Azure.KeyVault;
using Docentric.AX.Storage.Azure.Exceptions;

public class DocAzureStorageAccount extends common
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the field values.
    /// </summary>
    public void initValue()
    {
        super();

        this.CompanyId = strUpr(curExt());
        this.ValidationStatus = DocAzureStorageAccountValidationStatus::Unknown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the DocAzureStorageAccount table.
    /// </summary>
    public void insert()
    {
        Global::handleEncryptedTablePreInsert(this);
        super();
        Global::handleEncryptedTablePostInsert(this);

        // Reset the global cache for the AzureKeyVaultSecret key
        if (this.ConnectionStringStorageType == DocSecretStorageType::AzureKeyVault)
        {
            DocGlobalCache::upsert(DocGlobalCacheKey::AzureKeyVaultSecret);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>update</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the record in the DocAzureStorageAccount table.
    /// </summary>
    public void update()
    {
        Global::handleEncryptedTablePreUpdate(this);
        super();
        Global::handleEncryptedTablePostUpdate(this);

        // Reset the global cache for the AzureKeyVaultSecret key
        if (this.ConnectionStringStorageType == DocSecretStorageType::AzureKeyVault)
        {
            DocGlobalCache::upsert(DocGlobalCacheKey::AzureKeyVaultSecret);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>connectionStringEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets connection string encrypted or decrypted value.
    /// NOTE:
    /// The value is masked manually because the FormStringControl with the property Password Style set to Yes
    /// does not work properly in the new grid  (enabled feature (Preview) New grid control). The property
    /// Password Style of the FormStringControl is now set to No. The bug was reported to MS and when they fix
    /// it the code can be reverted to previous state.
    /// </summary>
    /// <param name = "_set">Indicates whether to set the connection string or not.</param>
    /// <param name = "_value">Connection string value.</param>
    /// <returns>Decrypted connection string.</returns>
    public edit str connectionStringEdit(boolean _set, DocAzureStorageAccountConnectionString _value)
    {
        if (_set)
        {
            // The empty value should not be encrypted, because the field ConnectionString is mandatory.
            // The validation of empty value would not work, because the encryption of empty value would never return empty string. 
            if (!_value)
            {
                this.ConnectionString = _value;
            }
            else
            {
                // Set the account ID from the connection string if it is empty
                if (!this.AccountId)
                {
                    this.AccountId = DocAzureStorageAccount::parseConnectionString(_value, 'AccountName');
                }
                _value = Global::editEncryptedStringField(this, _value, fieldNum(DocAzureStorageAccount, ConnectionString), _set);
            }
            // Validate the Azure storage account connection settings
            DocAzureHelper::testAzureStorageAccountConnection(this, false);
            // Reset the validation status fields if the value is not provided
            if (!_value)
            {
                this.ValidationStatus = DocAzureStorageAccountValidationStatus::Unknown;
                this.ValidationStatusMessage = '';
            }
        }
        else
        {
            _value = Global::editEncryptedStringField(this, _value, fieldNum(DocAzureStorageAccount, ConnectionString), _set);
        }
        return _value ? strRep('*', 10) : _value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>keyVaultCertificateRefEdit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the Key Vault connection string.
    /// </summary>
    /// <param name = "_set">Indicates whether to set the Key Vault connection string or not.</param>
    /// <param name = "_value">Key Vault connection string value.</param>
    /// <returns>Key Vault connection string.</returns>
    public edit Name keyVaultCertificateRefEdit(boolean _set, Name _value)
    {
        if (_set)
        {
            changecompany(this.CompanyId)
            {
                this.KeyVaultCertificateRef = KeyVaultCertificateTable::findByName(_value).RecId;
            }
            // Validate the Azure storage account connection settings
            DocAzureHelper::testAzureStorageAccountConnection(this, false);
            // Reset the validation status fields if the value is not provided
            if (!_value)
            {
                this.ValidationStatus = DocAzureStorageAccountValidationStatus::Unknown;
                this.ValidationStatusMessage = '';
            }
            else
            {
                // Set the account ID from the connection string if it is empty
                if (!this.AccountId)
                {
                    this.AccountId = this.accountNameDisplay();
                }
            }
        }
        else
        {
            changecompany(this.CompanyId)
            {
                _value = KeyVaultCertificateTable::findRecId(this.KeyVaultCertificateRef).Name;
            }
        }
        return _value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountNameDisplay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Azure storage account name from the connection string.
    /// </summary>
    /// <returns>Azure storage account name</returns>
    [SysClientCacheDataMethod(true)]
    public display DocAzureStorageAccountName accountNameDisplay()
    {
        str accountName = '';
        int infoLine;

        try
        {
            infoLine = infologLine();
            str connectionString = this.getConnectionString();
            
            if (connectionString)
            {
                accountName = DocAzureStorageAccount::parseConnectionString(connectionString, 'AccountName');
            }
        }
        catch
        {
            infolog.cut(infoLine + 1, infologLine());
            // Ignore errors on record selection, validation is done on write and by using the Refresh button.
            exceptionTextFallThrough();
        }

        return accountName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findByAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>DocAzureStorageAccount</c> record specified by an Azure storage account ID.
    /// </summary>
    /// <param name="_accountId">An Azure storage account ID.</param>
    /// <param name="_forUpdate">A Boolean value that indicates whether to read the record for update; optional.</param>
    /// <returns>The specified <c>DocAzureStorageAccount</c> record if found.</returns>
    public static DocAzureStorageAccount findByAccountId(DocAzureStorageAccountId _accountId, boolean _forUpdate = false)
    {
        DocAzureStorageAccount docAzureStorageAccount;

        docAzureStorageAccount.selectForUpdate(_forUpdate);

        select firstonly docAzureStorageAccount
            where docAzureStorageAccount.AccountId == _accountId;

        return docAzureStorageAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if Azure storage account with the provided ID exists.
    /// </summary>
    /// <param name = "_accountId">Azure storage account ID</param>
    /// <returns>True, if Azure storage account with the provided ID exists, otherwise false.</returns>
    public static boolean exists(DocAzureStorageAccountId _accountId)
    {
        if (!_accountId)
        {
            return false;
        }

        DocAzureStorageAccount docAzureStorageAccount;

        select firstonly RecId from docAzureStorageAccount
            where docAzureStorageAccount.AccountId == _accountId;

        return docAzureStorageAccount.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConnectionStringByAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets decrypted connection string for provided Azure storage account ID.
    /// </summary>
    /// <param name = "_accountId">An Azure storage account ID.</param>
    /// <param name = "_showErrorMsg">Should error be shown</param>
    /// <param name = "_throwError">Should error be thrown if occurs</param>
    /// <returns>Decrypted connection string</returns>
    /// <remarks>
    /// For security reasons, we only return the Azure Storage account connection string for the current company or DAT.
    /// Connection strings in the DAT company can be accessed across all companies.
    /// This is to prevent in the pipeline that the connection string is returned for a company that does not have access to it and store the report incorrectly.
    /// </remarks>
    public static str getConnectionStringByAccountId(DocAzureStorageAccountId _accountId,
        boolean _showErrorMsg = true,
        boolean _throwError = true)
    {
        str connectionString = '';

        DocAzureStorageAccount docAzureStorageAccount = DocAzureStorageAccount::findByAccountId(_accountId);
        if (docAzureStorageAccount)
        {
            str currentCompany = strUpr(curExt());

            // For security reasons, we only return the Azure Storage account connection string for the current company or DAT.
            // Connection strings in the DAT company can be accessed across all companies.
            // This is to prevent in the pipeline that the connection string is returned for a company that does not have access to it and store the report incorrectly.
            if (docAzureStorageAccount.CompanyId != currentCompany && docAzureStorageAccount.CompanyId != 'DAT')
            {
                if (_showErrorMsg)
                {
                    DocGlobalHelper::handleError(strFmt("@DocentricAX5:AzureStorageAccountIsNotPermitted", _accountId, currentCompany), true, funcName(), _throwError);
                }
            }
            else
            {
                connectionString = docAzureStorageAccount.getConnectionString();
            }
        }

        return connectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConnectionString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the decrypted connection string.
    /// </summary>
    /// <returns>Decrypted connection string.</returns>
    public str getConnectionString()
    {
        str connectionString = '';

        switch (this.ConnectionStringStorageType)
        {
            case DocSecretStorageType::Database:
                connectionString = Global::editEncryptedStringField(this, '', fieldNum(DocAzureStorageAccount, ConnectionString), false);
                break;

            case DocSecretStorageType::AzureKeyVault:
                if (this.KeyVaultCertificateRef)
                {
                    changecompany(this.CompanyId)
                    {
                        // Get the secret entry
                        KeyVaultCertificateTable keyVaultCertificateTable = KeyVaultCertificateTable::findRecId(this.KeyVaultCertificateRef);
                        // Get Azure Key Vault parameters (e.g., protocol url, applicationId and applicationSecret aka password)
                        KeyVaultParameters keyVaultParameters = KeyVaultParameters::findRecId(keyVaultCertificateTable.KeyVaultRef);

                        // Get the full url from protocol url (e.g., vault://[my vault]/[secret]/[optional version])
                        str url = KeyVaultProtocolUtils::GetIdentifierUrlFromKeyVaultProtocol(
                                                            keyVaultCertificateTable.KeyVaultCertificate,
                                                            KeyVaultObjectType::Secret,
                                                            keyVaultParameters.Url);

                        // Get the secret from Azure Key Vault
                        connectionString = Secret::GetSecret(keyVaultParameters.AppClientId, keyVaultParameters.getClientSecretKey(), url);
                    }
                }
                break;
        }

        return connectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseConnectionString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value for the provided key from the connection string.
    /// </summary>
    /// <param name = "_connectionString">Connection string</param>
    /// <param name = "_key">Key</param>
    /// <returns>A value for the given key.</returns>
    private static str parseConnectionString(str _connectionString, str _key)
    {
        str value = '';

        if (_connectionString)
        {
            List connStringList = DocGlobalHelper::strSplit(_connectionString, ';', DocStringSplitOptions::RemoveEmptyEntries | DocStringSplitOptions::TrimEntries);
            ListEnumerator connStringListEnum = connStringList.getEnumerator();

            while (connStringListEnum.moveNext())
            {
                str connStringItem = connStringListEnum.current();
                if (match(_key, connStringItem) == 1)
                {
                    container connStringItemCon = str2con(connStringItem, '=', false);
                    if (conLen(connStringItemCon) == 2)
                    {
                        value = conPeek(connStringItemCon, 2);
                    }
                    break;
                }
            }
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the value of the field is changed.
    /// </summary>
    /// <param name = "_fieldId">Field Id</param>
    public void modifiedField(FieldId _fieldId)
    {
        super(_fieldId);

        switch (_fieldId)
        {
            case fieldNum(DocAzureStorageAccount, ConnectionStringStorageType):
                // Reset the following fields when the connection string storage type is changed
                this.connectionStringEdit(true, '');
                this.KeyVaultCertificateRef = 0;
                this.ValidationStatus = DocAzureStorageAccountValidationStatus::Unknown;
                this.ValidationStatusMessage = '';
                break;

            case fieldNum(DocAzureStorageAccount, KeyVaultCertificateRef):
                // Validate the Azure storage connection settings
                DocAzureHelper::testAzureStorageAccountConnection(this, false);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the current record.
    /// </summary>
    /// <returns>True if the record is validated successfully; otherwise false</returns>
    public boolean validateWrite()
    {
        boolean ret;
    
        ret = super();
    
        if (this.ConnectionStringStorageType == DocSecretStorageType::Database && !this.getConnectionString())
        {
            DocGlobalHelper::handleWarning(strFmt("@SYS84753", fieldId2PName(tableNum(DocAzureStorageAccount), fieldNum(DocAzureStorageAccount, ConnectionString))));
            ret = ret && false;
        }

        if (this.ConnectionStringStorageType == DocSecretStorageType::AzureKeyVault && !this.KeyVaultCertificateRef)
        {
            DocGlobalHelper::handleWarning(strFmt("@SYS84753", fieldId2PName(tableNum(DocAzureStorageAccount), fieldNum(DocAzureStorageAccount, KeyVaultCertificateRef))));
            ret = ret && false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validationStatusIndicator</Name>
				<Source><![CDATA[
    /// <summary>
    /// A display method for connection string validation indicator.
    /// </summary>
    /// <returns>Connection string validation indicator</returns>
    [SysClientCacheDataMethod(true)]
    public display container validationStatusIndicator()
    {
        container result = conNull();
        
        container symbolAndLabel = this.getSymbolAndLabelForValidationStatus();
        str symbol = conPeek(symbolAndLabel, 1);
        str label = conPeek(symbolAndLabel, 2);

        if (symbol)
        {
            result = ImageReference::constructForSymbol(symbol, label).pack();
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSymbolAndLabelForValidationStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the symbol and label depending on current connection string validation status.
    /// </summary>
    /// <returns>Container with symbol and label</returns>
    private container getSymbolAndLabelForValidationStatus()
    {
        str symbol = '';
        LabelId label;

        switch (this.ValidationStatus)
        {
            case DocAzureStorageAccountValidationStatus::Valid:
                symbol = ImageReferenceSymbol::Completed;
                label = "@DocentricAX5:AzureStorageAccountValidationStatusValid";
                break;

            case DocAzureStorageAccountValidationStatus::Error:
                symbol = ImageReferenceSymbol::Error;
                label = "@DocentricAX5:AzureStorageAccountValidationStatusError";
                break;

            case DocAzureStorageAccountValidationStatus::Unknown:
                symbol = ImageReferenceSymbol::FieldHelp;
                label = "@DocentricAX5:AzureStorageAccountValidationStatusUnknown";
                break;
        }
        return [symbol, label];
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearEncryptedFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears encrypted fields (ConnectionString)).
    /// </summary>
    /// <returns>Description of changed fields if some records were changed; otherwise empty string.</returns>
    public static str clearEncryptedFields()
    {
        DocAzureStorageAccount docAzureStorageAccount;
        boolean changed = false;

        ttsBegin;

        while select forupdate docAzureStorageAccount
        {
            // clear invalid ConnectionString fields (exception thrown at decryption)
            str value;

            // DocAzureStorageAccount.getConnectionString() throws X++ exception that aborts the transaction,
            // so we use direct method Application.DecryptFromStringForPurpose() to test EncyptedString field.
            System.Object[] paramsDecryptFromStringForPurpose = new System.Object[2]();
            paramsDecryptFromStringForPurpose.Set(0, docAzureStorageAccount.ConnectionString);
            paramsDecryptFromStringForPurpose.Set(1, docAzureStorageAccount.encryptionPurpose(fieldNum(DocAzureStorageAccount, ConnectionString)));

            if (!UL.ReflectionHelper::TryInvokeInstanceMethod(byref value, appl, 'DecryptFromStringForPurpose', paramsDecryptFromStringForPurpose))
            {
                docAzureStorageAccount.connectionStringEdit(true, '');
                docAzureStorageAccount.update();
                changed = true;
            }
        }

        ttsCommit;

        return (changed ? 'Azure storage accounts (DocAzureStorageAccount) connection strings' : '');
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
	<DeveloperDocumentation>@DocentricAX3:AzureStorageAccountHelp</DeveloperDocumentation>
	<FormRef>DocAzureStorageAccount</FormRef>
	<Label>@DocentricAX3:AzureStorageAccount</Label>
	<SubscriberAccessLevel>
		<Read>Allow</Read>
	</SubscriberAccessLevel>
	<TableGroup>Main</TableGroup>
	<TitleField1>AccountId</TitleField1>
	<CacheLookup>Found</CacheLookup>
	<ReplacementKey>DocAzureStorageAccountIdx</ReplacementKey>
	<SaveDataPerCompany>No</SaveDataPerCompany>
	<DeleteActions />
	<FieldGroups>
		<AxTableFieldGroup>
			<Name>AutoReport</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ConnectionString</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoLookup</Name>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>accountNameDisplay</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>CompanyId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoIdentification</Name>
			<AutoPopulate>Yes</AutoPopulate>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoSummary</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>AutoBrowse</Name>
			<Fields />
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>Overview</Name>
			<Label>@DocentricAX:Overview</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>CompanyId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>accountNameDisplay</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ConnectionStringStorageType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>connectionStringEdit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>keyVaultCertificateRefEdit</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>AccessType</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>validationStatusIndicator</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidationStatusMessage</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
		<AxTableFieldGroup>
			<Name>All</Name>
			<Label>@SYS6047</Label>
			<Fields>
				<AxTableFieldGroupField>
					<DataField>AccountId</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ConnectionString</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>KeyVaultCertificateRef</DataField>
				</AxTableFieldGroupField>
				<AxTableFieldGroupField>
					<DataField>ValidationStatus</DataField>
				</AxTableFieldGroupField>
			</Fields>
		</AxTableFieldGroup>
	</FieldGroups>
	<Fields>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>CompanyId</Name>
			<AllowEdit>No</AllowEdit>
			<ExtendedDataType>SelectableDataArea</ExtendedDataType>
			<HelpText>@DocentricAX5:AzureStorageAccountCompanyIdHelp</HelpText>
			<Label>@DocentricAX:CompanyId</Label>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>AccountId</Name>
			<ExtendedDataType>DocAzureStorageAccountId</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<Mandatory>Yes</Mandatory>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ConnectionString</Name>
			<ExtendedDataType>DocAzureStorageAccountConnectionString</ExtendedDataType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ConnectionStringStorageType</Name>
			<ExtendedDataType>DocAzureStorageAccountConnectionStringStorageType</ExtendedDataType>
			<EnumType>DocSecretStorageType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldInt64">
			<Name>KeyVaultCertificateRef</Name>
			<ExtendedDataType>KeyVaultCertificateRef</ExtendedDataType>
			<HelpText>@DocentricAX4:AzureStorageAccountKeyVaultConnectionStringHelp</HelpText>
			<Label>@DocentricAX4:AzureStorageAccountKeyVaultConnectionString</Label>
			<RelationContext>KeyVaultCertificateTable</RelationContext>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>AccessType</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>DocAzureStorageAccessType</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
			<EnumType>DocAzureAccessType</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldEnum">
			<Name>ValidationStatus</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<EnumType>DocAzureStorageAccountValidationStatus</EnumType>
		</AxTableField>
		<AxTableField xmlns=""
			i:type="AxTableFieldString">
			<Name>ValidationStatusMessage</Name>
			<AllowEdit>No</AllowEdit>
			<AllowEditOnCreate>No</AllowEditOnCreate>
			<ExtendedDataType>DocAzureStorageAccountValidationStatusMessage</ExtendedDataType>
			<IgnoreEDTRelation>Yes</IgnoreEDTRelation>
		</AxTableField>
	</Fields>
	<FullTextIndexes />
	<Indexes>
		<AxTableIndex>
			<Name>DocAzureStorageAccountIdx</Name>
			<AlternateKey>Yes</AlternateKey>
			<Fields>
				<AxTableIndexField>
					<DataField>AccountId</DataField>
				</AxTableIndexField>
			</Fields>
		</AxTableIndex>
	</Indexes>
	<Mappings />
	<Relations>
		<AxTableRelation xmlns=""
			i:type="AxTableRelationForeignKey">
			<Name>KeyVaultCertificateTable</Name>
			<Cardinality>ZeroMore</Cardinality>
			<OnDelete>Restricted</OnDelete>
			<RelatedTable>KeyVaultCertificateTable</RelatedTable>
			<RelatedTableCardinality>ExactlyOne</RelatedTableCardinality>
			<RelationshipType>Association</RelationshipType>
			<Constraints>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>CompanyId</Name>
					<Field>CompanyId</Field>
					<RelatedField>DataAreaId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintField">
					<Name>KeyVaultCertificateRef</Name>
					<Field>KeyVaultCertificateRef</Field>
					<RelatedField>RecId</RelatedField>
				</AxTableRelationConstraint>
				<AxTableRelationConstraint xmlns=""
					i:type="AxTableRelationConstraintRelatedFixed">
					<Name>KeyVaultCertificateType</Name>
					<RelatedField>KeyVaultCertificateType</RelatedField>
					<ValueStr>KeyVaultCertificateType::Manual</ValueStr>
				</AxTableRelationConstraint>
			</Constraints>
			<Index>RecId</Index>
		</AxTableRelation>
	</Relations>
	<StateMachines />
</AxTable>