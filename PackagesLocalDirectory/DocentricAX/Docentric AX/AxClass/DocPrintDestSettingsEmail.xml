<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocPrintDestSettingsEmail</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class containing all the necessary parameters and logic for handling the Docentric email print destination.
/// </summary>
public class DocPrintDestSettingsEmail implements SysPackable
{
    DocEmailFrom                    emailFrom;
    DocEmailTo                      emailTo;
    DocEmailCc                      emailCc;
    DocEmailBcc                     emailBcc;
    DocEmailSubject                 emailSubject;
    DocEmailBody                    emailBody;
    DocEmailAttachmentName          emailAttachmentName;
    DocEmailAttachmentFileFormat    emailAttachmentFileFormat;
    SRSReportFileFormat             emailAttachmentFileFormatSrs;
    boolean                         emailAttachmentUseSsrsBuiltInDesign;
    boolean                         openEmailBeforeSending;
    boolean                         isHtmlBody;
    container                       emailAdditionalAttachments;  // [ [attachmentName, [content]], [attachmentName, [content]], ...]
    Map                             emailImageMap = new Map(Types::String, Types::Container);   // <contentId, Bitmap>;

    str                                  emailFromDisplayName;
    DocEmailReplyToAddress               emailReplyTo;
    DocEmailBounceToAddress              emailBounceTo;
    DocEmailSendingModeExt               emailSendingMode; 
    DocEmailMsgPriorityExt               emailMsgPriority;
    DocEmailReadReceiptAddress           readReceiptAddress;
    DocEmailDeliveryReceiptCondition     deliveryReceiptCondition;
    boolean                              useEmailTemplate;
    DocReportEmailTemplateId             emailTemplateId;
    

    #define.currentPackVersion(5)
    #localmacro.currentList
        version,
        emailFrom,
        emailTo,
        emailCc,
        emailBcc,
        emailSubject,
        emailBody,
        emailAttachmentName,
        emailAttachmentFileFormat,
        emailAttachmentFileFormatSrs,
        emailAttachmentUseSsrsBuiltInDesign,
        openEmailBeforeSending,
        isHtmlBody,
        //emailImageMap    // handled in pack/unpack
        emailFromDisplayName,
        emailReplyTo,
        emailBounceTo,
        emailSendingMode,
        emailMsgPriority,
        readReceiptAddress,
        deliveryReceiptCondition,
        useEmailTemplate,
        emailTemplateId
    #endMacro
    #localmacro.listVersion4
        version,
        emailFrom,
        emailTo,
        emailCc,
        emailBcc,
        emailSubject,
        emailBody,
        emailAttachmentName,
        emailAttachmentFileFormat,
        emailAttachmentFileFormatSrs,
        emailAttachmentUseSsrsBuiltInDesign,
        openEmailBeforeSending,
        isHtmlBody,
        //emailImageMap    // handled in pack/unpack
        emailFromDisplayName,
        emailReplyTo,
        emailBounceTo,
        emailSendingMode,
        emailMsgPriority,
        readReceiptAddress,
        deliveryReceiptCondition
    #endMacro
    #localmacro.listVersion3
        version,
        emailFrom,
        emailTo,
        emailCc,
        emailBcc,
        emailSubject,
        emailBody,
        emailAttachmentName,
        emailAttachmentFileFormat,
        emailAttachmentFileFormatSrs,
        emailAttachmentUseSsrsBuiltInDesign,
        openEmailBeforeSending,
        isHtmlBody,
        //emailImageMap    // handled in pack/unpack
        emailFromDisplayName,
        emailReplyTo,
        emailBounceTo,
        emailSendingMode,
        emailMsgPriority
    #endMacro
    #localmacro.listVersion2
        version,
        emailFrom,
        emailTo,
        emailCc,
        emailBcc,
        emailSubject,
        emailBody,
        emailAttachmentName,
        emailAttachmentFileFormat,
        emailAttachmentFileFormatSrs,
        emailAttachmentUseSsrsBuiltInDesign,
        openEmailBeforeSending,
        isHtmlBody
        //emailImageMap    // handled in pack/unpack
    #endMacro
    #localmacro.listVersion1
        version,
        emailFrom,
        emailTo,
        emailCc,
        emailBcc,
        emailSubject,
        emailBody,
        emailAttachmentName,
        emailAttachmentFileFormat,
        emailAttachmentFileFormatSrs,
        emailAttachmentUseSsrsBuiltInDesign,
        openEmailBeforeSending,
        isHtmlBody
    #endMacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructor which sets some needed parameters.
    /// </summary>
    public void new()
    {
        isHtmlBody = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAdditionalAttachment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an additional email attachment along the report itself
    /// for the email that will be sent in case of Email print destination.
    /// </summary>
    /// <param name="_additionalAttachmentName">
    /// Additional attachment name (e.g. 'AdditionalAttachment.pdf').
    /// </param>
    /// <param name="_additionalAttachmentFileContent">
    /// Email additional attachment file content.
    /// </param>
    /// <remarks>
    /// This is the utility method for setting the emailAdditionalAttachments field.
    /// </remarks>
    public void addAdditionalAttachment(str _additionalAttachmentName, container _additionalAttachmentFileContent)
    {
        container   additionalAttachment;
        Filename    additionalAttachmentName;
        Filename    filePath, onlyFilename, fileExt;
            

        if (_additionalAttachmentName == '')
        {
            DocGlobalHelper::handleException(funcName(), "@DocentricAX:EmailAttachmentNameIsNotSet");
        }

        if (_additionalAttachmentFileContent == conNull())
        {
            DocGlobalHelper::handleException(funcName(), "@DocentricAX:EmailAttachmentContentIsNotSet");
        }

        if (_additionalAttachmentName)
        {
            [filePath, onlyFilename, fileExt] = Global::fileNameSplit(_additionalAttachmentName);
        }
        
        if (onlyFilename == '' || fileExt == '.')
        {
            DocGlobalHelper::handleException("@DocentricAX:EmailAttachmentNameCannotBeSet");
        }
            
        additionalAttachmentName = onlyFilename + fileExt;
    
        // We are making a structure like:
        // [ [attachmentName, [content]], [attachmentName, [content]], ...]
        additionalAttachment = [additionalAttachmentName, _additionalAttachmentFileContent];
        emailAdditionalAttachments = emailAdditionalAttachments + [additionalAttachment];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an additional email attachment along the report itself
    /// for the email that will be sent in case of Email print destination.
    /// </summary>
    /// <param name="_contentId">
    /// Content ID (CID in email HTML body).
    /// </param>
    /// <param name="_image">
    /// Image bitmap (e.g. CompanyInfo.Image)
    /// </param>
    /// <remarks>
    /// This is the utility method for adding image to emailImageMap.
    /// </remarks>
    public void addImage(str _contentId, Bitmap _image)
    {
        if (!_contentId)
        {
            DocGlobalHelper::handleException(funcName(), 'Image content ID (CID) is not set');
        }

        if (!_image)
        {
            DocGlobalHelper::handleException(funcName(), 'Image content is not set');
        }

        if (emailImageMap.exists(_contentId))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Image with ContentId %1 already exists', _contentId));
        }

        emailImageMap.insert(_contentId, _image);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteEmptyAndDuplicatedEmailAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all empty and duplicated email addresses from To, Cc, Bcc, Reply-to, Bounce-to and From email address(es), if any.
    /// </summary>
    /// <returns>
    /// True if any empty or duplicated email address is found.
    /// </returns>
    /// <remarks>
    /// Empty or duplicated email address in an email list can exist after placeholders are replaced with the
    /// empty or duplicated strings. (e.g. 'name@company.com;;name2@company.com' contains one empty email address)
    /// </remarks>
    public boolean deleteEmptyAndDuplicatedEmailAddresses()
    {
        boolean     foundEmptyAddress;
        str         emailToNew, emailCcNew, emailBccNew, emailFromNew, emailReplyToNew, emailBounceToNew;
    
        emailToNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailTo);
        emailCcNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailCc);
        emailBccNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailBcc);
        emailFromNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailFrom);
        emailReplyToNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailReplyTo);
        emailBounceToNew = DocEmailMngHelper::deleteEmptyAndDuplicatedEmailAddresses(emailBounceTo);

        foundEmptyAddress = false;
        if (emailTo != emailToNew)
        {
            emailTo = emailToNew;
            foundEmptyAddress = true;
        }
    
        if (emailCc != emailCcNew)
        {
            emailCc = emailCcNew;
            foundEmptyAddress = true;
        }
    
        if (emailBcc != emailBccNew)
        {
            emailBcc = emailBccNew;
            foundEmptyAddress = true;
        }
  
        if (emailFrom != emailFromNew)
        {
            emailFrom = emailFromNew;
            foundEmptyAddress = true;
        }
    
        if (emailReplyTo != emailReplyToNew)
        {
            emailReplyTo = emailReplyToNew;
            foundEmptyAddress = true;
        }

        if (emailBounceTo != emailBounceToNew)
        {
            emailBounceTo = emailBounceToNew;
            foundEmptyAddress = true;
        }

        return foundEmptyAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInvalidEmailAddressesDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for removing invalid email addresses from specified sections.
    /// </summary>
    /// <param name = "_emailPrintDestSettings">Object containing all the email print destination settings.</param>
    /// <param name = "_printReportSettings">Object containing all the report printing settings.</param>
    /// <param name = "_eventHandlerCleanEmailsResult">Event handler result object that contains the result with parameters for cleaning.</param>
    delegate void removeInvalidEmailAddressesDelegate(
        DocPrintDestSettingsEmail _emailPrintDestSettings,
        DocPrintReportSettings    _printReportSettings,
        DocEventHandlerCleanEmailsResult _eventHandlerCleanEmailsResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInvalidEmailAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publisher class for the removeInvalidEmailAddresses delegate.
    /// </summary>
    /// <param name = "_printReportSettings">Object containing all the report printing settings.</param>
    /// <returns>True if any invalid email addresses were removed, otherwise false.</returns>
    public boolean removeInvalidEmailAddresses(DocPrintReportSettings _printReportSettings)
    {
        // Result needs to be single response in case multiple subscribers are present.
        DocEventHandlerCleanEmailsResult eventHandlerResult = DocEventHandlerCleanEmailsResult::newSingleResponse();

        // Invoke the delegate so any subscribers can pass the required parameters.
        try
        {
            this.removeInvalidEmailAddressesDelegate(this, _printReportSettings, eventHandlerResult);
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", delegateStr(DocPrintDestSettingsEmail, removeInvalidEmailAddressesDelegate)));
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", delegateStr(DocPrintDestSettingsEmail, removeInvalidEmailAddressesDelegate)));
        }

        // If the eventHandlerResult class has no result, return as there is no point in continuing.
        if (!eventHandlerResult.hasResult())
        {
            return false;
        }

        DocCleanEmailsResult result = eventHandlerResult.result();
        
        // If invalid emails were already cleaned by a delegate subscriber, exit method without cleaning further.
        if (result.isCleaned())
        {
            return true;
        }

        boolean invalidAddressesRemoved = false;
        str warningMessageToSection = '', warningMessageCcSection = '', warningMessageBccSection = '';
        List emailsList, removedInvalidEmails;

        // Clean the email addresses in the To section and compose warning message.
        if (result.cleanEmailTo())
        {
            emailsList = DocGlobalHelper::getEmailList(emailTo);
            removedInvalidEmails = DocEmailMngHelper::removeInvalidEmailAddresses(emailsList);
            if (removedInvalidEmails.elements() > 0)
            {
                emailTo = DocPrintDestSettingsEmail::emailListToString(emailsList, ';');
                warningMessageToSection = DocPrintDestSettingsEmail::emailListToString(removedInvalidEmails, ', ');
                invalidAddressesRemoved = true;
            }
        }

        // Clean the email addresses in the CC section and compose warning message.
        if (result.cleanEmailCc())
        {
            emailsList = DocGlobalHelper::getEmailList(emailCc);
            removedInvalidEmails = DocEmailMngHelper::removeInvalidEmailAddresses(emailsList);
            if (removedInvalidEmails.elements() > 0)
            {
                emailCc = DocPrintDestSettingsEmail::emailListToString(emailsList, ';');
                warningMessageCcSection = DocPrintDestSettingsEmail::emailListToString(removedInvalidEmails, ', ');
                invalidAddressesRemoved = true;
            }
        }

        // Clean the email addresses in the BCC section and compose warning message.
        if (result.cleanEmailBcc())
        {
            emailsList = DocGlobalHelper::getEmailList(emailBcc);
            removedInvalidEmails = DocEmailMngHelper::removeInvalidEmailAddresses(emailsList);
            if (removedInvalidEmails.elements() > 0)
            {
                emailBcc = DocPrintDestSettingsEmail::emailListToString(emailsList, ';');
                warningMessageBccSection = DocPrintDestSettingsEmail::emailListToString(removedInvalidEmails, ', ');
                invalidAddressesRemoved = true;
            }
        }

        // If no invalid addresses were removed, don't show warning message.
        if (result.showWarningMsg() && invalidAddressesRemoved)
        {
            str warningMessage = "@DocentricAX4:InvalidEmailsWarningMessage";
            warningMessage += warningMessageToSection ? strFmt('%1 (%2), ', warningMessageToSection, "@DocentricAX:To") : '';
            warningMessage += warningMessageCcSection ? strFmt('%1 (%2), ', warningMessageCcSection, "@DocentricAX:Cc") : '';
            warningMessage += warningMessageBccSection ? strFmt('%1 (%2), ', warningMessageBccSection, "@DocentricAX:Bcc") : '';

            // Removes the last comma with space and replaces it with a full stop.
            warningMessage = subStr(warningMessage, 1, strLen(warningMessage) - 2) + '.';

            DocGlobalHelper::handleWarning(warningMessage);
        }
        
        return invalidAddressesRemoved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emailListToString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a list of emails into a string of emails separated by the specified delimiter.
    /// </summary>
    /// <param name = "_emailList">List to be converted to a string</param>
    /// <param name = "_delimiter">A delimiter used to separate email addresses</param>
    /// <returns>A string of emails separated by the specified delimiter</returns>
    protected static str emailListToString(List _emailList, str _delimiter = ';')
    {
        str emailListString = '';
        if (_emailList == null)
        {
            return emailListString;
        }

        ListEnumerator emailListEnumerator = _emailList.getEnumerator();
        while (emailListEnumerator.moveNext())
        {
            emailListString += (emailListString == '' ? '' : _delimiter) + strLRTrim(emailListEnumerator.current());
        }

        return emailListString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the current object to the packed container.
    /// </summary>
    /// <returns>Packed container</returns>
    public container pack()
    {
        int version = #currentPackVersion;
        container ret;
    
        ret = [#currentList] + [emailAdditionalAttachments] + [emailImageMap.pack()];
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailAdditionalAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the additional attachments parameter.
    /// </summary>
    /// <param name = "_emailAdditionalAttachments">Container containing the additional email attachments.</param>
    /// <returns>Container containing the additional email attachments.</returns>
    /// <remarks>Container is in the format of [ [attachmentName, content], [attachmentName, content], ...].</remarks>
    public container parmEmailAdditionalAttachments(container _emailAdditionalAttachments = emailAdditionalAttachments)
    {
        emailAdditionalAttachments = _emailAdditionalAttachments;
        return emailAdditionalAttachments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailImageMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email image map parameter.
    /// </summary>
    /// <param name = "_emailImageMap">Map object containing the email image.</param>
    /// <returns>Map object containing the email image.</returns>
    public Map parmEmailImageMap(Map _emailImageMap = emailImageMap)
    {
        emailImageMap = _emailImageMap;
        return emailImageMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailAttachmentFileFormat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email attachment file format parameter.
    /// </summary>
    /// <param name = "_emailAttachmentFileFormat">Email attachment file format enumerator.</param>
    /// <returns>Email attachment file format enumerator.</returns>
    public DocEmailAttachmentFileFormat parmEmailAttachmentFileFormat(DocEmailAttachmentFileFormat _emailAttachmentFileFormat = emailAttachmentFileFormat)
    {
        emailAttachmentFileFormat = _emailAttachmentFileFormat;
        return emailAttachmentFileFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailAttachmentFileFormatSrs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the SSRS email attachment file format parameter.
    /// </summary>
    /// <param name = "_emailAttachmentFileFormatSrs">SSRS email attachment file format enumerator.</param>
    /// <returns>SSRS email attachment file format enumerator.</returns>
    public SRSReportFileFormat parmEmailAttachmentFileFormatSrs(SRSReportFileFormat _emailAttachmentFileFormatSrs = emailAttachmentFileFormatSrs)
    {
        emailAttachmentFileFormatSrs = _emailAttachmentFileFormatSrs;
        return emailAttachmentFileFormatSrs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailAttachmentUseSsrsBuiltInDesign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the flag whether Docentric design should be used.
    /// </summary>
    /// <param name = "_emailAttachmentUseSsrsBuiltInDesign">Should Docentric design be used</param>
    /// <returns>Should Docentric design be used</returns>
    public boolean parmEmailAttachmentUseSsrsBuiltInDesign(boolean _emailAttachmentUseSsrsBuiltInDesign = emailAttachmentUseSsrsBuiltInDesign)
    {
        emailAttachmentUseSsrsBuiltInDesign = _emailAttachmentUseSsrsBuiltInDesign;
        return emailAttachmentUseSsrsBuiltInDesign;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResolvedAttachmentFileType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the file extension as a string using the attachment file format which should be used.
    /// </summary>
    /// <returns>Attachment output file type as a string</returns>
    public str getResolvedAttachmentFileType()
    {
        str fileType;

        if (!emailAttachmentUseSsrsBuiltInDesign)
        {
            fileType = DocFileMngHelper::convertToFileExtensionStr(emailAttachmentFileFormat);
        }
        else
        {
            fileType = DocFileMngHelper::convertSrsFileFormatToFileExtensionStr(emailAttachmentFileFormatSrs);
        }

        return fileType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailAttachmentName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email attachment name.
    /// </summary>
    /// <param name="_emailAttachmentName">Email attachment name.</param>
    /// <returns>Email attachment name.</returns>
    /// <remarks>
    /// It can be used in combination with standard and custom placeholders.
    /// http://ax.docentric.com/how-to-manuals/report-print-destinations/how-to-use-placeholders-in-print-destination-settings/
    /// </remarks>
    public DocEmailAttachmentName parmEmailAttachmentName(DocEmailAttachmentName _emailAttachmentName = emailAttachmentName)
    {
        emailAttachmentName = _emailAttachmentName;
        return emailAttachmentName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailBcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets one or more emails separated by commas or semicolons.
    /// </summary>
    /// <param name="_emailBcc">One or more emails separated by commas or semicolons.</param>
    /// <returns>One or more emails separated by commas or semicolons.</returns>
    public DocEmailBcc parmEmailBcc(DocEmailBcc _emailBcc = emailBcc)
    {
        emailBcc = _emailBcc;
        return emailBcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseEmailTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the flag indicating if the selected email tenplate will be used for the email body.
    /// </summary>
    /// <param name = "_useEmailTemplate">True if the email tenplate will be used for the email body.</param>
    /// <returns>True if the email template will be used for the email body; otherwise false.</returns>
    public boolean parmUseEmailTemplate(boolean _useEmailTemplate = useEmailTemplate)
    {
        useEmailTemplate = _useEmailTemplate;
        return useEmailTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailTemplateId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email template used for the email body.
    /// </summary>
    /// <param name = "_emailTemplateId">Email template Id.</param>
    /// <returns>Email template Id.</returns>
    public DocReportEmailTemplateId parmEmailTemplateId(DocReportEmailTemplateId _emailTemplateId = emailTemplateId)
    {
        emailTemplateId = _emailTemplateId;
        return emailTemplateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEmailDefaultTemplateToken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the selected email template ID is set to the default email template token.
    /// </summary>
    /// <returns>True/False</returns>
    public boolean isEmailDefaultTemplateToken()
    {
        return emailTemplateId == DocConstant::DefaultEmailTemplatePlaceholder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email body.
    /// </summary>
    /// <param name="_emailBody">Email body.</param>
    /// <returns>Email body.</returns>
    /// <remarks>
    /// It can be used in combination with standard and custom placeholders.
    /// http://ax.docentric.com/how-to-manuals/report-print-destinations/how-to-use-placeholders-in-print-destination-settings/
    /// </remarks>
    public DocEmailBody parmEmailBody(DocEmailBody _emailBody = emailBody)
    {
        emailBody = _emailBody;
        return emailBody;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailCc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets one or more emails separated by commas or semicolons.
    /// </summary>
    /// <param name="_emailCc">One or more emails separated by commas or semicolons.</param>
    /// <returns>One or more emails separated by commas or semicolons.</returns>
    public DocEmailCc parmEmailCc(DocEmailCc _emailCc = emailCc)
    {
        emailCc = _emailCc;
        return emailCc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailFrom</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets one or more emails separated by commas or semicolons.
    /// </summary>
    /// <param name="_emailFrom">One or more emails separated by commas or semicolons.</param>
    /// <returns>One or more emails separated by commas or semicolons.</returns>
    public DocEmailFrom parmEmailFrom(DocEmailFrom _emailFrom = emailFrom)
    {
        emailFrom = _emailFrom;
        return emailFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailSubject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the email subject.
    /// </summary>
    /// <param name="_emailSubject">Email subject.</param>
    /// <returns>Email subject.</returns>
    /// <remarks>
    /// It can be used in combination with standard and custom placeholders.
    /// http://ax.docentric.com/how-to-manuals/report-print-destinations/how-to-use-placeholders-in-print-destination-settings/
    /// </remarks>
    public DocEmailSubject parmEmailSubject(DocEmailSubject _emailSubject = emailSubject)
    {
        emailSubject = _emailSubject;
        return emailSubject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets one or more emails separated by commas or semicolons.
    /// </summary>
    /// <param name="_emailTo">One or more emails separated by commas or semicolons.</param>
    /// <returns>One or more emails separated by commas or semicolons.</returns>
    public DocEmailTo parmEmailTo(DocEmailTo _emailTo = emailTo)
    {
        emailTo = _emailTo;
        return emailTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpenEmailBeforeSending</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the flag should the email be open before sending.
    /// </summary>
    /// <param name="_openEmailBeforeSending">Should the email be open before sending.</param>
    /// <returns>Should the email be open before sending.</returns>
    public boolean parmOpenEmailBeforeSending(boolean _openEmailBeforeSending = openEmailBeforeSending)
    {
        openEmailBeforeSending = _openEmailBeforeSending;
        return openEmailBeforeSending;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsHtmlBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the flag if the email body is HTML.
    /// </summary>
    /// <param name="_isHtmlBody">Is the email body HTML.</param>
    /// <returns>Is the email body HTML.</returns>
    public boolean parmIsHtmlBody(boolean _isHtmlBody = isHtmlBody)
    {
        isHtmlBody = _isHtmlBody;
        return isHtmlBody;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailFromDisplayName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets Email sender display name, which is used in the combination with From email address.
    /// </summary>
    /// <param name = "_emailFromDisplayName">Email sender display name</param>
    /// <returns>Email sender display name</returns>
    public str parmEmailFromDisplayName(str _emailFromDisplayName = emailFromDisplayName)
    {
        emailFromDisplayName = _emailFromDisplayName;
        return emailFromDisplayName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailReplyTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets Reply-to email address. This is the address that will be used when replying to an email.
    /// </summary>
    /// <param name="_emailReplyTo">Reply-to email address.</param>
    /// <returns>Reply-to email address.</returns>
    public DocEmailReplyToAddress parmEmailReplyTo(DocEmailReplyToAddress _emailReplyTo = emailReplyTo)
    {
        emailReplyTo = _emailReplyTo;
        return emailReplyTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailBounceTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets Bounce-to email address. This is the address that a bounced email will return to.
    /// </summary>
    /// <param name="_emailBounceTo">Bounce-to email address.</param>
    /// <returns>Bounce-to email address.</returns>
    public DocEmailBounceToAddress parmEmailBounceTo(DocEmailBounceToAddress _emailBounceTo = emailBounceTo)
    {
        emailBounceTo = _emailBounceTo;
        return emailBounceTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailSendingMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets Emailing mode: Synchronous or Email processing.
    /// Default value is Synchronous (i.e. in process) and it is set in the constructor.
    /// </summary>
    /// <param name = "_emailSendingMode">Emailing mode</param>
    /// <returns>Emailing mode</returns>
    public DocEmailSendingModeExt parmEmailSendingMode(DocEmailSendingModeExt _emailSendingMode = emailSendingMode)
    {
        emailSendingMode = _emailSendingMode;
        return emailSendingMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailingMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the emailing mode parameter.
    /// </summary>
    /// <returns>Emailing mode enumerator.</returns>
    public DocEmailSendingMode getEmailingMode()
    {
        return DocEmailMessageReportSettings::sendingModeFromExt(emailSendingMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmailMsgPriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets Email priority: Normal, High or Low.
    /// Default value is Normal.
    /// </summary>
    /// <param name = "_emailMsgPriority">Email priority</param>
    /// <returns>Email priority</returns>
    public DocEmailMsgPriorityExt parmEmailMsgPriority(DocEmailMsgPriorityExt _emailMsgPriority = emailMsgPriority)
    {
        emailMsgPriority = _emailMsgPriority;
        return emailMsgPriority;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReadReceiptAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the read receipt address parameter.
    /// </summary>
    /// <param name = "_readReceiptAddress">Read receipt  address string.</param>
    /// <returns>Read receipt  address string.</returns>
    public DocEmailReadReceiptAddress parmReadReceiptAddress(DocEmailReadReceiptAddress _readReceiptAddress = readReceiptAddress)
    {
        readReceiptAddress = _readReceiptAddress;
        return readReceiptAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDeliveryReceiptCondition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/sets the delivery receipt condition parameter.
    /// </summary>
    /// <param name = "_deliveryReceiptCondition">Delivery receipt condition enumerator.</param>
    /// <returns>Delivery receipt condition enumerator.</returns>
    public DocEmailDeliveryReceiptCondition parmDeliveryReceiptCondition(DocEmailDeliveryReceiptCondition _deliveryReceiptCondition = deliveryReceiptCondition)
    {
        deliveryReceiptCondition = _deliveryReceiptCondition;
        return deliveryReceiptCondition;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailPriority</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the email priority parameter.
    /// </summary>
    /// <returns>Email priority enumerator.</returns>
    public eMailPriority getEmailPriority()
    {
        return DocEmailMessageReportSettings::msgPriorityFromExt(emailMsgPriority); 
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultParmValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the _reportId, _reportCaption, _setFromAccount parameters.
    /// </summary>
    /// <param name = "_reportId">Report ID string.</param>
    /// <param name = "_reportCaption">Report caption string.</param>
    /// <param name = "_setFromAccount">Boolean showing whether the from account has been set.</param>
    public void setDefaultParmValues(DocReportId _reportId, DocReportCaption _reportCaption, boolean _setFromAccount)
    {
        str  attachmentFilenameReportId;
    
    
        if (!emailFrom && _setFromAccount)
        {
            emailFrom = DocEmailMngHelper::getDefaultEmailProviderEmailAddress();
        }
    
        if (!emailAttachmentName)
        {
            attachmentFilenameReportId = DocReportingHelper::getDefaultOutputFilename(
                _reportId, false, _reportCaption, 0, this.getResolvedAttachmentFileType(), '', false);
            if (attachmentFilenameReportId && DocFileMngHelper::isValidOnlyFilename(attachmentFilenameReportId))
            {
                emailAttachmentName = attachmentFilenameReportId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>escapeAttachmentFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes invalid characters from attachment filename.
    /// </summary>
    public void escapeAttachmentFilename()
    {
        emailAttachmentName = DocFileMngHelper::replaceInvalidCharsForFileName(emailAttachmentName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the packed container to the current object.
    /// </summary>
    /// <param name = "_pack">Packed container</param>
    /// <returns>True/False</returns>
    public boolean unpack(container _pack)
    {
        boolean    ret = false;
        int        version;
    
   
        if (typeOf(conPeek(_pack, 1)) == Types::Integer)
        {
            version = conPeek(_pack, 1);
            if (version == #currentPackVersion)
            {
                container conImageMap;
                [#currentList, emailAdditionalAttachments, conImageMap] = _pack;
                emailImageMap = Map::create(conImageMap);
                ret = true;
            }
            else if (version == 4)
            {
                container conImageMap;
                [#listVersion4, emailAdditionalAttachments, conImageMap] = _pack;
                emailImageMap = Map::create(conImageMap);
                ret = true;
            }
            else if (version == 3)
            {
                container conImageMap;
                [#listVersion3, emailAdditionalAttachments, conImageMap] = _pack;
                emailImageMap = Map::create(conImageMap);
                ret = true;
            }
            else if (version == 2)
            {
                container conImageMap;
                [#listVersion2, emailAdditionalAttachments, conImageMap] = _pack;
                emailImageMap = Map::create(conImageMap);
                ret = true;
            }
            else if (version == 1)
            {
                [#listVersion1, emailAdditionalAttachments] = _pack;
                ret = true;
            }
        }
    
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the email print settings.
    /// </summary>
    /// <param name = "_reportId">Report Id</param>
    /// <param name = "_printValidationErrors">Should print the validation errors</param>
    /// <param name = "_checkPlaceholders">Should check the placeholders</param>
    /// <param name = "_checkFromAccount">Should check if emailFrom failed to be set to the default 'From' email account</param>
    /// <returns>True/False</returns>
    public boolean validate(
        DocReportId _reportId, 
        boolean _printValidationErrors = true, 
        boolean _checkPlaceholders = true, 
        boolean _checkFromAccount = false)
    {
        str           attachmentFilenameReportId, attachmentFilenameReportIdExt;
        str           emailAttachmentFileType;
        Filename      fileNameOnly, fileType, filePath;
        boolean       isValid;
        boolean       showWarningsAboutPlaceholders;
    
    
        showWarningsAboutPlaceholders = _checkPlaceholders && _printValidationErrors;
        isValid = true;
        
        /*** emailTo ***/
        if (!emailTo)
        {
            isValid = false;
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning("@DocentricAX:ToFieldNotSpecified");
            }
        }
    
        if (emailTo)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailTo, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ToFieldContainsPlaceholders", emailTo));
                    }
                }
                else if(!DocGlobalHelper::validateEmailListSkipPlaceholders(emailTo))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ToEmailAddressesNotValid", emailTo));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmailList(emailTo))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ToEmailAddressesNotValid", emailTo));
                    }
                }
            }
        }
    
        /*** emailCc ***/
        if (emailCc)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailCc, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:CcFieldContainsPlaceholders", emailCc));
                    }
                }
                else if(!DocGlobalHelper::validateEmailListSkipPlaceholders(emailCc))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:CcEmailAddressesNotValid", emailCc));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmailList(emailCc))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:CcEmailAddressesNotValid", emailCc));
                    }
                }
            }
        }
    
        /*** emailBcc ***/
        if (emailBcc)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailBcc, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:BccFieldContainsPlaceholders", emailBcc));
                    }
                }
                else if(!DocGlobalHelper::validateEmailListSkipPlaceholders(emailBcc))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:BccEmailAddressesNotValid", emailBcc));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmailList(emailBcc))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:BccEmailAddressesNotValid", emailBcc));
                    }
                }
            }
        }

        /*** emailReplyTo ***/
        if (emailReplyTo)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailReplyTo, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ReplyToFieldContainsPlaceholders", emailReplyTo));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmailList(emailReplyTo))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ReplyToEmailAddressesNotValid", emailReplyTo));
                    }
                }
            }
        }

        /*** emailBounceTo ***/
        if (emailBounceTo)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailBounceTo, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:BounceToFieldContainsPlaceholders", emailBounceTo));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmail(emailBounceTo))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:BounceToEmailAddressesNotValid", emailBounceTo));
                    }
                }
            }
        }

        /*** readReceiptAddress ***/
        if (readReceiptAddress && readReceiptAddress != DocConstant::EmailFromAddressPlaceholder) // Ignore token @FROM_ADDRESS@
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(readReceiptAddress, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:ReadReceiptAddressContainsPlaceholders", readReceiptAddress));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmail(readReceiptAddress))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX2:ReadReceiptEmailAddressNotValid", readReceiptAddress));
                    }
                }
            }
        }



        /*** emailFrom ***/
        if (_checkFromAccount && emailFrom == '')
        {
            // Note that if _checkFromAccount == true, this means that emailFrom failed to be set to the default 'From' email account.
            if (SysEmailParameters::find().MailerNonInteractive == '')
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:BatchEmailProviderNotSet");
                }
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == 255)  // Unsupported email provider
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:BatchEmailProviderNotSupported", SysEmailParameters::find().MailerNonInteractive));
                }
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::SMTP)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:EmailAccountForSMTPNotSet");
                }
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Exchange)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX:EmailUserAccountForExchangeNotSet", curUserId()));
                }
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Graph)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX5:EmailUserAccountForGraphNotSet", curUserId()));
                }
            }
        }

        if (emailFrom)
        {
            if (DocPlaceholderManager::findAnyPlaceholderCandidateForEmails(emailFrom, showWarningsAboutPlaceholders))
            {
                if (_checkPlaceholders)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:FromFieldContainsPlaceholders", emailFrom));
                    }
                }
            }
            else // No placeholder found.
            {
                if (!DocGlobalHelper::validateEmail(emailFrom))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:FromEmailAddressesInvalid", emailFrom));
                    }
                }
            }
        }
    
        /*** emailAttachmentName ***/
        if (!emailAttachmentName)
        {
            if (!_reportId)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:AttachmentFilenameNotSpecified");
                }
            }
            else
            {
                attachmentFilenameReportIdExt = this.getResolvedAttachmentFileType();
                attachmentFilenameReportId = _reportId + DocConstantFile::FileExtensionDelimiter + attachmentFilenameReportIdExt;
                if (!DocFileMngHelper::isValidOnlyFilename(attachmentFilenameReportId))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:AttahcmentFilenameInvalid", attachmentFilenameReportId));
                    }
                }
            }
        }
        else // emailAttachmentName != ''
        {
            if (_checkPlaceholders)
            {
                if (DocPlaceholderManager::findAnyPlaceholderCandidate(emailAttachmentName))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:EmailAttachmentContainsPlaceholders", emailAttachmentName));
                    }
                }
            }

            // Check if the report output file name is a valid filename, i.e. if it contains illegal characters.
            // Note that @PLACEHOLDER@ would not affect the result of the filename validation but @DOC_LABEL:UserDefinedLabelId@ would.
            // This is why before filename validation, we'll first remove all placeholders from resolvedOutputFilename.
            if (!DocFileMngHelper::isValidOnlyFilename(DocPlaceholderManager::removeAllPlaceholders(emailAttachmentName)))
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX:AttachmentFilenameInvalid", emailAttachmentName));
                }
            }
    
            emailAttachmentFileType = this.getResolvedAttachmentFileType();
            
            // NOTE: Until we don't introduce Custom output file format, we will asume that XML file extension
            // can be replaced with some other file extension, to enable varios customization scenarios.
            if (emailAttachmentFileType != DocConstantFile::FileExtXml)
            {
                [fileNameOnly, fileType, filePath] = Docu::splitFilename(emailAttachmentName);
                if (fileType != emailAttachmentFileType)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:FileExtensionInvalid", fileType, emailAttachmentFileType));
                    }
                }
            }

            // Check if the email attachment file format is deprecated XPS.
            if (this.parmEmailAttachmentFileFormat() == DocOutputFileFormat::XPS)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:FileFormatDeprecated", DocOutputFileFormat::XPS, DocOutputFileFormat::PDF));
                }
            }
        }
    
        /*** emailTemplate ***/
        if (this.parmUseEmailTemplate() && this.parmEmailTemplateId() == '')
        {
            isValid = false;
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning("@DocentricAX3:EmailTemplateNotSetWithUseEmailTemplateOn");
            }
        }

        // NOTE: For the sake of performance we will not be checking emailSubject,
        // emailBody and emailFromDisplayName for standard placeholders.
        /*
        if (emailSubject)
        {
            if (_checkPlaceholders)
            {
                if (DocPlaceholderManager::findAnyStdPlaceholder(emailSubject))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:EmailSubjectContainsPlaceholders", emailSubject));
                    }
                }
            }
        }
    
        if (emailBody)
        {
            if (_checkPlaceholders)
            {
                if (DocPlaceholderManager::findAnyStdPlaceholder(emailBody))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:EmailBodyContainsPlaceholders", emailBody));
                    }
                }
            }
        }
        */

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAdditionalEmailAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates additional email attachments.
    /// </summary>
    /// <param name = "_printValidationErrors">Boolean showing whether to print the validation errors.</param>
    /// <returns>True if addtional email attachments are valid, otherwise false.</returns>
    public boolean validateAdditionalEmailAttachments(boolean _printValidationErrors = true)
    {
        if (emailAdditionalAttachments == conNull())
        {
            return true;
        }

        boolean isValid = true;
        
        // Iterate through additional attachments.
        // [ [attachmentName, [content]], [attachmentName, [content]], ...]
        for (int counter = 1; counter <= conLen(emailAdditionalAttachments); counter++)
        {
            container additionalAttachment = conPeek(emailAdditionalAttachments, counter);
            str additionalAttachmentName = conPeek(additionalAttachment, 1);
            if (additionalAttachmentName == '')
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:ParameterAdditionalAttachmentNotProvided");
                    break;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEmailTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the email template.
    /// </summary>
    /// <param name = "_reportId">Report Id.</param>
    /// <param name = "_companyId">Company Id.</param>
    /// <param name = "_languageId">Language Id.</param>
    /// <param name = "_printValidationErrors">Should print validation errors.</param>
    /// <returns>True/False.</returns>
    public boolean validateEmailTemplate(DocReportId _reportId, CompanyId _companyId, LanguageId _languageId, boolean _printValidationErrors = true)
    {
        if (!this.parmUseEmailTemplate())
        {
            return true;
        }

        if (this.parmEmailTemplateId() == '')
        {
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning("@DocentricAX3:EmailTemplateNotSetWithUseEmailTemplateOn");
            }
            return false;
        }

        DocReportTable reportTable = DocReportTable::findReportId(_reportId);
        if (reportTable.RecId == 0)
        {
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:EmailTemplatesReportNotExists", _reportId));
            }
            return false;
        }
        
        if (!reportTable.IsActiveSRS)
        {
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:EmailTemplatesParentReportNotActive", _reportId));
            }
            return false;
        }

        // Report is registered and active in Docentric report setup. Try to find the selected email template.
        DocReportEmailTemplate emailTemplate;
        str errorMsg = '';
        if (this.isEmailDefaultTemplateToken())
        {
            // Locate the default template.
            emailTemplate = DocReportEmailTemplate::findDefaultEmailTemplateReportId(_reportId, _companyId, _languageId, false);
            if (emailTemplate.RecId == 0)
            {
                errorMsg = strFmt("@DocentricAX3:DefaultEmailTemplateNotExist", _reportId, _companyId, _languageId);

                // The default template is not found. Check if it exists but it is disabled.
                DocReportEmailTemplate emailTemplate2 = DocReportEmailTemplate::findDefaultEmailTemplateReportId(_reportId, _companyId, _languageId, true);
                if (emailTemplate2.RecId != 0 && emailTemplate2.IsEnabled == false)
                {
                    errorMsg = strFmt("@DocentricAX3:DefaultEmailTemplateNotEnabled", this.parmEmailTemplateId(), _reportId);
                }
            }
        }
        else   // It's not the default email template selected.
        {
            emailTemplate = DocReportEmailTemplate::findEmailTemplateIdUsingRules(this.parmEmailTemplateId(), _companyId, _languageId, false);

            // Check if the given email template exists.
            if (emailTemplate.RecId == 0)
            {
                errorMsg = strFmt("@DocentricAX3:EmailTemplateWithIdNotExist", this.parmEmailTemplateId(), _companyId, _languageId);

                // The given template is not found. Check if it exists but it is disabled.
                DocReportEmailTemplate emailTemplate2 = DocReportEmailTemplate::findEmailTemplateIdUsingRules(this.parmEmailTemplateId(), _companyId, _languageId, true);
                if (emailTemplate2.RecId != 0 && emailTemplate2.IsEnabled == false)
                {
                    errorMsg = strFmt("@DocentricAX3:EmailTemplateWithIdNotEnabled", this.parmEmailTemplateId(), _companyId, _languageId);
                }
            }

            // Check if the provided email template is assigned to the provided report ID.
            if (emailTemplate.RecId != 0 && reportTable.RecId != emailTemplate.Report)
            {
                DocReportTable parentReport = DocReportTable::find(emailTemplate.Report);
                errorMsg = strFmt("@DocentricAX3:EmailTemplateIsNotAssignedToReport", this.parmEmailTemplateId(), parentReport.ReportId, _reportId);
            }
        }

        // Print error message if needed.
        if (errorMsg)
        {
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning(errorMsg);
            }
            return false;
        }

        // The email template is found and it is valid.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadEmailTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the selected email template into the email body and sets the email subject if it is enabled.
    /// </summary>
    /// <param name = "_reportId">Report Id.</param>
    /// <param name = "_companyId">Company Id.</param>
    /// <param name = "_languageId">Language Id.</param>
    /// <returns>True/False.</returns>
    public boolean loadEmailTemplate(DocReportId _reportId, CompanyId _companyId, LanguageId _languageId)
    {
        boolean bodyLoaded = false;

        if (this.parmUseEmailTemplate() && this.parmEmailTemplateId() != '')
        {
            DocReportEmailTemplate emailTemplate;
            if (this.isEmailDefaultTemplateToken())
            {
                emailTemplate = DocReportEmailTemplate::findDefaultEmailTemplateReportId(_reportId, _companyId, _languageId, false);
            }
            else
            {
                emailTemplate = DocReportEmailTemplate::findEmailTemplateIdUsingRules(this.parmEmailTemplateId(), _companyId, _languageId, false);
            }

            // NOTE: Validation error about non-found email template will occur later in the pipeline using the method: this.validateEmailTemplate()
            if (emailTemplate.RecId != 0)
            {
                // Set the Email template ID (important for the default temlate).
                this.parmEmailTemplateId(emailTemplate.EmailTemplateId);

                // Set the email body.
                this.parmEmailBody(emailTemplate.HtmlBody);

                // Set the email subject if configured so.
                if (emailTemplate.IsSubjectEnabled)
                {
                    this.parmEmailSubject(emailTemplate.Subject);
                }

                // Set the email sender address if configured so.
                if (emailTemplate.IsSenderAddressEnabled)
                {
                    this.parmEmailFrom(emailTemplate.SenderAddress);
                }

                // Set the email sender name if configured so.
                if (emailTemplate.IsSenderNameEnabled)
                {
                    this.parmEmailFromDisplayName(emailTemplate.SenderName);
                }

                // Set the flag if body is successfully loaded.
                bodyLoaded = true;
            }
        }

        return bodyLoaded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    public static DocPrintDestSettingsEmail create(container _packedFromPrintDestSettingsEmail)
    {
        DocPrintDestSettingsEmail printDestSettingsEmail;
    
        printDestSettingsEmail = new DocPrintDestSettingsEmail();
        printDestSettingsEmail.unpack(_packedFromPrintDestSettingsEmail);
    
        return printDestSettingsEmail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixBareLinefeeds</Name>
				<Source><![CDATA[
    /// <summary> 
    /// Replace bare linefeeds in email body (Unix linefeeds \n (hex 0A) with Windows linefeeds \r\n (hex 0D 0A)).
    /// </summary>
    /// <remarks>
    /// This is a fix for MS bug in xSysLastValue::getLast().
    /// </remarks>
    public void fixBareLinefeeds()
    {        
        emailBody = strReplace(emailBody, '\r\n', '\n');
        emailBody = strReplace(emailBody, '\n',   '\r\n');
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>