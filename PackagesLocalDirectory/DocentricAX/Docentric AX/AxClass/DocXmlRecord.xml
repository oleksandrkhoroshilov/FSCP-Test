<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocXmlRecord</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// A utility class to quickly build an XML fragment by using table buffers and calculated values.
/// </summary>
public class DocXmlRecord
{
    TableId          tableId;
    SysDictTable     sysDictTable;
    RecId            recId;
    DataAreaId       dataAreaId;

    List             childRecords;
    Map              fields; // Map(Types::String, Types::Class), i.e. Map(fieldName, DocXmlField object)

    Common           common;
    boolean          isCalculatedRecord;
    guid             recordId;
    str              recordName;
    str              recordLabelValue;
    LabelId          recordLabelId;
    boolean          isSingleRecord;

    LanguageId       languageId;

    DocXmlRecord     parent;
    DocXmlRecordBuildingContext recordBuildingContext;
    

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getlabelRepository</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the label repository capable to resolve D365FO labels (i.e. system labels), GER labels, User-defined and Custom Fields labels.
    /// </summary>
    /// <returns>Label repository</returns>
    public DocDataSourceProviderLabelRepository getlabelRepository()
    {
        return this.recordBuildingContext().getlabelRepository();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAllDisplayMethods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends all display methods of the underlying table buffer to this record as data fields.
    /// Can be appended only to a table buffer based record that has the fields used by display methods
    /// already fetched from the database.
    /// </summary>
    /// <returns>This record.</returns>
    public DocXmlRecord addAllDisplayMethods()
    {
        Set                     methodSet;
        SetEnumerator           enumerator;
        SysDictMethod           sysDictMethod;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'display methods'));
        }
    
        // Add all display methods.
        if (this.sysDictTable() != null)
        {
            methodSet = this.sysDictTable().methods(true, false, true);
            enumerator = methodSet.getEnumerator();
    
            while (enumerator.moveNext())
            {
                sysDictMethod = enumerator.current();
    
                // Consider only display methods.
                if (sysDictMethod.displayType() != DisplayFunctionType::Get)
                {
                    continue;
                }
    
                this.addDisplayMethod(sysDictMethod.name());
            }
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAllFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends all fields of the underlying table buffer to this record as data fields.
    /// Can be appended only to a table buffer based record that has all fields already fetched from the database.
    /// </summary>
    /// <returns>This record.</returns>
    public DocXmlRecord addAllFields()
    {
        Array               fieldArray;
        FieldName           fieldName;
        int                 i;
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'fields'));
        }
    
        // Add all fields except the system fields..
        fieldArray = this.recordBuildingContext().getFieldArrayForTable(this.tableId());
        if (fieldArray)
        {
            for (i = 1; i <= fieldArray.lastIndex(); i++)
            {
                fieldName = fieldArray.value(i);
                this.addField(fieldName);
            }
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAllFieldsExcept</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends all fields of the underlying table buffer to this record as data fields
    /// except those listed in the _fieldList parameter. The table buffer must have all included
    /// fields already fetched from the database.
    /// </summary>
    /// <param name="_fieldList">
    /// List of field names to exclude, provided in the form of strings separated by commas
    /// within a container [field1_name, field2_name, ...].
    /// All listed fields will be excluded from the adding record with all fields.
    /// Use the fieldStr() method to provide a field name.
    /// </param>
    /// <returns>
    /// This record.
    /// </returns>
    public DocXmlRecord addAllFieldsExcept(container _fieldList)
    {
        Array               fieldArray;
        FieldName           fieldName;
        int                 i;
        Set                 excludedFieldSet;
    
    
        boolean isFieldExcluded(FieldName _fieldName)
        {
            return excludedFieldSet.in(_fieldName);
        }
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'fields'));
        }
    
        excludedFieldSet = new Set(Types::String);
        for (i = 1; i <= conLen(_fieldList); i++)
        {
            if (typeOf(conPeek(_fieldList, i)) != Types::String)
            {
                DocGlobalHelper::handleException(funcName(),
                    'Method addAllFieldsExcept: In the provided container _fieldList not all the elements are of the FieldName (string) type');
            }
    
            excludedFieldSet.add(conPeek(_fieldList, i));
        }
    
    
        // Add all fields except the system fields and the excluded fields.
        fieldArray = this.recordBuildingContext().getFieldArrayForTable(this.tableId());
        if (fieldArray)
        {
            for (i = 1; i <= fieldArray.lastIndex(); i++)
            {
                fieldName = fieldArray.value(i);
    
                // Skip the excluded fields.
                if (!isFieldExcluded(fieldName))
                {
                    this.addField(fieldName);
                }
            }
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends all fields of the underlying table buffer listed in the _fieldList
    /// parameter to this record as data fields. The table buffer must have all included fields
    /// already fetched from the database.
    /// </summary>
    /// <param name="_fieldList">
    /// List of field names to include, provided in the form of strings separated by commas
    /// within a container [field1_name, field2_name, ...].
    /// Use the fieldStr() method to provide a field name.
    /// </param>
    /// <returns>
    /// This record.
    /// </returns>
    public DocXmlRecord addFields(container _fieldList)
    {
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'fields'));
        }
    
        // Add fields from the provided field list.
        for (int i = 1; i <= conLen(_fieldList); i++)
        {
            if (typeOf(conPeek(_fieldList, i)) != Types::String)
            {
                DocGlobalHelper::handleException(funcName(),
                    'Method addFields: In the provided container _fieldList not all the elements are of the FieldName (string) type');
            }
    
            this.addField(conPeek(_fieldList, i));
        }
        
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalculatedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a calculated field based on the provided value to this recod as a data field.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_calculatedFieldName">
    /// Calculated field name.
    /// </param>
    /// <param name="_value">
    /// Field value. If the field value is of an enum or an edt type, the this.addCalculatedFieldFromEdt()
    /// and this.addCalculatedFieldFromEnum() methods should be used instead.
    /// </param>
    /// <param name="_labelIdOrValue">
    /// Label ID or label value of the calculated field.
    /// If ommited, the friendly name of the field will be missing in resulting data source.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField).
    /// </returns>
    public DocXmlField addCalculatedField(str _calculatedFieldName, anytype _value, str _labelIdOrValue = '')
    {
        DocXmlField  field;
        EnumName     enumName;
    
    
        // Validate parameters.
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedField: Parameter _calculatedFieldName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (this.containField(_calculatedFieldName))
        {
            if (this.recordBuildingContext().skipFieldIfErrorOccurs())
            {
                // Data field already exists -> Return it.
                return this.getField(_calculatedFieldName);
            }
            else
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Field (%1) already exists within the current record (%2)', _calculatedFieldName, this.getRecordName()));
            }
        }
    
        enumName = '';
        if (typeOf(_value) == Types::Enum && (enum2Value(_value) == 'true' || enum2Value(_value) == 'false'))
        {
            enumName = enumStr(boolean);
        }
    
        // Create field and add it to the current record.
        field = DocXmlField::constructCalculatedField(_calculatedFieldName, '', enumName, _value,
                                                      _labelIdOrValue, this.getLanguageId(), this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalculatedFieldFromEdt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a calculated field based on the provided EDT to this recod as a data field.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_calculatedFieldName">
    /// Calculated field name.
    /// </param>
    /// <param name="_edtName">
    /// Exended data type name. Use the extendedTypeStr() method to provide it.
    /// </param>
    /// <param name="_value">
    /// Field value.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying EDT is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField).
    /// </returns>
    public DocXmlField addCalculatedFieldFromEdt(str _calculatedFieldName, ExtendedDataTypeName _edtName, anytype _value,
                                                 str _overridingLabelIdOrValue = '')
    {
        DocXmlField   field;
        str           labelIdOrValue;
    
    
        // Validate parameters.
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldFromEdt: Parameter _calculatedFieldName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (!_edtName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldFromEdt: Parameter _edtName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (this.containField(_calculatedFieldName))
        {
            if (this.recordBuildingContext().skipFieldIfErrorOccurs())
            {
                // Data field already exists -> Return it.
                return this.getField(_calculatedFieldName);
            }
            else
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Field (%1) already exists within the current record (%2)', _calculatedFieldName, this.getRecordName()));
            }
        }
    
        // Get label.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForEdt(extendedTypeName2Id(_edtName));
        }
    
        // Create field and add it to the current record.
        field = DocXmlField::constructCalculatedField(_calculatedFieldName, _edtName, '', _value,
                                                      labelIdOrValue, this.getLanguageId(), this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalculatedFieldFromEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a calculated field based on the provided enum to this recod as a data field.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_calculatedFieldName">
    /// Calculated field name.
    /// </param>
    /// <param name="_enumName">
    /// Enum name. Use the enumStr() method to provide it.
    /// </param>
    /// <param name="_value">
    /// Field value.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying enum is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField).
    /// </returns>
    public DocXmlField addCalculatedFieldFromEnum(str _calculatedFieldName, EnumName _enumName, anytype _value,
                                                  str _overridingLabelIdOrValue = '')
    {
        DocXmlField   field;
        str           labelIdOrValue;
    
    
        // Validate parameters.
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldFromEnum: Parameter _calculatedFieldName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (!_enumName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldFromEnum: Parameter _enumName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (this.containField(_calculatedFieldName))
        {
            if (this.recordBuildingContext().skipFieldIfErrorOccurs())
            {
                // Data field already exists -> Return it.
                return this.getField(_calculatedFieldName);
            }
            else
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Field (%1) already exists within the current record (%2)', _calculatedFieldName, this.getRecordName()));
            }
        }
    
    
        // Get label.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForEnum(enumName2Id(_enumName));
        }
    
        // Create field and add it to the current record.
        field = DocXmlField::constructCalculatedField(_calculatedFieldName, '', _enumName, _value,
                                                      labelIdOrValue, this.getLanguageId(), this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalculatedFieldFromUserDefEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a calculated field based on a user-defined enum to this recod as a data field.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_calculatedFieldName">
    /// Calculated field name.
    /// </param>
    /// <param name="_enumValueName">
    /// Name of the selected user-defined enum node.
    /// </param>
    /// <param name="_enumValueLabelIdOrValue">
    /// Label ID (or Label Value, if Label ID is not provided) of the selected user-defined enum node.
    /// </param>
    /// <param name="_fieldLabelIdOrValue">
    /// Field label ID or label value.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField).
    /// </returns>
    public DocXmlField addCalculatedFieldFromUserDefEnum(str _calculatedFieldName,
                                                         str _enumValueName, str _enumValueLabelIdOrValue, // selected enum node Name and Label ID or Value
                                                         str _fieldLabelIdOrValue = '')
    {
        // Validate parameters.
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method %1: Parameter _calculatedFieldName is not provided for the record (%2)', funcName(), this.getRecordName()));
        }
    
        if (!_enumValueName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method %1: Parameter _enumValueName is not provided for the record (%2)', funcName(), this.getRecordName()));
        }
    
        if (this.containField(_calculatedFieldName))
        {
            if (this.recordBuildingContext().skipFieldIfErrorOccurs())
            {
                // Data field already exists -> Return it.
                return this.getField(_calculatedFieldName);
            }
            else
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Field (%1) already exists within the current record (%2)', _calculatedFieldName, this.getRecordName()));
            }
        }
    
        // Create field and add it to the current record.
        DocXmlField field = DocXmlField::constructCalculatedFieldUserDefEnum(_calculatedFieldName, _enumValueName, _enumValueLabelIdOrValue,
                                                                             _fieldLabelIdOrValue, this.getLanguageId(), this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCalculatedFieldWithSysLbl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a calculated field based on the provided value to this recod
    /// as a data field, with a label of another field of the underlying record table buffer.
    /// Can be appended only to a table buffer based record.
    /// </summary>
    /// <param name="_calculatedFieldName">
    /// Calculated field name.
    /// </param>
    /// <param name="_value">
    /// Field value.
    /// </param>
    /// <param name="_fieldNameSameTableForLabel">
    /// Field name of a field from the same context table buffer. Label of this field will be
    /// used as a friendly name of the calculated field. Use the fieldStr() method to provide it.
    /// If ommited or the current record is not a table buffer based record, an exception is thrown.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField).
    /// </returns>
    public DocXmlField addCalculatedFieldWithSysLbl(str _calculatedFieldName, anytype _value,
                                                    FieldName _fieldNameSameTableForLabel)
    {
        DocXmlField    field;
        str            systemLabelId;
        FieldId        fieldId;
        EnumName       enumName;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('The record (%1) is a calculated record. You can add a calculated field (%2) with the label from another table field (%3) only to a table buffer based record.',
                       this.getRecordName(), _calculatedFieldName, _fieldNameSameTableForLabel));
        }
    
        if (!_fieldNameSameTableForLabel)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldWithSysLbl: Parameter _fieldNameSameTableForLabel is not provided for the record (%1)', this.getRecordName()));
        }
    
        fieldId = this.sysDictTable().fieldName2Id(_fieldNameSameTableForLabel);
        if (fieldId == 0)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Method addCalculatedFieldWithSysLbl: Field with name (%1) is not defined on the current table (%2)',
                           _fieldNameSameTableForLabel, this.sysDictTable().name()));
        }
    
    
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method addCalculatedFieldWithSysLbl: Parameter _calculatedFieldName is not provided for the record (%1)', this.getRecordName()));
        }
    
        if (this.containField(_calculatedFieldName))
        {
            if (this.recordBuildingContext().skipFieldIfErrorOccurs())
            {
                // Data field already exists -> Return it.
                return this.getField(_calculatedFieldName);
            }
            else
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Field (%1) already exists within the current record (%2)', _calculatedFieldName, this.getRecordName()));
            }
        }
    
        enumName = '';
        if (typeOf(_value) == Types::Enum && (enum2value(_value) == 'true' || enum2value(_value) == 'false'))
        {
            enumName = enumStr(boolean);
        }
    
        // Get label.
        systemLabelId = this.recordBuildingContext().getLabelForField(this.tableId(), fieldId);
    
        // Create field and add it to the current record.
        field = DocXmlField::constructCalculatedField(_calculatedFieldName, '', enumName, _value,
                                                      systemLabelId, this.getLanguageId(), this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildCalculatedRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a calculated record as a child record of this record.
    /// No fields are appended. Only calculated fields can be appended to a calculated record afterwards.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_calculatedRecordName">
    /// Record name.
    /// </param>
    /// <param name="_labelIdOrValue">
    /// Label ID or label value of the calculated record.
    /// If ommited, the friendly name of the record will be missing in resulting data source.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended record (created DocXmlRecord instance).
    /// </returns>
    public DocXmlRecord addChildCalculatedRecord(str _calculatedRecordName, str _labelIdOrValue = '')
    {
        DocXmlRecord   childRecord;
    
    
        // Validate parameters.
        if (!_calculatedRecordName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addChildCalculatedRecord: Parameter _calculatedRecordName is not provided');
        }
    
        // Create record and add it to the parent or current record.
        childRecord = DocXmlRecord::constructCalculatedRecord(_calculatedRecordName, _labelIdOrValue,
                                                              this.getLanguageId(), this.recordBuildingContext());
    
        this.appendChildRecordNC(childRecord);
    
        return childRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildCalculatedRecordFromFieldGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a field group i.e. all fields and display methods from the provided field
    /// group as a child record of this record that is named as the provided field group.
    /// Can be appended only to a table buffer based record that has all fields from this
    /// particular field group already fetched from the database.
    /// </summary>
    /// <param name="_fieldGroupName">
    /// Field group name. Use the tableFieldgroupStr() method to provide it.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying field group is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended record (created DocXmlRecord instance).
    /// </returns>
    public DocXmlRecord addChildCalculatedRecordFromFieldGroup(FieldGroupName _fieldGroupName, str _overridingLabelIdOrValue = '')
    {
        FieldId                 fieldId;
        SysDictFieldGroup       sysDictFieldGroup;
        SysDictField            sysDictField;
        int                     i;
        str                     methodName;
        DocXmlRecord            fieldGroupRecord;
        DocXmlField             field;
        str                     labelIdOrValue, labelId;
        SysDictMethod           sysDictMethod;
        anytype                 methodReturnValue;
        ExtendedDataTypeName    edtName;
        EnumName                enumName;
    
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'field groups'));
        }
    
        if (!_fieldGroupName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addChildCalculatedRecordFromFieldGroup: Parameter _fieldGroupName is not provided');
        }
    
        sysDictFieldGroup = this.recordBuildingContext().getSysDictFieldGroup(this.tableId(), _fieldGroupName);
        if (!sysDictFieldGroup)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Field group (%1) is not defined on the current table (%2)', _fieldGroupName, this.sysDictTable().name()));
        }
    
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForFieldGroup(this.tableId(), _fieldGroupName);
        }
    
        // Construct calculated record from the field group.
        fieldGroupRecord = DocXmlRecord::constructCalculatedRecord(_fieldGroupName, labelIdOrValue,
                                                                   this.getLanguageId(), this.recordBuildingContext());
    
        // Don't move pointer to the current record.
        this.appendChildRecordNC(fieldGroupRecord);
    
        // Add each field to the constructed fieldGroupRecord.
        for (i = 1; i <= sysDictFieldGroup.numberOfFields(); i++)
        {
            fieldId = sysDictFieldGroup.field(i);
            methodName = sysDictFieldGroup.methodName(fieldId);
            if (methodName)
            {
                sysDictMethod = this.recordBuildingContext().getSysDictMethod(this.tableId(), methodName);
    
                // Execute method.
                new ExecutePermission().assert();
                methodReturnValue = this.sysDictTable().callObject(methodName, this.getCommon());
                CodeAccessPermission::revertAssert();
    
                // Get label if exists.
                labelId = this.recordBuildingContext().getLabelForMethod(this.tableId(), methodName);
    
                // Get the returning type.
                enumName = '';
                edtName  = '';
                if (sysDictMethod.returnType() == Types::Enum)
                {
                    enumName = enumId2Name(sysDictMethod.returnId());
                }
                else if (sysDictMethod.returnType() == Types::UserType)
                {
                    edtName = extendedTypeId2name(sysDictMethod.returnId());
                }
    
                // Create field and append it to the fieldGroupRecord.
                field = DocXmlField::constructCalculatedField(methodName, edtName, enumName, methodReturnValue,
                                                              labelId, this.getLanguageId(), this.recordBuildingContext());
                if (field != null)
                {
                    fieldGroupRecord.appendField(field);
                }
            }
            else
            {
                sysDictField = this.recordBuildingContext().getSysDictField(sysDictFieldGroup.tableid(), fieldId);
    
                // Create field and append it to the fieldGroupRecord.
                field = DocXmlField::constructField(this.tableId(), sysDictField.name(),
                                                    this.getCommon().(fieldId),
                                                    this.recordBuildingContext().getLabelForField(this.tableId(), fieldId),
                                                    this.getLanguageId(), this.recordBuildingContext());
                fieldGroupRecord.appendField(field);
            }
        }
    
        return fieldGroupRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChildRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a table buffer based record as a child record of this record.
    /// No fields are appended. Both table buffer based and calculated fields can be appended
    /// to a table buffer based record afterwards.
    /// Can be appended to both types of records: table buffer based or calculated records.
    /// </summary>
    /// <param name="_common">
    /// Table buffer.
    /// NOTE: To keep the created data record (DocXmlRecord) pointing to the same Common record,
    /// use addChildRecord(tableBuffer.data()) instead of addChildRecord(tableBuffer).
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying table is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended record (created DocXmlRecord instance).
    /// </returns>
    public DocXmlRecord addChildRecord(Common _common, str _overridingLabelIdOrValue = '')
    {
        DocXmlRecord      childRecord;
        str               labelIdOrValue;
    
        // Validate parameters.
        if (!_common.TableId)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addChildRecord: Record (parameter _common) is not set');
        }
    
        // Create record and add it to the parent or current record.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForTable(_common.TableId);
        }
    
        childRecord = DocXmlRecord::constructRecord(_common, labelIdOrValue,
                                                    this.getLanguageId(), this.recordBuildingContext());
    
        this.appendChildRecordNC(childRecord);
    
        return childRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDisplayMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a display or any other instance parameterless method as
    /// a data field of this record. This data field will be named as a method name,
    /// and with a field value that is equal to the method returning value.
    /// Can be appended only to a table buffer based record that has all fields used by this
    /// display method already fetched from the database.
    /// </summary>
    /// <param name="_methodName">
    /// Name of a display or any other instance parameterless method. Use the tableMethodStr() method to provide it.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying method, if defined, is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField), or returns already existing data field.
    /// </returns>
    public DocXmlField addDisplayMethod(MethodName _methodName, str _overridingLabelIdOrValue = '')
    {
        DocXmlField             field;
        str                     labelIdOrValue;
        SysDictMethod           sysDictMethod;
        anytype                 methodReturnValue;
        ExtendedDataTypeName    edtName;
        EnumName                enumName;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'display methods'));
        }
    
        if (!_methodName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addDisplayMethod: Parameter _methodName is not provided');
        }
    
        if (this.containField(_methodName))
        {
            // Data field already exists -> Return it.
            return this.getField(_methodName);
        }
    
        sysDictMethod = this.recordBuildingContext().getSysDictMethod(this.tableId(), _methodName);
        if (!sysDictMethod)
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method (%1) is not defined on the current table (%2)',
                                                                _methodName, this.sysDictTable().name()));
        }
    
        if (!this.recordBuildingContext().isMethodDefinedOnTable(this.tableId(), _methodName))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method (%1) is not defined on the current table (%2)',
                                                                _methodName, this.sysDictTable().name()));
        }
    
        if (!this.recordBuildingContext().isMethodParameterless(this.tableId(), _methodName))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method (%1) defined on the table (%2) has parameters which are not optional. Only parameterless methods or methods having all parameters optional can be added.',
                       _methodName, this.getRecordName()));
        }
    
        // Execute the method.
        new ExecutePermission().assert();
        if (this.getCommon().RecId != 0)
        {
            // It can happen that underlying table record doesn't exist, e.g. if we have a query with outer join.
            // This will be possible to happen only in design-time data source generation. In that case we will
            // initialize field value later, in the DocXmlField::constructCalculatedField() method.
            methodReturnValue = this.sysDictTable().callObject(_methodName, this.getCommon());
        }
        CodeAccessPermission::revertAssert();
    
        // Get the label.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForMethod(this.tableId(), _methodName);
        }
    
        // Get the returning type.
        enumName = '';
        edtName  = '';
        if (sysDictMethod.returnType() == Types::Enum)
        {
            enumName = enumId2Name(sysDictMethod.returnId());
        }
        else if (sysDictMethod.returnType() == Types::UserType)
        {
            edtName = extendedTypeId2name(sysDictMethod.returnId());
        }
    
        // Create field and add it to the current record.
        field = DocXmlField::constructCalculatedField(_methodName, edtName, enumName,
                                                      methodReturnValue, labelIdOrValue, this.getLanguageId(),
                                                      this.recordBuildingContext());
        if (field != null)
        {
            this.appendField(field);
        }
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a field of the underlying table buffer to this record as a data field.
    /// Can be appended only to a table buffer based record that has this particular field
    /// already fetched from the database.
    /// </summary>
    /// <param name="_fieldName">
    /// Field name. Use the fieldStr() method to provide it.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying field is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <returns>
    /// Created and appended data field (of type DocXmlField), or returns already existing data field.
    /// </returns>
    public DocXmlField addField(FieldName _fieldName, str _overridingLabelIdOrValue = '')
    {
        FieldId       fieldId;
        DocXmlField   field;
        str           labelIdOrValue;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'fields'));
        }
    
        if (!_fieldName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addField: Parameter _fieldName is not provided');
        }
    
        if (this.containField(_fieldName))
        {
            // Data field already exists -> Return it.
            return this.getField(_fieldName);
        }
    
        fieldId = this.sysDictTable().fieldName2Id(_fieldName);
        if (fieldId == 0)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Field with name (%1) is not defined on the current table (%2)', _fieldName, this.sysDictTable().name()));
        }
    
        // Get label.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = this.recordBuildingContext().getLabelForField(this.tableId(), fieldId);
        }
    
        // Create field and add it to the current record.
        field = DocXmlField::constructField(this.tableId(), _fieldName,
                                            this.getCommon().(fieldId),
                                            labelIdOrValue, this.getLanguageId(),
                                            this.recordBuildingContext());
        this.appendField(field);
    
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends a field group i.e. all fields and display methods from the provided field group
    /// as data fields of this record. Can be appended only to a table buffer based record that has all fields
    /// from this particular field group already fetched from the database.
    /// </summary>
    /// <param name="_fieldGroupName">
    /// Field group name. Use the tableFieldgroupStr() method to provide it.
    /// </param>
    /// <returns>
    /// This record.
    /// </returns>
    public DocXmlRecord addFieldGroup(FieldGroupName _fieldGroupName)
    {
        FieldId             fieldId;
        SysDictFieldGroup   sysDictFieldGroup;
        SysDictField        sysDictField;
        int                 i;
        str                 methodName;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'field groups'));
        }
    
        if (!_fieldGroupName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method addFieldGroup: Parameter _fieldGroupName is not provided');
        }
    
        sysDictFieldGroup = this.recordBuildingContext().getSysDictFieldGroup(this.tableId(), _fieldGroupName);
        if (!sysDictFieldGroup)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Field group (%1) is not defined on the current table (%2)', _fieldGroupName, this.sysDictTable().name()));
        }
    
    
        // Add each field.
        for (i = 1; i <= sysDictFieldGroup.numberOfFields(); i++)
        {
            fieldId = sysDictFieldGroup.field(i);
            methodName = sysDictFieldGroup.methodName(fieldId);
            if (methodName)
            {
                this.addDisplayMethod(methodName);
            }
            else
            {
                sysDictField = this.recordBuildingContext().getSysDictField(sysDictFieldGroup.tableid(), fieldId);
                this.addField(sysDictField.name());
            }
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSystemFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends system fields of the underlying table buffer to this record as data fields.
    /// Can be appended only to a table buffer based record that has the system fields already fetched
    /// from the database.
    /// </summary>
    /// <returns>This record.</returns>
    public DocXmlRecord addSystemFields()
    {
        FieldId         fieldId;
        SysDictField    sysDictField;
        int             i;
    
    
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'system fields'));
        }
    
        // Add only system fields.
        for (i = 1; i <= this.sysDictTable().fieldCnt(); i++)
        {
            fieldId = this.sysDictTable().fieldCnt2Id(i);
            sysDictField = this.recordBuildingContext().getSysDictField(this.sysDictTable().id(), fieldId);
    
            if (sysDictField.isSystem())
            {
                this.addField(sysDictField.name());
            }
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTitleFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and appends the title fields of the underlying table buffer to this record as data fields.
    /// Can be appended only to a table buffer based record that has the title fields already fetched
    /// from the database.
    /// </summary>
    /// <returns>
    /// This record.
    /// </returns>
    public DocXmlRecord addTitleFields()
    {
        // Validate parameters.
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('The record (%1) is a calculated record. You can create and append %2 only to a table buffer based record.',
                           this.getRecordName(), 'title fields'));
        }
    
        // Add title fields.
        if (this.sysDictTable().titleField1())
        {
            this.addField(fieldId2name(this.sysDictTable().id(), this.sysDictTable().titleField1()));
        }
    
        if (this.sysDictTable().titleField2())
        {
            this.addField(fieldId2name(this.sysDictTable().id(), this.sysDictTable().titleField2()));
        }
    
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendChildRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Append the provided data record to this record as a child.
    /// </summary>
    /// <param name = "_childRecord">The appending child record</param>
    public void appendChildRecord(DocXmlRecord _childRecord)
    {
        if (_childRecord == null)
        {
            DocGlobalHelper::handleException(funcName(), 'Parameter _childRecord is not set');
        }

        if (!this.containChildRecord(_childRecord.recordId()))
        {
            _childRecord.setParent(this);
            childRecords.addEnd(_childRecord);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendChildRecordNC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Use this method only when you are sure that no checking is needed whether the adding
    /// child record has already been added to the same parent (i.e. this record).
    /// </summary>
    /// <param name = "_childRecord">The appending child record</param>
    public void appendChildRecordNC(DocXmlRecord _childRecord)
    {
        if (_childRecord == null)
        {
            DocGlobalHelper::handleException(funcName(), 'Parameter _childRecord is not set');
        }
    
        /*
           We will not check this since this method is used by the framework only in the context
           where each appending child record has newly been created with the different recordID.
           This way will we gain in performance with large documents.
        */
        //if (!this.containChildRecord(_childRecord.recordId()))
        //{
        //    _childRecord.setParent(this);
        //    childRecords.addEnd(_childRecord);
        //}

        _childRecord.setParent(this);
        childRecords.addEnd(_childRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends the field to the field list.
    /// </summary>
    /// <param name = "_field">A fild to append</param>
    public void appendField(DocXmlField _field)
    {
        if (_field == null)
        {
            DocGlobalHelper::handleException(funcName(), 'Parameter _field is not set');
        }
    
        if (_field.getFieldName() == '')
        {
            DocGlobalHelper::handleException(funcName(), 'Name of the appending field is not set');
        }
    
        if (!fields.exists(_field.getFieldName()))
        {
            // Note: This method is not being used because of a performance issue.
            // _field.setParent(this);
    
            fields.insert(_field.getFieldName(), _field);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>childRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the child records in a list.
    /// </summary>
    /// <returns>
    /// List containing all child records.
    /// </returns>
    public List childRecords()
    {
        return childRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clone the record with fields including child records if the parameter _recursively is true.
    /// </summary>
    /// <param name="_recursively">
    /// Should the record be cloned with child records.
    /// </param>
    /// <param name="_recordBuildingContext">
    /// Record building context that contains caching structures, etc.
    /// </param>
    /// <returns>
    /// Cloned record.
    /// </returns>
    public DocXmlRecord clone(boolean _recursively, DocXmlRecordBuildingContext _recordBuildingContext = this.recordBuildingContext())
    {
        DocXmlRecord     childRecord, newchildRecord, newRecord;
        DocXmlField      field, newField;
        ListEnumerator   listEnumerator;
        MapEnumerator    mapEnumerator;
        str              recordLabelIdOrValue;
    
    
        recordLabelIdOrValue = this.getRecordLabelId();
        if (!recordLabelIdOrValue)
        {
            recordLabelIdOrValue = this.getRecordLabel();
        }
    
        // Construct new cloned record.
        if (this.isCalculatedRecord())
        {
            newRecord = DocXmlRecord::constructCalculatedRecord(this.getRecordName(), recordLabelIdOrValue,
                                                                this.getLanguageId(), _recordBuildingContext);
        }
        else
        {
            newRecord = DocXmlRecord::constructRecord(this.getCommon2(), recordLabelIdOrValue,
                                                      this.getLanguageId(), _recordBuildingContext);
            newRecord.setRecordName(this.getRecordName()); // In case that record name was changed.
            if (recordLabelIdOrValue == '') // In case that the record label was reset, it should be kept that way.
            {
                newRecord.setRecordLabel('');
            }
        }

        // Set SingleRecord property of the new cloned record.
        /* NOTE: SingleRecord is introduced in 3.3.9 for Docentric NextGen */
        newRecord.setSingleRecord(this.isSingleRecord());
    
        // Clone all fields.
        mapEnumerator = this.fields().getEnumerator();
        while (mapEnumerator.moveNext())
        {
            field = mapEnumerator.currentValue();
            newField = field.clone(newRecord.recordBuildingContext());
            newRecord.appendField(newField);
        }
    
        // Clone all child records.
        if (_recursively)
        {
            listEnumerator = this.childRecords().getEnumerator();
            while (listEnumerator.moveNext())
            {
                childRecord = listEnumerator.current();
                newchildRecord = childRecord.clone(true, newRecord.recordBuildingContext());
                newRecord.appendChildRecordNC(newchildRecord);
            }
        }
    
        return newRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containChildRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the given record is a direct child record.
    /// </summary>
    /// <param name="_recordId">
    /// Record ID of the potential child record.
    /// </param>
    /// <returns>
    /// True if the given record is a direct child record.
    /// </returns>
    public boolean containChildRecord(guid _recordId)
    {
        ListEnumerator   enumerator;
        DocXmlRecord     currentChildRecord;
    
    
        enumerator = childRecords.getEnumerator();
        while (enumerator.moveNext())
        {
            currentChildRecord = enumerator.current();
            if (currentChildRecord.recordId() == _recordId)
            {
                return true;
            }
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containDimensionFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the record contains at least one dimension field.
    /// </summary>
    /// <param name="_recursively">
    /// Should the child records be taken into account.
    /// </param>
    /// <returns>
    /// True if the record contains at least one dimension field.
    /// </returns>
    public boolean containDimensionFields(boolean _recursively = true)
    {
        MapEnumerator       mapEnumerator;
        ListEnumerator      listEnumerator;
        DocXmlField         currentField;
        DocXmlRecord        childRecord;
    
    
        mapEnumerator = fields.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            currentField = mapEnumerator.currentValue();
            if (currentField.isDimensionField())
            {
                return true;
            }
        }
    
        if (_recursively)
        {
            listEnumerator = childRecords.getEnumerator();
            while (listEnumerator.moveNext())
            {
                childRecord = listEnumerator.current();
                if (childRecord.containDimensionFields(true))
                {
                    return true;
                }
            }
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the given field is a child field of the record.
    /// </summary>
    /// <param name="_fieldName">
    /// Name of the potential child field.
    /// </param>
    /// <returns>
    /// True if the given field is a child data field.
    /// </returns>
    public boolean containField(str _fieldName)
    {
        if (!_fieldName)
        {
            return false;
        }
    
        return fields.exists(_fieldName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlElement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes the provided XML document to XML.
    /// </summary>
    /// <param name = "_parentXmlDoc">XML document</param>
    /// <returns>Serialized XML document as XML ekement</returns>
    private XmlElement createXmlElement(XmlDocument _parentXmlDoc)
    {
        XmlElement xmlElement;
    
        // Create element for the record.
        xmlElement = _parentXmlDoc.createElement(this.getRecordName());
    
        return xmlElement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdElement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an XSD schema for the provided XML document.
    /// </summary>
    /// <param name = "_parentXmlDoc">XML document</param>
    /// <returns>An XSD schema as XML document for provided XML document</returns>
    public XmlElement createXsdElement(XmlDocument _parentXmlDoc)
    {
        XmlElement    xsdElement, xsdComplexType, xsdChoice;
        XmlElement    xsdAnnotation;
        XmlAttribute  xsdElementNameAttr;
    
        /* Need to generate <xs:element> and <xs:complexType>.
          <xs:element name="Person">
            <xs:complexType>
              <xs:choice maxOccurs="unbounded" minOccurs="0">
                <xs:element name="Address">
                  <xs:annotation>
                    <xs:appinfo>
                      <dsp:label dsp:text="Address of the person (label)" />
                    </xs:appinfo>
                  </xs:annotation>
                  <xs:complexType>
                    <xs:attribute name="Street" type="xs:integer"></xs:attribute>
                    <xs:attribute name="City" type="xs:boolean"></xs:attribute>
                  </xs:complexType>
                </xs:element>
              </xs:choice>
              <xs:attribute name="Name" type="xs:base64Binary"></xs:attribute>
            </xs:complexType>
          </xs:element>
        */
    

        // Create <xs:element> for this data record.
        xsdElement = _parentXmlDoc.createElement2('xs:element', DocConstantDSP::XmlShemaNamespaceUri);
    
        xsdElementNameAttr = _parentXmlDoc.createAttribute('name');
        xsdElementNameAttr.value(this.getRecordName());
        xsdElement.setAttributeNode(xsdElementNameAttr);
    
        // ******* SingleRecord vs. RecordList **********************************************************
        // From 3.3.9: <xs:element> will additionally have maxOccurs="unbounded", if it is a record list.
        // **********************************************************************************************
        if (!this.isSingleRecord())
        {
            xsdElementNameAttr = _parentXmlDoc.createAttribute('maxOccurs');
            xsdElementNameAttr.value('unbounded');
            xsdElement.setAttributeNode(xsdElementNameAttr);
        }

        // Create annotation for the record label.
        if (this.getRecordLabelId() || this.getRecordLabel())
        {
            xsdAnnotation = DocDataSourceProviderHelper::createXsdAnnotationLabel(_parentXmlDoc, this.getRecordLabelId(), this.getRecordLabel());
            xsdElement.appendChild(xsdAnnotation);
        }
    
        // Create <xs:complex> element.
        xsdComplexType = _parentXmlDoc.createElement2('xs:complexType', DocConstantDSP::XmlShemaNamespaceUri);
        xsdElement.appendChild(xsdComplexType);
    
        if (this.childRecords().elements() > 0)
        {
            // Create <xs:choice> element.
            xsdChoice = DocDataSourceProviderHelper::createXsdChoiceElement(_parentXmlDoc);
            xsdComplexType.appendChild(xsdChoice);
        }
    
        return xsdElement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the fields of the record in a list.
    /// </summary>
    /// <returns>
    /// Map(str fieldName, DocXmlField fieldObject) containing all fields of the record.
    /// </returns>
    public Map fields()
    {
        return fields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the fields of the record in a list.
    /// </summary>
    /// <param name="_fieldName">Field name.</param>
    /// <returns>Field object.</returns>
    public DocXmlField getField(FieldName _fieldName)
    {
        if (fields.exists(_fieldName))
        {
            return fields.lookup(_fieldName);
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChildRecordsSortedAlphabetically</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sorts all child records of the record alphabetically.
    /// </summary>
    /// <returns>
    /// List of all child records sorted alphabetically by record names.
    /// </returns>
    public List getChildRecordsSortedAlphabetically()
    {
        List             sortedRecords;
        ListIterator     iteratorSR;
        ListEnumerator   enumerator, enumeratorSR;
        DocXmlRecord     currentRecord, currentSortedRecord;
        int              i, posToInsert;
    
    
        sortedRecords = new List(Types::Class);
    
        enumerator = childRecords.getEnumerator();
        while(enumerator.moveNext())
        {
            // Insert currentRecord to the right place in sortedRecords list.
            currentRecord = enumerator.current();
    
            posToInsert = -1;
    
            i = 1;
            enumeratorSR = sortedRecords.getEnumerator();
            while (enumeratorSR.moveNext())
            {
                currentSortedRecord = enumeratorSR.current();
    
                if (currentSortedRecord.getRecordName() > currentRecord.getRecordName())
                {
                    posToInsert = i;
                    break;
                }
    
                i++;
            }
    
            if (posToInsert == 1)
            {
                sortedRecords.addStart(currentRecord);
                continue;
            }
    
            if (posToInsert == -1)
            {
                sortedRecords.addEnd(currentRecord);
                continue;
            }
    
            i = 1;
            iteratorSR = new ListIterator(sortedRecords);
            while (iteratorSR.more())
            {
                if (i == posToInsert)
                {
                    iteratorSR.insert(currentRecord);
                    break;
                }
                iteratorSR.next();
                i++;
            }
        }
    
        return sortedRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the underlaying table buffer if exists (i.e. if this is not a calculated data record).
    /// Note that the 'common' field contains the pointer to the table buffer of the currently creating data record.
    /// Once the data record is created, the 'common' field might not point to the table buffer that this data record and its fields are created from.
    /// To keep this pointer valid, when creating a new data record, use this.addChildRecord(tableBuffer.data()) instead of this.addChildRecord(tableBuffer).
    /// To get the underlaying Common also when you created the record without using tableBuffer.data(), use this.getCommon2().
    /// </summary>
    /// <returns>Underlaying table buffer</returns>
    public Common getCommon()
    {
        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCommon2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the underlaying table buffer if exists (i.e. if this is not a calculated data record). 
    /// </summary>
    /// <returns>Underlaying table buffer</returns>
    public Common getCommon2()
    {
        if (tableId && recId)
        {
            if (recId == common.RecId && tableId == common.TableId)
            {
                return common;
            }

            return DocGlobalHelper::getTableRecord(tableId, recId, dataAreaId);
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// A new property needed for the distinction between RecordList and SingleRecord.
    /// If returns true, it means it isn't participating in a record list.
    /// *** NOTE: This property is introduced in 3.3.9 and used in Docentric NextGen only.
    /// </summary>
    /// <returns>True, if this is a single data record (no more than one record with the same name in a row)</returns>
    public boolean isSingleRecord()
    {
        return isSingleRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSingleRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// A new property needed for the distinction between RecordList and SingleRecord.
    /// Sets the IsSingleRecord property to true, only if this is a single data record,
    /// which means that it isn't participating in a record list.
    /// NOTE: Serializing to XML will thrown a warning if this property is not used properly.
    /// *** NOTE: This property is introduced in 3.3.9 and used in Docentric NextGen only.
    /// </summary>
    /// <param name = "_isSingleRecord">Is this data record a single record</param>
    /// <returns>
    /// This object (to enable fluent APIs).
    /// </returns>
    public DocXmlRecord setSingleRecord(boolean _isSingleRecord)
    {
        isSingleRecord = _isSingleRecord;
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldsSortedAlphabetically</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sorts all fields of the record alphabetically.
    /// </summary>
    /// <returns>
    /// Field list sorted alphabetically by field name.
    /// </returns>
    public List getFieldsSortedAlphabetically()
    {
        List                sortedFields;
        ListIterator        iteratorSF;
        ListEnumerator      enumeratorSF;
        MapEnumerator       mapEnumerator;
        DocXmlField         currentField, currentSortedField;
        int                 i, posToInsert;
    
    
        sortedFields = new List(Types::Class);
    
        mapEnumerator = fields.getEnumerator();
        while(mapEnumerator.moveNext())
        {
            // Insert currentField to the right place in sortedFields list.
            currentField = mapEnumerator.currentValue();
    
            posToInsert = -1;
    
            i = 1;
            enumeratorSF = sortedFields.getEnumerator();
            while (enumeratorSF.moveNext())
            {
                currentSortedField = enumeratorSF.current();
    
                if (currentSortedField.getFieldName() > currentField.getFieldName())
                {
                    posToInsert = i;
                    break;
                }
    
                i++;
            }
    
            if (posToInsert == 1)
            {
                sortedFields.addStart(currentField);
                continue;
            }
    
            if (posToInsert == -1)
            {
                sortedFields.addEnd(currentField);
                continue;
            }
    
            i = 1;
            iteratorSF = new ListIterator(sortedFields);
            while (iteratorSF.more())
            {
                if (i == posToInsert)
                {
                    iteratorSF.insert(currentField);
                    break;
                }
                iteratorSF.next();
                i++;
            }
        }
    
        return sortedFields;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstChildRecordByName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets first child record by name.
    /// </summary>
    /// <param name="_recordName">
    /// Name of the potential child record.
    /// </param>
    /// <returns>
    /// First child record with the given name if such exists. Otherwise returns null.
    /// </returns>
    public DocXmlRecord getFirstChildRecordByName(str _recordName)
    {
        ListEnumerator   enumerator;
        DocXmlRecord     currentChildRecord;
    
    
        enumerator = childRecords.getEnumerator();
        while (enumerator.moveNext())
        {
            currentChildRecord = enumerator.current();
            if (currentChildRecord.getRecordName() == _recordName)
            {
                return currentChildRecord;
            }
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record language ID.
    /// </summary>
    /// <returns>
    /// The record language ID.
    /// </returns>
    public LanguageId getLanguageId()
    {
        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent record.
    /// </summary>
    /// <returns>
    /// The parent record if such exists; otherwise (in case of the top record) returns null.
    /// </returns>
    public DocXmlRecord getParent()
    {
        return parent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecordLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets label value (not label ID) of the record.
    /// </summary>
    /// <returns>
    /// Label value of the record.
    /// </returns>
    public str getRecordLabel()
    {
        return recordLabelValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecordLabelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets label ID of the record.
    /// </summary>
    /// <returns>
    /// Label ID of the record.
    /// </returns>
    public LabelId getRecordLabelId()
    {
        return recordLabelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecordName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Name of the record.
    /// </summary>
    /// <returns>
    /// Name of the record which will result in the XML element in the resulting XML.
    /// </returns>
    public str getRecordName()
    {
        return recordName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculatedRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the flag indicating whether the record is a calculated record.
    /// </summary>
    /// <returns>True if the record is a calculated record; otherwise false</returns>
    public boolean isCalculatedRecord()
    {
        return isCalculatedRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEqual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the provided record is equal to the current record.
    /// </summary>
    /// <param name = "_record">A record</param>
    /// <returns>True if the provided record is equal to the current record; otherwise false</returns>
    public boolean isEqual(DocXmlRecord _record)
    {
        return this.recordId() == _record.recordId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>merge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Merges the fields and child records of the given record with the record.
    /// </summary>
    /// <param name="_mergingRecord">
    /// Record to merge.
    /// </param>
    /// <param name="_recordBuildingContext">
    /// Record building context that contains caching structures, etc.
    /// </param>
    public void merge(DocXmlRecord _mergingRecord, DocXmlRecordBuildingContext _recordBuildingContext = this.recordBuildingContext())
    {
        DocXmlRecord     mergingChildRecord, newChildRecord, childRecord;
        DocXmlField      mergingField, newField;
        ListEnumerator   childRecordEnum;
        MapEnumerator    fieldEnum;
    
    
        // Merge fields.
        fieldEnum = _mergingRecord.fields().getEnumerator();
        while (fieldEnum.moveNext())
        {
            mergingField = fieldEnum.currentValue();
            if (!this.containField(mergingField.getFieldName()))
            {
                newField = mergingField.clone(this.recordBuildingContext());
                this.appendField(newField);
            }
        }
    
        // Merge child records.
        childRecordEnum = _mergingRecord.childRecords().getEnumerator();
        while (childRecordEnum.moveNext())
        {
            mergingChildRecord = childRecordEnum.current();
            childRecord = this.getFirstChildRecordByName(mergingChildRecord.getRecordName());
            if (childRecord == null)
            {
                newChildRecord = mergingChildRecord.clone(false, this.recordBuildingContext());
                this.appendChildRecordNC(newChildRecord);
    
                newChildRecord.merge(mergingChildRecord);
            }
            else
            {
                childRecord.merge(mergingChildRecord);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the DocXmlRecord class.
    /// </summary>
    /// <param name = "_isCalculatedRecord">Indicates whether the record is calculated</param>
    /// <param name = "_common">A common record</param>
    /// <param name = "_calculatedRecordName">A name of the calculated record</param>
    /// <param name = "_recordLabelIdOrValue">A labelId or value of the calculated record</param>
    /// <param name = "_languageId">Language Id</param>
    /// <param name = "_recordBuildingContext">An instance of the DocXmlRecordBuildingContext class</param>
    protected void new(boolean _isCalculatedRecord, Common _common,
                       str _calculatedRecordName, str _recordLabelIdOrValue,
                       LanguageId _languageId, DocXmlRecordBuildingContext _recordBuildingContext)
    {
        recordBuildingContext = _recordBuildingContext;
    
        isCalculatedRecord = _isCalculatedRecord;
    
        if (isCalculatedRecord)
        {
            recordName = _calculatedRecordName;
        }
        else
        {
            tableId = _common.TableId;
            sysDictTable = recordBuildingContext.getSysDictTable(tableId);
            common = _common;
            recId = _common.RecId;
            dataAreaId = _common.DataAreaId;
    
            recordName = sysDictTable.name();
        }
    
        recordId = newGuid();
    
        childRecords = new List(Types::Class);
        fields = new Map(Types::String, Types::Class);  // Map(fieldName, DocXmlField object)
        parent = null;
    
        languageId = _languageId;
        if (languageId && !LanguageTable::exist(languageId))
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:LanguageNotExist", languageId));
        }
    
        this.setRecordLabelIdAndValue(_recordLabelIdOrValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rec ID of the record if it is not calculated record (but table buffer based).
    /// </summary>
    /// <returns>
    /// Rec ID of the record if it is not calculated record; otherwise 0.
    /// </returns>
    public RecId recId()
    {
        return recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordBuildingContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instace of the DocXmlRecordBuildingContext class.
    /// </summary>
    /// <returns>An instace of the DocXmlRecordBuildingContext class</returns>
    public DocXmlRecordBuildingContext recordBuildingContext()
    {
        return recordBuildingContext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unique ID of the record.
    /// </summary>
    /// <returns>
    /// Record ID. Each record has its unique ID.
    /// </returns>
    public guid recordId()
    {
        return recordId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeChildRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes provided child record.
    /// </summary>
    /// <param name="_recordId">
    /// Child record ID.
    /// </param>
    /// <returns>
    /// True if the child is removed; otherwise false.
    /// </returns>
    public boolean removeChildRecord(guid _recordId)
    {
        ListIterator    iterator;
        DocXmlRecord    currentRecord;
    
    
        if (guid2str(_recordId) ==  Global::nullValueFromType(Types::Guid))
        {
            return false;
        }
    
        iterator = new ListIterator(childRecords);
    
        while (iterator.more())
        {
            currentRecord = iterator.value();
            if (currentRecord.recordId() == _recordId)
            {
                currentRecord.setParent(null);
                iterator.delete();
                return true;
            }
            iterator.next();
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes given field.
    /// </summary>
    /// <param name="_fieldName">
    /// Field name.
    /// </param>
    /// <returns>
    /// Returns true if the field is removed; otherwise false.
    /// </returns>
    public boolean removeField(str _fieldName)
    {
        DocXmlField     removingField;
    
        if (!_fieldName)
        {
            return false;
        }
    
        if (fields.exists(_fieldName))
        {
            removingField = fields.lookup(_fieldName);
            removingField.setParent(null);
            fields.remove(_fieldName);
            removingField = null;
    
            return true;
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serializeToXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serialize the record to XML element.
    /// </summary>
    /// <param name="_parentXmlDoc">
    /// Parent XML document.
    /// </param>
    /// <returns>
    /// Serialized to XML record to XML.
    /// </returns>
    public XmlElement serializeToXml(XmlDocument _parentXmlDoc)
    {
        XmlElement       currentXmlElement, childXmlElement;
        ListEnumerator   childRecordsEnum;
        MapEnumerator    fieldsEnum;
        DocXmlField      currentField;
        DocXmlRecord     childRecord;
    
    
        currentXmlElement = this.createXmlElement(_parentXmlDoc);
    
        //-- Add all child records as XML child elements.
        childRecordsEnum = this.childRecords().getEnumerator();

        /* NOTE: SingleRecord is introduced in 3.3.9 for Docentric NextGen */
        boolean isPreviousChildSingleRecord = false;
        str previousChildRecordName = '';

        while (childRecordsEnum.moveNext())
        {
            childRecord = childRecordsEnum.current();

            // Check if the previous child record was marked as a single data record.
            if (isPreviousChildSingleRecord && previousChildRecordName == childRecord.getRecordName())
            {
                DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:DataConsistencyCheckErrorMsg", previousChildRecordName));
            }

            // Store the information whether the current child record is marked as a single data record.
            isPreviousChildSingleRecord = childRecord.isSingleRecord();
            previousChildRecordName = childRecord.getRecordName();

            // Serialize the current child record to XML.
            childXmlElement = childRecord.serializeToXml(_parentXmlDoc);
            currentXmlElement.appendChild(childXmlElement);
        }
    
        //-- Add all fields as XML attributes.
        fieldsEnum = this.fields().getEnumerator();
        while (fieldsEnum.moveNext())
        {
            currentField = fieldsEnum.currentValue();
            // Serialize the field to XML fragment and append it the current XML element.
            currentField.serializeToXmlAndAppend(_parentXmlDoc, currentXmlElement);
        }
    
        return currentXmlElement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the new table buffer for the record.
    /// WARNING: Changed table buffer will not affect already added fields, field groups or display methods.
    /// </summary>
    /// <param name="_common">
    /// Table buffer for the same table and record which were defined at the construction time of the DocXmlRecord object.
    /// </param>
    /// <remarks>
    /// Applicable only for table buffer based records.
    /// Use this method if you didn't fetch all fields of the table buffer at the construction time of the DocXmlRecord object.
    /// </remarks>
    public void setCommon(Common _common)
    {
        if (this.isCalculatedRecord())
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setCommon: Table buffer cannot be set for a calculated record. Current record: %1', this.getRecordName()));
        }
    
        if (this.tableId() != _common.TableId)
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method setCommon: New table buffer (%1) differs from the underlying table buffer (%2)',
                                             tableId2name(this.tableId()), tableId2name(_common.TableId)));
        }
    
        if (this.recId() != 0 && _common.RecId != 0)
        {
            if (this.recId() != _common.RecId)
            {
                DocGlobalHelper::handleException(funcName(), strFmt('Method setCommon: New table buffer record (RecId: %1) differs from the underlying table buffer record (RecId: %2)',
                                                 this.recId(), _common.RecId));
            }
        }
    
        common = _common;
        recId = _common.RecId;
        dataAreaId = _common.DataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new language of the record and automatically reset the record label value
    /// as well, in case that the record label ID is set.
    /// If the _setLanguageFields parameter is set to True, sets also the language of the record fields.
    /// If the _setLanguageChildRecords parameter is set to True, sets also the language of the all child records.
    /// </summary>
    /// <param name="_languageId">
    /// Language ID.
    /// </param>
    /// <param name="_setLanguageFields">
    /// If true then the language of the all record fields should be set as well.
    /// </param>
    /// <param name="_setLanguageChildRecords">
    /// If true then the language of the all child records should be set as well.
    /// </param>
    public void setLanguageId(LanguageId _languageId, boolean _setLanguageFields = true, boolean _setLanguageChildRecords = true)
    {
        DocXmlRecord     childRecord;
        DocXmlField      field;
        ListEnumerator   listEnumerator;
        MapEnumerator    mapEnumerator;
    
    
        languageId = _languageId;
    
        if (recordLabelId)
        {
            // Reset the record label value.
            this.setRecordLabelIdAndValue(recordLabelId);
        }
    
        // Set language of the record fields.
        if (_setLanguageFields)
        {
            mapEnumerator = this.fields().getEnumerator();
            while (mapEnumerator.moveNext())
            {
                field = mapEnumerator.currentValue();
                field.setLanguageId(_languageId);
            }
        }
    
        // Set language of the child records.
        if (_setLanguageChildRecords)
        {
            listEnumerator = this.childRecords().getEnumerator();
            while (listEnumerator.moveNext())
            {
                childRecord = listEnumerator.current();
                childRecord.setLanguageId(_languageId, _setLanguageFields, _setLanguageChildRecords);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the parent record.
    /// </summary>
    /// <param name = "_parent">Parent record</param>
    public void setParent(DocXmlRecord _parent)
    {
        if (_parent != null && parent != null && _parent != parent)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Cannot set the parent record (%1) of the record appending as a child (%2) because it already has a parent (%3) in the record tree. Remove or clone this record first.',
                           _parent.getRecordName(), this.getRecordName(), parent.getRecordName()));
        }
    
        parent = _parent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecordLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new record label value (not label ID).
    /// </summary>
    /// <param name="_recordLabelValue">
    /// Label value of the record, that will be a friendly name of the data record
    /// in the resulting data source.
    /// </param>
    /// <returns>
    /// This object (to enable fluent APIs).
    /// </returns>
    public DocXmlRecord setRecordLabel(str _recordLabelValue)
    {
        if (_recordLabelValue && DocLabelHelper::isLabelIdForDsProvider(_recordLabelValue))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setRecordLabel: Provided parameter (%1) is a valid label ID. Use the setRecordLabelId() method instead.', _recordLabelValue));
        }
    
        this.setRecordLabelIdAndValue(_recordLabelValue);

        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecordLabelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new record label Id and record label value resolved in the language of the record.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </summary>
    /// <param name="_recordLabelId">
    /// Record label ID.
    /// </param>
    /// <returns>
    /// This object (to enable fluent APIs).
    /// </returns>
    public DocXmlRecord setRecordLabelId(LabelId _recordLabelId)
    {
        if (_recordLabelId && !DocLabelHelper::isLabelIdForDsProvider(_recordLabelId))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method setRecordLabelId: Provided parameter (%1) is not a valid label ID', _recordLabelId));
        }
    
        this.setRecordLabelIdAndValue(_recordLabelId);

        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecordLabelIdAndValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets record label ID and resolves record label value in the language of the record
    /// in case that the _labelIdOrValue parameter is a label ID. Otherwise, sets record label ID
    /// to an empty string and record label value to the value of the _labelIdOrValue parameter.
    /// </summary>
    /// <param name="_labelIdOrValue">
    /// Label ID (code) or value (text).
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    private void setRecordLabelIdAndValue(str _labelIdOrValue)
    {
        if (_labelIdOrValue)
        {
            // Check if this is a label ID.
            if (strScan(_labelIdOrValue, '@', 1, 1))
            {
                recordLabelId = _labelIdOrValue;
                if (this.recordBuildingContext().isDesignTime())
                {
                    // Note: Resolving the label will be skiped in the runtime because of the performance.
                    recordLabelValue = this.getlabelRepository().resolveDdspLabel(_labelIdOrValue, languageId);
                }
                else
                {
                    recordLabelValue = '';
                }

                // Add the new label to the common label map.
                this.recordBuildingContext().ensureLabel(recordLabelId);
            }
            else
            {
                recordLabelId = '';
                recordLabelValue = _labelIdOrValue;
            }
        }
        else
        {
            recordLabelId = '';
            recordLabelValue = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecordName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes record name which was initially set during construction via <c>constructRecord</c> method.
    /// </summary>
    /// <param name="_newRecordName">
    /// New record name.
    /// </param>
    /// <returns>
    /// This object (to enable fluent APIs).
    /// </returns>
    /// <remarks>
    /// Use this method to change XML element name in resulting XML.
    /// </remarks>
    public DocXmlRecord setRecordName(str _newRecordName)
    {
        XmlDocument  testXmlDoc;
        XmlElement   testNameXmlElement;
    
        if (!_newRecordName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method setRecordName: Parameter _newRecordName is not provided');
        }
    
        testXmlDoc = XmlDocument::newBlank();
        try
        {
            //BP Deviation Documented.
            testNameXmlElement = testXmlDoc.createElement(_newRecordName);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setRecordName: Parameter _newRecordName (%1) has invalid value for XML element', _newRecordName));
        }
    
        recordName = _newRecordName;

        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets SysDictTable of the record if it is not calculated record.
    /// </summary>
    /// <returns>
    /// SysDictTable of the record if it is not calculated record.
    /// </returns>
    public SysDictTable sysDictTable()
    {
        return sysDictTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Table ID of the record if it is not calculated record.
    /// </summary>
    /// <returns>
    /// Table ID of the record if it is not calculated record.
    /// </returns>
    public TableId tableId()
    {
        return tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes the record to the XML document converted to a string.
    /// </summary>
    /// <returns>
    /// XML representation of the record.
    /// </returns>
    public str toXml()
    {
        XmlDocument   xmlDocument;
        XmlElement    rootXmlElement;
        str           xmlDocumentStr;
    
    
        xmlDocument = xmlDocument::newBlank();
        try
        {
            rootXmlElement = this.serializeToXml(xmlDocument);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), 'Error occurred while serializing to XML');
        }
    
        xmlDocument.appendChild(rootXmlElement);
    
        xmlDocumentStr = xmlDocument.toString();
    
        return xmlDocumentStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toXmlMemoryStream</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes the record to the XML document saved to a memory stream.
    /// </summary>
    /// <returns>
    /// Memory stream containing the XML representation of the record.
    /// </returns>
    public System.IO.Stream toXmlMemoryStream()
    {
        System.IO.MemoryStream xmlStream = new System.IO.MemoryStream();

        // Get the data record as XML string.
        str dataRecordXmlStr = this.toXml();

        System.Xml.XmlDocument xmlDoc = new System.Xml.XmlDocument();

        try
        {
            xmlDoc.LoadXml(dataRecordXmlStr);
            xmlDoc.Save(xmlStream);
        
            xmlStream.Flush();
            xmlStream.Position = 0;
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), 'Error while saving XML document to memory stream');
        }
        catch (Exception::Internal)
        {
            DocGlobalHelper::handleClrException(funcName(), 'Error while saving XML document to memory stream');
        }

        return xmlStream;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toXmlFile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serializes the record to the XML document saved in a file.
    /// </summary>
    /// <param name="_filename">
    /// File name (e.g. 'DataRecord.xml') to save the resulting XML document.
    /// </param>
    public void toXmlFile(str _filename = 'DataRecord.xml')
    {
        using (System.IO.MemoryStream xmlMemoryStream = this.toXmlMemoryStream())
        {
            DocFileMngHelper::sendFileToUser(xmlMemoryStream, _filename, '', '', '', '', true, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCalculatedRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs calculated record.
    /// NOTE: If used within the generateXmlDataSource() method of the data source provider class,
    /// either the language of the record builder or the language from the data source provider class
    /// (stored in dsProvider.parmParams().parmLanguageId()) should be used for the _languageId parameter.
    /// Alternatively, the createCalculatedRecord() method of the record builder can be used.
    /// </summary>
    /// <param name="_calculatedRecordName">
    /// Name of the calculated record. It will be used as a name of the resulting XML element.
    /// </param>
    /// <param name="_recordLabelIdOrValue">
    /// A label ID or value of the record. This label value will be mapped in the Friendly name
    /// of the data record in the resulting XML data source.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <param name="_languageId">
    /// Language of the record. If set, label ID will be resolved in this language.
    /// </param>
    /// <param name="_recordBuildingContext">
    /// Record building context that contains caching structures, etc.
    /// </param>
    /// <returns>
    /// Constructed XmlRecord which will be mapped to an XML element in the resulting XML
    /// named as this record.
    /// </returns>
    public static DocXmlRecord constructCalculatedRecord(str _calculatedRecordName, str _recordLabelIdOrValue = '',
                                                         LanguageId _languageId = currentUserLanguage(),
                                                         DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        if (!_calculatedRecordName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method constructCalculatedRecord: Parameter _calculatedRecordName is not provided');
        }
    
        if (!_recordBuildingContext.isValidCalculatedRecordName(_calculatedRecordName))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method constructCalculatedRecord: Parameter _calculatedRecordName (%1) has invalid value for XML Element', _calculatedRecordName));
        }
    
        return new DocXmlRecord(true, null, _calculatedRecordName, _recordLabelIdOrValue, _languageId, _recordBuildingContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs record which is table buffer based.
    /// NOTE: If used within the generateXmlDataSource() method of the data source provider class,
    /// either the language of the record builder or the language from the data source provider class
    /// (stored in dsProvider.parmParams().parmLanguageId()) should be used for the _languageId parameter.
    /// Alternatively, the createRecord() method of the record builder can be used.
    /// </summary>
    /// <param name="_common">
    /// Table buffer.
    /// </param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying table is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <param name="_languageId">
    /// Language of the record. If set, label ID will be resolved in this language.
    /// </param>
    /// <param name="_recordBuildingContext">
    /// Record building context that contains caching structures, etc.
    /// </param>
    /// <returns>
    /// Constructed XmlRecord which will be mapped to an XML element in the resulting XML
    /// named as the provided table buffer.
    /// </returns>
    public static DocXmlRecord constructRecord(Common _common, str _overridingLabelIdOrValue = '',
                                               LanguageId _languageId = currentUserLanguage(),
                                               DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        str labelIdOrValue;
    
        if (!_common.TableId)
        {
            DocGlobalHelper::handleException(funcName(), 'Method constructRecord: Parameter _common is not set');
        }
    
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = _recordBuildingContext.getLabelForTable(_common.TableId);
        }
    
        return new DocXmlRecord(false, _common, '', labelIdOrValue, _languageId, _recordBuildingContext);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>