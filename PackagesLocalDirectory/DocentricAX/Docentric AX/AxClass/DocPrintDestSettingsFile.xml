<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocPrintDestSettingsFile</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Represents document print settings for destination: File.
/// </summary>
class DocPrintDestSettingsFile implements SysPackable
{
    // Filename
    DocOutputFilename                   outputFilename;
    // Filename suffix
    boolean                             useGuidAsSuffix;
    boolean                             useTimestampAsSuffix;
    boolean                             useDocIdInFilename;
    str                                 printMgmtDocId;
    
    // Output file format
    DocOutputFileFormat                 outputFileFormat;
    SRSReportFileFormat                 outputFileFormatSrs;
    boolean                             useSsrsBuiltInDesign;

    // Send output file to user
    boolean                             sendOutputFileToUser;

    // Download separate files (if set to yes, default ZIP behaviour will be ignored)
    boolean                             sendSeparateFilesToUser;
    
    // Save to attachments
    boolean                             saveToAttachments;
    DocuTypeId                          saveToAttachmentsDocuTypeId;
    DocSaveToAttachmentsRecordType      saveToAttachmentsRecordType;
    Common                              saveToAttachmentsRecord; // not packed
    DocDocumentRestriction              saveToAttachmentsDocumentRestriction;
    DocAttachmentsOverridingMode        saveToAttachmentsOverridingMode;
    DocAttachmentCategoryId             saveToAttachmentsCategory;
    DocAttachmentTags                   saveToAttachmentsTags;
    DocReportTemplateLanguageId         saveToAttachmentsLanguage; // The member is obsolete and replaced with the member saveToAttachmentsLanguageMode
    DocAttachmentLanguageMode           saveToAttachmentsLanguageMode;
    DocReportAttachmentActiveFrom       saveToAttachmentsActiveFrom;
    DocReportAttachmentActiveTo         saveToAttachmentsActiveTo;
    boolean                             saveToAttachmentsWithDocumentHashNumber;
    DocReportSharePointMetadataSettings saveToAttachmentsSharePointMetadata;        // not packed
    
    // Save to SharePoint
    boolean                             saveToSharePoint;
    str                                 sharePointSiteUrl;
    str                                 sharePointFolderPath;
    boolean                             sharePointOverrideFileIfExists;
    boolean                             sharePointCreateNonExistingFolders;
    DocReportSharePointMetadataSettings sharePointMetadata; // not packed
    
    // Save to Azure Blob storage
    boolean                             saveToAzureBlobStorage;
    str                                 azureBsContainerName;
    str                                 azureBsBlobPath;
    boolean                             azureBsOverrideFileIfExists;
    str                                 azureBsAccountId;

    // Save to Azure Files
    boolean                             saveToAzureFiles;
    str                                 azureFilesFileShareName;
    str                                 azureFilesDirectoryPath;
    boolean                             azureFilesOverrideFileIfExists;
    boolean                             azureFilesCreateNonExistingFileShare;
    boolean                             azureFilesCreateNonExistingFolders;
    str                                 azureFilesAccountId;

    // Save to File system
    boolean                             saveToFileSystem;
    str                                 fileSystemFilePath;
    boolean                             fileSystemOverrideFileIfExists;

    // Internal members
    str                                 resolvedOutputFilenameCached;


    #define.currentPackVersion(8)  // Added sendSeparateFilesToUser, saveToAttachmentsWithDocumentHashNumber and the fields related to Azure Files
    #localmacro.currentList
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType,
        saveToAttachmentsDocumentRestriction,
        saveToAttachmentsOverridingMode,
        sharePointCreateNonExistingFolders,
        azureBsAccountId,
        saveToAttachmentsCategory,
        saveToAttachmentsTags,
        saveToAttachmentsLanguageMode,
        saveToAttachmentsActiveFrom,
        saveToAttachmentsActiveTo,
        saveToAzureFiles,
        azureFilesFileShareName,
        azureFilesDirectoryPath,
        azureFilesOverrideFileIfExists,
        azureFilesCreateNonExistingFileShare,
        azureFilesCreateNonExistingFolders,
        azureFilesAccountId,
        sendSeparateFilesToUser,
        saveToAttachmentsWithDocumentHashNumber
    #endMacro

    #define.packVersion7(7)  // Added saveToAttachmentsLanguageMode, removed saveToAttachmentsLanguage
    #localmacro.listVersion7
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType,
        saveToAttachmentsDocumentRestriction,
        saveToAttachmentsOverridingMode,
        sharePointCreateNonExistingFolders,
        azureBsAccountId,
        saveToAttachmentsCategory,
        saveToAttachmentsTags,
        saveToAttachmentsLanguageMode,
        saveToAttachmentsActiveFrom,
        saveToAttachmentsActiveTo
    #endMacro

    #define.packVersion6(6)  // Added azureBsAccountId, saveToAttachmentsCategory, saveToAttachmentsTags, saveToAttachmentsLanguage, saveToAttachmentsActiveFrom, saveToAttachmentsActiveTo
    #localmacro.listVersion6
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType,
        saveToAttachmentsDocumentRestriction,
        saveToAttachmentsOverridingMode,
        sharePointCreateNonExistingFolders,
        azureBsAccountId,
        saveToAttachmentsCategory,
        saveToAttachmentsTags,
        saveToAttachmentsLanguage,
        saveToAttachmentsActiveFrom,
        saveToAttachmentsActiveTo
    #endMacro

    #define.packVersion5(5)  // Added sharePointCreateNonExistingFolders
    #localmacro.listVersion5
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType,
        saveToAttachmentsDocumentRestriction,
        saveToAttachmentsOverridingMode,
        sharePointCreateNonExistingFolders
    #endMacro

    #define.packVersion4(4)  // Added saveToAttachmentsDocumentRestriction, saveToAttachmentsOverridingMode
    #localmacro.listVersion4
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType,
        saveToAttachmentsDocumentRestriction,
        saveToAttachmentsOverridingMode
    #endMacro

    #define.packVersion3(3)  // Added saveToAttachmentsRecordType
    #localmacro.listVersion3
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists,
        saveToAttachmentsRecordType
    #endMacro

    #define.packVersion2(2)
    #localmacro.listVersion2
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists,
        saveToFileSystem,
        fileSystemFilePath,
        fileSystemOverrideFileIfExists
    #endMacro

    #define.packVersion1(1)
    #localmacro.listVersion1
        version,
        outputFilename,
        useGuidAsSuffix,
        useTimestampAsSuffix,
        useDocIdInFilename,
        printMgmtDocId,
        outputFileFormat,
        outputFileFormatSrs,
        useSsrsBuiltInDesign,
        sendOutputFileToUser,
        saveToAttachments,
        saveToAttachmentsDocuTypeId,
        saveToSharePoint,
        sharePointSiteUrl,
        sharePointFolderPath,
        sharePointOverrideFileIfExists,
        saveToAzureBlobStorage,
        azureBsContainerName,
        azureBsBlobPath,
        azureBsOverrideFileIfExists
    #endMacro


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the DocPrintDestSettingsFile class.
    /// </summary>
    public void new()
    {
        sendOutputFileToUser = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the current object to the packed container.
    /// </summary>
    /// <returns>Packed container</returns>
    public container pack()
    {
        int version = #currentPackVersion;
    
        return [#currentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResolvedOutputFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolved the report output filename.
    /// </summary>
    /// <param name="_useCachedResolvedFilename">
    /// If set, the cached resolved output filename will be used, if it exists.
    /// </param>
    /// <returns>
    /// Report output filename.
    /// </returns>
    public Filename getResolvedOutputFilename(boolean _useCachedResolvedFilename = false)
    {
        str           outputFilenameResolved;
        str           filePath, filenameOnly, fileType;
        str           printMgmtDocIdCleaned;
        
        // Check if you can use the cached resolved output filename.
        if (_useCachedResolvedFilename && resolvedOutputFilenameCached != '')
        {
            outputFilenameResolved = resolvedOutputFilenameCached;
            return outputFilenameResolved;
        }
    
        // Output filename is the base for the resolved filename.
        // Afterwards, we will add Document ID, Timestamp and/or Guid.
        outputFilenameResolved = strLTrim(strRTrim(outputFilename));

        [filenameOnly, fileType, filePath] = Docu::splitFilename(outputFilenameResolved);

        // Append Document ID (applicable only for Print Management reports) if the flag useDocIdInFilename is set.
        if (useDocIdInFilename && printMgmtDocId && outputFilenameResolved)
        {
            printMgmtDocIdCleaned = DocFileMngHelper::replaceInvalidCharsForFileName(printMgmtDocId);
            
            if (filenameOnly)
            {
                filenameOnly = filenameOnly + DocConstantFile::PrintMgmtFilenameConcatSymbol + printMgmtDocIdCleaned;
            }
            else
            {
                filenameOnly = printMgmtDocIdCleaned;
            }
            
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }
    
        // Timestamp sufix.
        if (filenameOnly && useTimestampAsSuffix)
        {
            filenameOnly = filenameOnly + DocConstantFile::FilenameUndescore + System.DateTime::Now.ToString('yyyy-MM-dd HH-mm-ss');
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }
    
        // Guid sufix.
        if (filenameOnly && useGuidAsSuffix)
        {
            filenameOnly = filenameOnly + DocConstantFile::FilenameUndescore + DocGlobalHelper::guid2strWithoutBraces(newGuid());
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }

        if (filenameOnly == '' && outputFilenameResolved != '')
        {
            outputFilenameResolved = '';
        }

        // Cache the resolved filename for the future use.
        resolvedoutputFilenameCached = outputFilenameResolved;
    
        return outputFilenameResolved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOutputFilenameUsingPlaceholders</Name>
				<Source><![CDATA[
    public boolean isOutputFilenameUsingPlaceholders()
    {
        boolean usingPlaceholders = false;

        if (DocPlaceholderManager::findAnyPlaceholderCandidate(this.parmOutputFilename()))
        {
            usingPlaceholders = true;
        }

        usingPlaceholders = usingPlaceholders || this.parmUseDocIdInFilename() || this.parmUseGuidAsSuffix() || this.parmUseTimestampAsSuffix();

        return usingPlaceholders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSymbolicResolvedOutputFilename</Name>
				<Source><![CDATA[
    public str getSymbolicResolvedOutputFilename()
    {
        str           outputFilenameResolved;
        str           filePath, filenameOnly, fileType;
        
    
        // Output filename is the base for the resolved filename.
        // Afterwards, we will add Document ID, Timestamp and/or Guid.
        outputFilenameResolved = strLTrim(strRTrim(outputFilename));

        [filenameOnly, fileType, filePath] = Docu::splitFilename(outputFilenameResolved);

        // Append Document ID (applicable only for Print Management reports) if the flag useDocIdInFilename is set.
        if (useDocIdInFilename && outputFilenameResolved)
        {
            if (filenameOnly)
            {
                filenameOnly = filenameOnly + DocConstantFile::PrintMgmtFilenameConcatSymbol +
                               DocConstantPlaceholder::PlaceholderStartSymbol + 'DOCID' + DocConstantPlaceholder::PlaceholderEndSymbol;
            }
            else
            {
                filenameOnly = DocConstantPlaceholder::PlaceholderStartSymbol + 'DOCID' + DocConstantPlaceholder::PlaceholderEndSymbol;
            }
            
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }

        // Timestamp sufix.
        if (filenameOnly && useTimestampAsSuffix)
        {
            filenameOnly = filenameOnly + DocConstantFile::FilenameUndescore +
                           DocConstantPlaceholder::PlaceholderStartSymbol + 'TIMESTAMP' + DocConstantPlaceholder::PlaceholderEndSymbol;
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }
    
        // Guid sufix.
        if (filenameOnly && useGuidAsSuffix)
        {
            filenameOnly = filenameOnly + DocConstantFile::FilenameUndescore +
                           DocConstantPlaceholder::PlaceholderStartSymbol + 'GUID' + DocConstantPlaceholder::PlaceholderEndSymbol;
            outputFilenameResolved = filenameOnly + DocConstantFile::FileExtensionDelimiter + fileType;
        }

        if (filenameOnly == '' && outputFilenameResolved != '')
        {
            outputFilenameResolved = '';
        }
    
        return outputFilenameResolved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOutputFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the output report file name. The final output file name is resolved
    /// in the getResolvedoutputFilename() method.
    /// </summary>
    /// <param name="_outputFilename">
    /// Output report file name.
    /// </param>
    /// <returns>
    /// Output report file name.
    /// </returns>
    /// <remarks>
    /// It can be used in combination with standard and custom placeholders.
    /// http://ax.docentric.com/how-to-manuals/report-print-destinations/how-to-use-placeholders-in-print-destination-settings/
    /// </remarks>
    public DocOutputFilename parmOutputFilename(DocOutputFilename _outputFilename = outputFilename)
    {
        outputFilename = _outputFilename;
        return outputFilename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOutputFileFormat</Name>
				<Source><![CDATA[
    public DocOutputFileFormat parmOutputFileFormat(DocOutputFileFormat _outputFileFormat = outputFileFormat)
    {
        outputFileFormat = _outputFileFormat;
        return outputFileFormat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOutputFileFormatSrs</Name>
				<Source><![CDATA[
    public SRSReportFileFormat parmOutputFileFormatSrs(SRSReportFileFormat _outputFileFormatSrs = outputFileFormatSrs)
    {
        outputFileFormatSrs = _outputFileFormatSrs;
        return outputFileFormatSrs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseSsrsBuiltInDesign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag whether Docentric design should be used.
    /// </summary>
    /// <param name = "_useSsrsBuiltInDesign">Should Docentric design be used</param>
    /// <returns>Should Docentric design be used</returns>
    public boolean parmUseSsrsBuiltInDesign(boolean _useSsrsBuiltInDesign = useSsrsBuiltInDesign)
    {
        useSsrsBuiltInDesign = _useSsrsBuiltInDesign;
        return useSsrsBuiltInDesign;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResolvedOutputFileType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the file extension as a string using the output file format which should be used.
    /// </summary>
    /// <returns>Output file type as a string</returns>
    public str getResolvedOutputFileType()
    {
        str fileType;

        if (!useSsrsBuiltInDesign)
        {
            fileType = DocFileMngHelper::convertToFileExtensionStr(outputFileFormat);
        }
        else
        {
            fileType = DocFileMngHelper::convertSrsFileFormatToFileExtensionStr(outputFileFormatSrs);
        }

        return fileType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendSeparateFilesToUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets a flag that determines if the files to be sent are to be combined in a ZIP file or sent as separate files. This parameter is only checked when parmSendOutputFileToUser() is set to "true".
    /// </summary>
    /// <param name = "_sendSeparateFilesToUser">Should the generated report files be sent as separate files to the user.</param>
    /// <returns>Should the generated report files be sent as separate files to the user.</returns>
    public boolean parmSendSeparateFilesToUser(boolean _sendSeparateFilesToUser = sendSeparateFilesToUser)
    {
        sendSeparateFilesToUser = _sendSeparateFilesToUser;
        return sendSeparateFilesToUser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendOutputFileToUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets a flag that determines if the files are to be sent (downloaded) to the user.
    /// </summary>
    /// <param name = "_sendOutputFileToUser">Should the generated report files be sent (downloaded) to the user.</param>
    /// <returns>Should the generated report files be sent (downloaded) to the user.</returns>
    public boolean parmSendOutputFileToUser(boolean _sendOutputFileToUser = sendOutputFileToUser)
    {
        sendOutputFileToUser = _sendOutputFileToUser;
        return sendOutputFileToUser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets a flag that determines if the report should be saved to the Attachments of
    /// the report context execution table, i.e. to the Attachment of the underlying entity
    /// which is a data source of the report menu item.
    /// </summary>
    /// <param name="_saveToAttachments">
    /// Should the report be saved to the attachment of the underlying entity.
    /// </param>
    /// <returns>
    /// Should the report be saved to the attachment of the underlying entity.
    /// </returns>
    /// <remarks>
    /// This flag is not applicable if report runs without any underlying entity,
    /// i.e. from the Report menu on Area pages of particular modules.
    /// </remarks>
    public boolean parmSaveToAttachments(boolean _saveToAttachments = saveToAttachments)
    {
        saveToAttachments = _saveToAttachments;
        return saveToAttachments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsDocuTypeId</Name>
				<Source><![CDATA[
    public DocuTypeId parmSaveToAttachmentsDocuTypeId(DocuTypeId _saveToAttachmentsDocuTypeId = saveToAttachmentsDocuTypeId)
    {
        saveToAttachmentsDocuTypeId = _saveToAttachmentsDocuTypeId;
        return saveToAttachmentsDocuTypeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsRecordType</Name>
				<Source><![CDATA[
    public DocSaveToAttachmentsRecordType parmSaveToAttachmentsRecordType(DocSaveToAttachmentsRecordType _saveToAttachmentsRecordType = saveToAttachmentsRecordType)
    {
        saveToAttachmentsRecordType = _saveToAttachmentsRecordType;

        if (!prmIsDefault(_saveToAttachmentsRecordType))
        {
            // We need to anull saveToAttachmentsRecord to prevent inconsistent combination of the record type and the record itself.
            saveToAttachmentsRecord = null;
        }

        return saveToAttachmentsRecordType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsDocumentRestriction</Name>
				<Source><![CDATA[
    public DocDocumentRestriction parmSaveToAttachmentsDocumentRestriction(DocDocumentRestriction _saveToAttachmentsDocumentRestriction = saveToAttachmentsDocumentRestriction)
    {
        saveToAttachmentsDocumentRestriction = _saveToAttachmentsDocumentRestriction;
        return saveToAttachmentsDocumentRestriction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsOverridingMode</Name>
				<Source><![CDATA[
    public DocAttachmentsOverridingMode parmSaveToAttachmentsOverridingMode(DocAttachmentsOverridingMode _saveToAttachmentsOverridingMode = saveToAttachmentsOverridingMode)
    {
        saveToAttachmentsOverridingMode = _saveToAttachmentsOverridingMode;
        return saveToAttachmentsOverridingMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsCategory</Name>
				<Source><![CDATA[
    public DocAttachmentCategoryId parmSaveToAttachmentsCategory(DocAttachmentCategoryId _saveToAttachmentsCategory = saveToAttachmentsCategory)
    {
        saveToAttachmentsCategory = _saveToAttachmentsCategory;
        return saveToAttachmentsCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsTags</Name>
				<Source><![CDATA[
    public DocAttachmentTags parmSaveToAttachmentsTags(DocAttachmentTags _saveToAttachmentsTags = saveToAttachmentsTags)
    {
        saveToAttachmentsTags = _saveToAttachmentsTags;
        return saveToAttachmentsTags;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsLanguageMode</Name>
				<Source><![CDATA[
    public DocAttachmentLanguageMode parmSaveToAttachmentsLanguageMode(DocAttachmentLanguageMode _saveToAttachmentsLanguageMode = saveToAttachmentsLanguageMode)
    {
        saveToAttachmentsLanguageMode = _saveToAttachmentsLanguageMode;
        return saveToAttachmentsLanguageMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsActiveFrom</Name>
				<Source><![CDATA[
    public DocReportAttachmentActiveFrom parmSaveToAttachmentsActiveFrom(DocReportAttachmentActiveFrom _saveToAttachmentsActiveFrom = saveToAttachmentsActiveFrom)
    {
        saveToAttachmentsActiveFrom = _saveToAttachmentsActiveFrom;
        return saveToAttachmentsActiveFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsActiveTo</Name>
				<Source><![CDATA[
    public DocReportAttachmentActiveTo parmSaveToAttachmentsActiveTo(DocReportAttachmentActiveTo _saveToAttachmentsActiveTo = saveToAttachmentsActiveTo)
    {
        saveToAttachmentsActiveTo = _saveToAttachmentsActiveTo;
        return saveToAttachmentsActiveTo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsSharePointMetadata</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the SharePoint metadata settings used when report is saved to Attachments.
    /// </summary>
    /// <param name = "_saveToAttachmentsSharePointMetadata">SharePoint metadata settings</param>
    /// <returns>SharePoint metadata settings</returns>
    public DocReportSharePointMetadataSettings parmSaveToAttachmentsSharePointMetadata(DocReportSharePointMetadataSettings _saveToAttachmentsSharePointMetadata = saveToAttachmentsSharePointMetadata)
    {
        saveToAttachmentsSharePointMetadata = _saveToAttachmentsSharePointMetadata;
        return saveToAttachmentsSharePointMetadata;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEnabledSaveToAttachmentsSharePointMetadata</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the saving to SharePoint with metadata fields via Attachments is enabled.
    /// </summary>
    /// <returns>True, if saving to SharePoint with metadata fields via Attachments document type is enabled</returns>
    public boolean isEnabledSaveToAttachmentsSharePointMetadata()
    {
        if (saveToAttachmentsSharePointMetadata != null && saveToAttachmentsSharePointMetadata.parmIsSavingEnabled())
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAttachmentsWithDocumentHashNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether the document hash number should be calculated and stored on the attachment.
    /// </summary>
    /// <param name = "_saveToAttachmentsWithDocumentHashNumber">indicating whether the document hash number should be calculated and stored on the attachment</param>
    /// <returns>True, if the document hash number should be calculated and stored; otherwise false</returns>
    public boolean parmSaveToAttachmentsWithDocumentHashNumber(boolean _saveToAttachmentsWithDocumentHashNumber = saveToAttachmentsWithDocumentHashNumber)
    {
        saveToAttachmentsWithDocumentHashNumber = _saveToAttachmentsWithDocumentHashNumber;
        return saveToAttachmentsWithDocumentHashNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSaveToAttachmentsRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Call this method in the overrideReportRunSettings() method of your custom DSP class
    /// to set the record that the report will be attached to. If you don't set the Saving
    /// to Attachments record, it will be resolved automatically if possible.
    /// </summary>
    /// <param name = "_saveToAttachmentsRecord">Saving to Attachments record</param>
    /// <returns>True if the provided record is set, i.e. if saveToAttachmentsRecordType == DocSaveToAttachmentsRecordType::CustomRecord</returns>
    public boolean setSaveToAttachmentsRecord(Common _saveToAttachmentsRecord)
    {
        if (saveToAttachmentsRecordType != DocSaveToAttachmentsRecordType::CustomRecord)
        {
            return false;
        }

        saveToAttachmentsRecord = _saveToAttachmentsRecord;
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSaveToAttachmentsRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns Saving to Attachments record if set. If not set and _printReportSettings is provided,
    /// the Saving to Attachments record is being calculated (if possible).
    /// </summary>
    /// <param name = "_printReportSettings">If provided it can be used for calculating the Saving to Attachments record</param>
    /// <returns>Saving to Attachments record</returns>
    public Common getSaveToAttachmentsRecord(DocPrintReportSettings _printReportSettings = null)
    {
        if (saveToAttachmentsRecord)
        {
            return saveToAttachmentsRecord;
        }

        // If _printReportSettings is not provided, we cannot resolve the record.
        if (_printReportSettings == null)
        {
            return null;
        }

        // Try to resolve the record that the report is going to be attached to
        // using _printReportSettings and/or _printReportSettings.parmArchiveContract().
        switch (this.parmSaveToAttachmentsRecordType())
        {
            case DocSaveToAttachmentsRecordType::ContextRecord:
                saveToAttachmentsRecord = _printReportSettings.getReportExecutionContextRecord();
                break;

            case DocSaveToAttachmentsRecordType::Journal:
                if (_printReportSettings.parmArchiveContract() != null)
                {
                    saveToAttachmentsRecord = _printReportSettings.parmArchiveContract().getJournalTableRecord();
                }
                break;

            case DocSaveToAttachmentsRecordType::AccountTable:
                if (_printReportSettings.parmArchiveContract() != null)
                {
                    saveToAttachmentsRecord = _printReportSettings.parmArchiveContract().getAccountTableRecord();
                }
                break;

            case DocSaveToAttachmentsRecordType::SourceTable:
                if (_printReportSettings.parmArchiveContract() != null)
                {
                    saveToAttachmentsRecord = _printReportSettings.parmArchiveContract().getSourceTableRecord();
                }
                break;

            case DocSaveToAttachmentsRecordType::LegalEntity:
                {
                    saveToAttachmentsRecord = CompanyInfo::findByCompany_IN(_printReportSettings.parmCompanyId());
                }
                break;

            case DocSaveToAttachmentsRecordType::CustomRecord:
                // To be handled in the custom DSP class.
                break;

            default:
                DocGlobalHelper::handleException(funcName(), strFmt('Unsupported Save to Attachments record type: %1', this.parmSaveToAttachmentsRecordType()));
        }

        return saveToAttachmentsRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSaveToAttachmentsRecordStr</Name>
				<Source><![CDATA[
    public str getSaveToAttachmentsRecordStr(DocPrintReportSettings _printReportSettings)
    {
        str saveToAttachmentsRecordStr;

        switch (this.parmSaveToAttachmentsRecordType())
        {
            case DocSaveToAttachmentsRecordType::AccountTable:
                if (_printReportSettings.parmArchiveContract() && _printReportSettings.parmArchiveContract().parmAccountNum())
                {
                    saveToAttachmentsRecordStr = strFmt("@DocentricAX3:RecordTypeAccountNumDesc", _printReportSettings.parmArchiveContract().parmAccountNum());
                }
                break;

            case DocSaveToAttachmentsRecordType::SourceTable:
                if (_printReportSettings.parmArchiveContract() && _printReportSettings.parmArchiveContract().parmSourceTableId())
                {
                    saveToAttachmentsRecordStr = strFmt("@DocentricAX3:RecordTypeIdDesc", _printReportSettings.parmArchiveContract().parmSourceTableType(), _printReportSettings.parmArchiveContract().parmSourceTableId());
                }
                break;

            case DocSaveToAttachmentsRecordType::LegalEntity:
                {
                    saveToAttachmentsRecordStr = strFmt("@DocentricAX3:RecordTypeCompanyId", _printReportSettings.parmCompanyId());
                }
                break;
        }

        return saveToAttachmentsRecordStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseDocIdInFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets a flag that determines if the output file name should ends
    /// with a Document ID. Applicable only for Print Management reports.
    /// </summary>
    /// <param name="_useDocIdInFilename">Should the output report filename end with a Document ID.</param>
    /// <returns>Should the output report filename end with a Document ID.</returns>
    public boolean parmUseDocIdInFilename(boolean _useDocIdInFilename = useDocIdInFilename)
    {
        useDocIdInFilename = _useDocIdInFilename;
        return useDocIdInFilename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtDocId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets Print Management document ID.
    /// </summary>
    /// <param name="_printMgmtDocId">Print Management document ID.</param>
    /// <returns>Print Management document ID.</returns>
    public str printMgmtDocId(str _printMgmtDocId = printMgmtDocId)
    {
        printMgmtDocId = _printMgmtDocId;
        return printMgmtDocId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseGuidAsSuffix</Name>
				<Source><![CDATA[
    public boolean parmUseGuidAsSuffix(boolean _useGuidAsSuffix = useGuidAsSuffix)
    {
        useGuidAsSuffix = _useGuidAsSuffix;
        return useGuidAsSuffix;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseTimestampAsSuffix</Name>
				<Source><![CDATA[
    public boolean parmUseTimestampAsSuffix(boolean _useTimestampAsSuffix = useTimestampAsSuffix)
    {
        useTimestampAsSuffix = _useTimestampAsSuffix;
        return useTimestampAsSuffix;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToFileSystem</Name>
				<Source><![CDATA[
    public boolean parmSaveToFileSystem(boolean _saveToFileSystem = saveToFileSystem)
    {
        saveToFileSystem = _saveToFileSystem;
        return saveToFileSystem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFileSystemFilePath</Name>
				<Source><![CDATA[
    public str parmFileSystemFilePath(str _fileSystemFilePath = fileSystemFilePath)
    {
        fileSystemFilePath = _fileSystemFilePath;
        return fileSystemFilePath;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFileSystemOverrideFileIfExists</Name>
				<Source><![CDATA[
    public boolean parmFileSystemOverrideFileIfExists(boolean _fileSystemOverrideFileIfExists = fileSystemOverrideFileIfExists)
    {
        fileSystemOverrideFileIfExists = _fileSystemOverrideFileIfExists;
        return fileSystemOverrideFileIfExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFileSystemFullFileName</Name>
				<Source><![CDATA[
    public str getFileSystemFullFileName(str _resolvedOutputFilename = '')
    {
        str fileName = _resolvedOutputFilename;
        if (filename == '')
        {
            filename = this.getResolvedOutputFilename(false);
        }

        str filePath = fileSystemFilePath;
        if (filePath != '')
        {
            if (!strEndsWith(filePath, DocConstantFile::FilePathDelimiter))
            {
                filePath = filePath + DocConstantFile::FilePathDelimiter;
            }
        }
        if (filePath == DocConstantFile::FilePathDelimiter)
        {
            filePath = '';
        }

        return filePath + filename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFileSystemFullFileSymbolicName</Name>
				<Source><![CDATA[
    public str getFileSystemFullFileSymbolicName()
    {
        str filePath = fileSystemFilePath;
        if (filePath != '')
        {
            if (!strEndsWith(filePath, DocConstantFile::FilePathDelimiter))
            {
                filePath = filePath + DocConstantFile::FilePathDelimiter;
            }
        }
        if (filePath == DocConstantFile::FilePathDelimiter)
        {
            filePath = '';
        }

        return filePath + this.getSymbolicResolvedOutputFilename();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToSharePoint</Name>
				<Source><![CDATA[
    public boolean parmSaveToSharePoint(boolean _saveToSharePoint = saveToSharePoint)
    {
        saveToSharePoint = _saveToSharePoint;
        return saveToSharePoint;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharePointSiteUrl</Name>
				<Source><![CDATA[
    public str parmSharePointSiteUrl(str _sharePointSiteUrl = sharePointSiteUrl)
    {
        sharePointSiteUrl = _sharePointSiteUrl;
        return sharePointSiteUrl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharePointFolderPath</Name>
				<Source><![CDATA[
    public str parmSharePointFolderPath(str _sharePointFolderPath = sharePointFolderPath)
    {
        sharePointFolderPath = _sharePointFolderPath;
        return sharePointFolderPath;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharePointOverrideFileIfExists</Name>
				<Source><![CDATA[
    public boolean parmSharePointOverrideFileIfExists(boolean _sharePointOverrideFileIfExists = sharePointOverrideFileIfExists)
    {
        sharePointOverrideFileIfExists = _sharePointOverrideFileIfExists;
        return sharePointOverrideFileIfExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharePointCreateNonExistingFolders</Name>
				<Source><![CDATA[
    public boolean parmSharePointCreateNonExistingFolders(boolean _sharePointCreateNonExistingFolders = sharePointCreateNonExistingFolders)
    {
        sharePointCreateNonExistingFolders = _sharePointCreateNonExistingFolders;
        return sharePointCreateNonExistingFolders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSharePointMetadata</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the SharePoint metada settings used when saving report to SharePoint.
    /// </summary>
    /// <param name = "_sharePointMetadata">SharePoint metadata settings</param>
    /// <returns>SharePoint metadata settings</returns>
    public DocReportSharePointMetadataSettings parmSharePointMetadata(DocReportSharePointMetadataSettings _sharePointMetadata = sharePointMetadata)
    {
        sharePointMetadata = _sharePointMetadata;
        return sharePointMetadata;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEnabledSaveToSharePointMetadata</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the saving to SharePoint with metadata fields is enabled.
    /// </summary>
    /// <returns>True, if saving to SharePoint with metadata fields is enabled</returns>
    public boolean isEnabledSaveToSharePointMetadata()
    {
        if (sharePointMetadata != null && sharePointMetadata.parmIsSavingEnabled())
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAzureBlobStorage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether the file should be saved to Azure Blob storage.
    /// </summary>
    /// <param name = "_saveToAzureBlobStorage">Should the file be saved to Azure Blob storage</param>
    /// <returns>True if the file should be saved to Azure Blob storage; otherwise false</returns>
    public boolean parmSaveToAzureBlobStorage(boolean _saveToAzureBlobStorage = saveToAzureBlobStorage)
    {
        saveToAzureBlobStorage = _saveToAzureBlobStorage;
        return saveToAzureBlobStorage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureBsContainerName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the Azure Blob storage container name.
    /// </summary>
    /// <param name = "_azureBsContainerName">The Azure Blob storage container name</param>
    /// <returns>The Azure Blob storage container name</returns>
    public str parmAzureBsContainerName(str _azureBsContainerName = azureBsContainerName)
    {
        azureBsContainerName = _azureBsContainerName;
        return azureBsContainerName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureBsBlobPath</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the Azure Blob storage path.
    /// </summary>
    /// <param name = "_azureBsBlobPath">The Azure Blob storage path</param>
    /// <returns>The Azure Blob storage path</returns>
    public str parmAzureBsBlobPath(str _azureBsBlobPath = azureBsBlobPath)
    {
        azureBsBlobPath = _azureBsBlobPath;
        return azureBsBlobPath;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureBsOverrideFileIfExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether to overwrite the file if it already exists in Azure Blob storage.
    /// </summary>
    /// <param name = "_azureBsOverrideFileIfExists">Should the already existing file be overwritten</param>
    /// <returns>True if the already existing file should be overwritten; otherwise false</returns>
    public boolean parmAzureBsOverrideFileIfExists(boolean _azureBsOverrideFileIfExists = azureBsOverrideFileIfExists)
    {
        azureBsOverrideFileIfExists = _azureBsOverrideFileIfExists;
        return azureBsOverrideFileIfExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureBsAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the Azure storage account Id used for saving the report to Azure Blob storage.
    /// </summary>
    /// <param name = "_azureBsAccountId">Azure storage account Id</param>
    /// <returns>Azure storage account Id</returns>
    public str parmAzureBsAccountId(str _azureBsAccountId = azureBsAccountId)
    {
        azureBsAccountId = _azureBsAccountId;
        return azureBsAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAzureBsBlobName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Azure Blob storage path with the filename.
    /// </summary>
    /// <param name = "_resolvedOutputFilename">The resolved output filename</param>
    /// <returns>The Azure Blob storage path with the filename</returns>
    public str getAzureBsBlobName(str _resolvedOutputFilename = '')
    {
        str fileName = _resolvedOutputFilename;
        if (filename == '')
        {
            filename = this.getResolvedOutputFilename(false);
        }

        str blobPath = azureBsBlobPath;
        if (blobPath != '')
        {
            if (!strEndsWith(blobPath, DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter))
            {
                blobPath = blobPath + DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter;
            }
            if (strStartsWith(blobPath, DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter))
            {
                blobPath = subStr(blobPath, 2, strLen(blobPath) - 1);
            }
        }
        if (blobPath == DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter)
        {
            blobPath = '';
        }

        return blobPath + filename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAzureBsBlobSymbolicName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Azure blob path with the symbolic filename.
    /// </summary>
    /// <returns>Azure blob path with the symbolic filename</returns>
    public str getAzureBsBlobSymbolicName()
    {
        str blobPath = azureBsBlobPath;
        if (blobPath != '')
        {
            if (!strEndsWith(blobPath, DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter))
            {
                blobPath = blobPath + DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter;
            }
            if (strStartsWith(blobPath, DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter))
            {
                blobPath = subStr(blobPath, 2, strLen(blobPath) - 1);
            }
        }
        if (blobPath == DocConstantFile::AzureBlobStorageVirtualDirectoryDelimiter)
        {
            blobPath = '';
        }

        return blobPath + this.getSymbolicResolvedOutputFilename();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveToAzureFiles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether the file should be saved to Azure Files.
    /// </summary>
    /// <param name = "_saveToAzureFiles">Should the file be saved to Azure Files</param>
    /// <returns>True if the file should be saved to Azure Files; otherwise false</returns>
    public boolean parmSaveToAzureFiles(boolean _saveToAzureFiles = saveToAzureFiles)
    {
        saveToAzureFiles = _saveToAzureFiles;
        return saveToAzureFiles;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesAccountId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the Azure storage account Id used for saving the report to Azure Files.
    /// </summary>
    /// <param name = "_azureFilesAccountId">Azure storage account Id</param>
    /// <returns>Azure storage account Id</returns>
    public str parmAzureFilesAccountId(str _azureFilesAccountId = azureFilesAccountId)
    {
        azureFilesAccountId = _azureFilesAccountId;
        return azureFilesAccountId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesFileShareName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets Azure file share name.
    /// </summary>
    /// <param name = "_azureFilesFileShareName">Azure file share name</param>
    /// <returns>Azure file share name</returns>
    public str parmAzureFilesFileShareName(str _azureFilesFileShareName = azureFilesFileShareName)
    {
        azureFilesFileShareName = _azureFilesFileShareName;
        return azureFilesFileShareName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesDirectoryPath</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the directory path on the Azure file share.
    /// </summary>
    /// <param name = "_azureFilesDirectoryPath">Azure Files directoy path</param>
    /// <returns>Azure Files directoy path</returns>
    public str parmAzureFilesDirectoryPath(str _azureFilesDirectoryPath = azureFilesDirectoryPath)
    {
        azureFilesDirectoryPath = _azureFilesDirectoryPath;
        return azureFilesDirectoryPath;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesOverrideFileIfExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether to overwrite the file if it already exists in Azure Files
    /// </summary>
    /// <param name = "_azureFilesOverrideFileIfExists">Should the already existing file be overwritten</param>
    /// <returns>True if the already existing file should be overwritten; otherwise false</returns>
    public boolean parmAzureFilesOverrideFileIfExists(boolean _azureFilesOverrideFileIfExists = azureFilesOverrideFileIfExists)
    {
        azureFilesOverrideFileIfExists = _azureFilesOverrideFileIfExists;
        return azureFilesOverrideFileIfExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesCreateNonExistingFileShare</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether the nonexistent file share should be created in Azure Files.
    /// </summary>
    /// <param name = "_azureFilesCreateNonExistingFileShare">Should the nonexistent file share be created</param>
    /// <returns>True if the nonexistent file share should be created; otherwise false</returns>
    public boolean parmAzureFilesCreateNonExistingFileShare(boolean _azureFilesCreateNonExistingFileShare = azureFilesCreateNonExistingFileShare)
    {
        switch (DocParameters::find().AzureFileSharesCreatePermission)
        {
            case DocAzureFileSharesCreatePermission::Configurable:
                azureFilesCreateNonExistingFileShare = _azureFilesCreateNonExistingFileShare;
                break;

            case DocAzureFileSharesCreatePermission::Allowed:
                azureFilesCreateNonExistingFileShare = true;
                break;

            case DocAzureFileSharesCreatePermission::Forbidden:
                azureFilesCreateNonExistingFileShare = false;
                break;
        }
        return azureFilesCreateNonExistingFileShare;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureFilesCreateNonExistingFolders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets/Sets the flag indicating whether the nonexistent folders should be created in Azure Files.
    /// </summary>
    /// <param name = "_azureFilesCreateNonExistingFolders">Should the nonexistent folders be created</param>
    /// <returns>True if the nonexistent folders should be created; otherwise false</returns>
    public boolean parmAzureFilesCreateNonExistingFolders(boolean _azureFilesCreateNonExistingFolders = azureFilesCreateNonExistingFolders)
    {
        azureFilesCreateNonExistingFolders = _azureFilesCreateNonExistingFolders;
        return azureFilesCreateNonExistingFolders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAzureFilesFullFileName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the filepath including the filename in Azure Files.
    /// </summary>
    /// <param name = "_resolvedOutputFilename">The resolved output filename</param>
    /// <returns>Filepath including the filename in Azure Files</returns>
    public str getAzureFilesFullFileName(str _resolvedOutputFilename = '')
    {
        str fileName = _resolvedOutputFilename;
        if (filename == '')
        {
            filename = this.getResolvedOutputFilename(false);
        }

        str azureFilesPath = azureFilesDirectoryPath;
        if (azureFilesPath != '')
        {
            if (!strEndsWith(azureFilesPath, DocConstantFile::AzureFilesDirectoryPathDelimiter))
            {
                azureFilesPath = azureFilesPath + DocConstantFile::AzureFilesDirectoryPathDelimiter;
            }
            if (strStartsWith(azureFilesPath, DocConstantFile::AzureFilesDirectoryPathDelimiter))
            {
                azureFilesPath = subStr(azureFilesPath, 2, strLen(azureFilesPath) - 1);
            }
        }
        if (azureFilesPath == DocConstantFile::AzureFilesDirectoryPathDelimiter)
        {
            azureFilesPath = '';
        }

        return azureFilesPath + filename;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAzureFilesFullFileSymbolicName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Azure Files filepath with the symbolic filename.
    /// </summary>
    /// <returns>Azure Files filepath with the symbolic filename</returns>
    public str getAzureFilesFullFileSymbolicName()
    {
        str azureFilesPath = azureFilesDirectoryPath;
        if (azureFilesPath != '')
        {
            if (!strEndsWith(azureFilesPath, DocConstantFile::AzureFilesDirectoryPathDelimiter))
            {
                azureFilesPath = azureFilesPath + DocConstantFile::AzureFilesDirectoryPathDelimiter;
            }
            if (strStartsWith(azureFilesPath, DocConstantFile::AzureFilesDirectoryPathDelimiter))
            {
                azureFilesPath = subStr(azureFilesPath, 2, strLen(azureFilesPath) - 1);
            }
        }
        if (azureFilesPath == DocConstantFile::AzureFilesDirectoryPathDelimiter)
        {
            azureFilesPath = '';
        }

        return azureFilesPath + this.getSymbolicResolvedOutputFilename();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDefaultParmValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default parm values.
    /// </summary>
    /// <param name = "_reportId">Report Id</param>
    /// <param name = "_reportCaption">Report caption</param>
    public void setDefaultParmValues(DocReportId _reportId, DocReportCaption _reportCaption)
    {
        if (!this.parmOutputFilename())
        {
            str filenameWithType = DocReportingHelper::getDefaultOutputFilename(
                _reportId, false, _reportCaption, 0, this.getResolvedOutputFileType(), DocConstantFile::ReportFixedFilename, false);
            
            if (filenameWithType)
            {
                this.parmOutputFilename(filenameWithType);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the packed container to the current object.
    /// </summary>
    /// <param name = "_pack">Packed container</param>
    /// <returns>True/False</returns>
    public boolean unpack(container _pack)
    {
        boolean    ret = false;
        int        version;

        if (typeOf(conPeek(_pack, 1)) == Types::Integer)
        {
            version = conPeek(_pack, 1);
            
            if (version == #currentPackVersion)
            {
                [#currentList] = _pack;
                ret = true;
            }
            else if (version == #packVersion7)
            {
                [#listVersion7] = _pack;
                ret = true;
            }
            else if (version == #packVersion6)
            {
                [#listVersion6] = _pack;
                ret = true;
            }
            else if (version == #packVersion5)
            {
                [#listVersion5] = _pack;
                ret = true;
            }
            else if (version == #packVersion4)
            {
                [#listVersion4] = _pack;
                ret = true;
            }
            else if (version == #packVersion3)
            {
                [#listVersion3] = _pack;
                ret = true;
            }
            else if (version == #packVersion2)
            {
                [#listVersion2] = _pack;
                ret = true;
            }
            else if (version == #packVersion1)
            {
                [#listVersion1] = _pack;
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the File print destination settings.
    /// </summary>
    /// <param name = "_printValidationErrors">Should show the validation errors</param>
    /// <param name = "_checkPlaceholders">Should check the placeholders</param>
    /// <returns>True if validation is successful; otherwise false</returns>
    public boolean validate(boolean _printValidationErrors = true, boolean _checkPlaceholders = true)
    {
        Filename  fileNameOnly, fileType, filePath;
        Filename  resolvedOutputFilename;
        boolean   isValid, showWarningsAboutPlaceholders;
    
    
        isValid = true;
        showWarningsAboutPlaceholders = _checkPlaceholders && _printValidationErrors;

        resolvedOutputFilename = this.getResolvedOutputFilename();

        if (!resolvedOutputFilename)
        {
            isValid = false;
            if (_printValidationErrors)
            {
                DocGlobalHelper::handleWarning("@DocentricAX:ReportOutputFilenameNotSet");
            }
        }
    
        if (resolvedOutputFilename)
        {
            [fileNameOnly, fileType, filePath] = Docu::splitFilename(resolvedOutputFilename);

            // Check if the report output file name is set.
            if (!fileNameOnly)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:ReportOutputFilenameNotSet");
                }
            }
            
            /*** Validate the filename ***/
            if (_checkPlaceholders)
            {
                if (DocPlaceholderManager::findAnyPlaceholderCandidate(resolvedOutputFilename))
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ReportOutputFilenameContainsPlaceholders", resolvedoutputFilename));
                    }
                }
            }

            // Check if the report output file name is a valid filename, i.e. if it contains illegal characters.
            // Note that @PLACEHOLDER@ would not affect the result of the filename validation but @DOC_LABEL:UserDefinedLabelId@ would.
            // This is why before filename validation, we'll first remove all placeholders from resolvedOutputFilename.
            if (!DocFileMngHelper::isValidOnlyFilename(DocPlaceholderManager::removeAllPlaceholders(resolvedOutputFilename)))
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ReportOutputFilenameInvalid", resolvedOutputFilename));
                }
            }

            /***  Save To Attachments ***/
            if (saveToAttachments)
            {
                // Check if DocuTypeId is set.
                if (saveToAttachmentsDocuTypeId == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX:SaveToAttDocumentTypeIsNotSet");
                    }
                }

                // Check if the DocuType exists.
                else
                {
                    DocuType saveToAttachmentsDocuType = DocuType::find(saveToAttachmentsDocuTypeId);
                    if (saveToAttachmentsDocuType.RecId == 0)
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SaveToAttDocuTypeNotExist", saveToAttachmentsDocuTypeId));
                        }
                    }
                    
                    // Check if the action class is set.
                    else if (!saveToAttachmentsDocuType.ActionClassId)
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:DocuTypeAttachingActionClassNotSet", saveToAttachmentsDocuTypeId));
                        }
                    }

                    // Check if the action class is valid.
                    else if (!SysDictClass::isEqualOrSuperclass(saveToAttachmentsDocuType.ActionClassId, classNum(DocuActionFile)))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:DocuTypeAttachingInvalidActionClass",
                                                           saveToAttachmentsDocuTypeId, saveToAttachmentsDocuType.getActionClassDescription_DC()));
                        }
                    }
                }

                // Check if attachment category exists in the Attachment categories table.
                if (saveToAttachmentsCategory)
                {
                    if (!DocAttachmentCategory::findByCategory(saveToAttachmentsCategory))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:AttachmentCategoryNotFoundError", saveToAttachmentsCategory));
                        }
                    }
                }

                // Check if attachments active period is valid.
                if (saveToAttachmentsActiveTo && saveToAttachmentsActiveFrom > saveToAttachmentsActiveTo)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:ActiveFromGreatherThanActiveToError", saveToAttachmentsActiveFrom, saveToAttachmentsActiveTo));
                    }
                }
            }

            /***  Save To SharePoint ***/
            if (saveToSharePoint)
            {
                // Check if the SharePoint site url is set.
                if (sharePointSiteUrl == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX:SharePointSiteUrlNotSet");
                    }
                }

                // Check if the SharePoint site url is a valid URL.
                if (sharePointSiteUrl != '')
                {
                    if (!DocGlobalHelper::validateURL(sharePointSiteUrl))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SharePointSiteUrlInvalid", sharePointSiteUrl));
                        }
                    }

                    // Note that we will not check SharePoint site url for placeholders
                    // because most likely in this field placeholders will not be used.
                }

                // Check if the SharePoint folder path is set.
                if (sharePointFolderPath == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX:SpFolderIsNotSet");
                    }
                }

                // Check if the SharePoint folder path is valid.
                if (sharePointFolderPath != '')
                {
                    // Folder path should not start with '/'.
                    if (strStartsWith(sharePointFolderPath, DocConstantFile::SharePointFolderPathDelimiter))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SharePointFolderPathInvalidStart", sharePointFolderPath));
                        }
                    }

                    if (!DocSharePointHelperV3::isValidSharePointFolderPath(sharePointFolderPath))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SharePointFolderPathInvalid", sharePointFolderPath));
                        }
                    }

                    // Check placeholders.
                    if (_checkPlaceholders)
                    {
                        if (DocPlaceholderManager::findAnyStdPlaceholder(sharePointFolderPath))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SharePointFolderPathContainsPlaceholders", sharePointFolderPath));
                            }
                        }
                    }
                }
            }

            /***  Save To Azure Blob Storage ***/
            if (saveToAzureBlobStorage)
            {
                // Check if the Azure storage account exists, if set.
                if (azureBsAccountId)
                {
                    if (!DocAzureStorageAccount::exists(azureBsAccountId))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:AzureStorageAccountNotFoundError", azureBsAccountId));
                        }
                    }
                }

                // Check if the Azure container name is set.
                if (azureBsContainerName == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX:AzureContainerNameNotSet");
                    }
                }

                // Check if the Azure container name is valid.
                if (azureBsContainerName != '')
                {
                    // Check placeholders.
                    if (DocPlaceholderManager::findAnyPlaceholderCandidate(azureBsContainerName, showWarningsAboutPlaceholders))
                    {
                        if (_checkPlaceholders)
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:AzureContainerContainsPlaceholders", azureBsContainerName));
                            }
                        }
                    }
                    else // No placeholder found.
                    {
                        // Validate container name.
                        if (!DocAzureBlobHelper::isContainerNameValid(azureBsContainerName))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:InvalidContainerName", azureBsContainerName));
                            }
                        }
                    }
                }

                // Check if the Azure blob path is valid (if set).
                if (azureBsBlobPath != '')
                {
                    // Validate blob path characters.
                    if (!DocFileMngHelper::isValidFilePath(azureBsBlobPath))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:AzureBlobPathInvalid", azureBsBlobPath));
                        }
                    }

                    // Check placeholders.
                    if (_checkPlaceholders)
                    {
                        if (DocPlaceholderManager::findAnyStdPlaceholder(azureBsBlobPath))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:AzureBlobPathContainsPlaceholders", azureBsBlobPath));
                            }
                        }
                    }
                }
            }

            /***  Save To Azure Files ***/
            if (saveToAzureFiles)
            {
                // Check if the Azure storage account exists, if set.
                if (azureFilesAccountId)
                {
                    if (!DocAzureStorageAccount::exists(azureFilesAccountId))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:AzureStorageAccountNotFoundError", azureFilesAccountId));
                        }
                    }
                }

                // Check if the Azure files share name is set.
                if (azureFilesFileShareName == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX4:AzureFileShareNameIsNotSet");
                    }
                }

                // Check if the Azure files share name is valid.
                if (azureFilesFileShareName != '')
                {
                    // Check placeholders.
                    if (DocPlaceholderManager::findAnyPlaceholderCandidate(azureFilesFileShareName, showWarningsAboutPlaceholders))
                    {
                        if (_checkPlaceholders)
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:AzureFileShareContainsPlaceholders", azureFilesFileShareName));
                            }
                        }
                    }
                    else // No placeholder found.
                    {
                        // Validate Azure files share name.
                        if (!DocAzureFilesHelper::isFileShareNameValid(azureFilesFileShareName))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:AzureFileShareInvalidName", azureFilesFileShareName));
                            }
                        }
                    }
                }

                // Check if the Azure files path is valid (if set).
                if (azureFilesDirectoryPath != '')
                {
                    // Validate azure file path characters.
                    if (!DocFileMngHelper::isValidFilePath(azureFilesDirectoryPath))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:AzureFilesFolderPathInvalid", azureFilesDirectoryPath));
                        }
                    }

                    // Check placeholders.
                    if (_checkPlaceholders)
                    {
                        if (DocPlaceholderManager::findAnyStdPlaceholder(azureFilesDirectoryPath))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:AzureFilesFolderPathContainsPlaceholders", azureFilesDirectoryPath));
                            }
                        }
                    }
                }
            }

            /***  Save To File System ***/
            if (saveToFileSystem)
            {
                // Check if the output file path is set.
                if (fileSystemFilePath == '')
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning("@DocentricAX:ReportOutputFilepathIsNotSet");
                    }
                }

                // Check if the output file path is valid (if set).
                if (fileSystemFilePath != '')
                {
                    // Validate file path characters.
                    if (!DocFileMngHelper::isValidFilePath(fileSystemFilePath))
                    {
                        isValid = false;
                        if (_printValidationErrors)
                        {
                            DocGlobalHelper::handleWarning(strFmt("@DocentricAX:ReportOutputFilepathInvalid", fileSystemFilePath));
                        }
                    }

                    // Check placeholders.
                    if (DocPlaceholderManager::findAnyPlaceholderCandidate(fileSystemFilePath, showWarningsAboutPlaceholders))
                    {
                        if (_checkPlaceholders)
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:OutputFilePathContainsPlaceholders", fileSystemFilePath));
                            }
                        }
                    }
                    else // No placeholder found.
                    {
                        // Check if file path is a UNC path.
                        if (!DocFileMngHelper::isUncFilePath(fileSystemFilePath))
                        {
                            isValid = false;
                            if (_printValidationErrors)
                            {
                                DocGlobalHelper::handleWarning(strFmt("@DocentricAX:SharedFolderIsNotUncPath", fileSystemFilePath));
                            }
                        }
                    }
                }
            }

            // Check if the report output file type is set.
            if (!fileType)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning("@DocentricAX:ReportOutputFileTypeIsNotSet");
                }
            }
    
            // Check if the file type is corresponding to the outputFileFormat.
            str expectedFileType = this.getResolvedOutputFileType();

            // NOTE: Until we don't introduce Custom output file format, we will asume that XML file extension
            // can be replaced with some other file extension, to enable varios customization scenarios.
            if (expectedFileType != DocConstantFile::FileExtXml)
            {
                if (fileType && fileType != expectedFileType)
                {
                    isValid = false;
                    if (_printValidationErrors)
                    {
                        DocGlobalHelper::handleWarning(strFmt("@DocentricAX:FileExtensionInvalid", fileType, expectedFileType));
                    }
                }
            }

            // Check if the output file format is deprecated XPS.
            if (this.parmOutputFileFormat() == DocOutputFileFormat::XPS)
            {
                isValid = false;
                if (_printValidationErrors)
                {
                    DocGlobalHelper::handleWarning(strFmt("@DocentricAX4:FileFormatDeprecated", DocOutputFileFormat::XPS, DocOutputFileFormat::PDF));
                }
            }
        }
    
        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileExistsOnSharePoint</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given filename exists in SharePoint.
    /// </summary>
    /// <param name = "_showError">Should error be shown</param>
    /// <param name = "_throwError">Should error be thrown if occurs</param>
    /// <param name = "_resolvedOutputFilename">File name</param>
    /// <param name = "_checkPlaceholders">Should the placeholders be checked</param>
    /// <returns>True if the given file exists; otherwise false</returns>
    public boolean fileExistsOnSharePoint(
        boolean _showError = true,
        boolean _throwError = true,
        str _resolvedOutputFilename = '',
        boolean _checkPlaceholders = false)
    {
        boolean fileExists = false;
        if (saveToSharePoint)
        {
            // Check if the part of the filename is automatically generated and return false if it is
            if (useGuidAsSuffix || useTimestampAsSuffix)
            {
                return false;
            }

            str resolvedOutputFilename = _resolvedOutputFilename;
            if (resolvedOutputFilename == '')
            {
                resolvedOutputFilename = this.getResolvedOutputFilename(false);
            }

            if (resolvedOutputFilename && sharePointSiteUrl && sharePointFolderPath)
            {
                boolean placeholdersFound = _checkPlaceholders && DocPlaceholderManager::findAnyPlaceholderCandidate(resolvedOutputFilename) != '';
                // Don't check if placeholders are found.
                if (!placeHoldersFound)
                {
                    str sharePointFileUrl = DocFileMngHelper::addUrlDelimiter(sharePointSiteUrl) +
                                            DocFileMngHelper::addUrlDelimiter(sharePointFolderPath) +
                                            resolvedOutputFilename;
                    DocSharePointCredentials spCredentials = DocSharePointCredentials::constructFromSetup(sharePointSiteUrl, sharePointFolderPath, DocSharePointRole::ReportUser);

                    fileExists = DocSharePointHelperV3::fileExistsByUrl(sharePointFileUrl, sharePointSiteUrl, spCredentials, _showError, _throwError);
                }
            }
            else
            {
                if (_showError)
                {
                    DocGlobalHelper::handleError("@DocentricAX4:SaveToSharePointFileExistsOnSharePointError", true, funcName(), _throwError);
                }
            }
        }

        return fileExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileExistsOnAzure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given filename exists in Azure blob storage.
    /// </summary>
    /// <param name = "_showError">Should error be shown</param>
    /// <param name = "_throwError">Should error be thrown if occurs</param>
    /// <param name = "_resolvedOutputFilename">File name</param>
    /// <param name = "_checkPlaceholders">Should the placeholders be checked</param>
    /// <returns>True if the given file exists; otherwise false</returns>
    public boolean fileExistsOnAzure(
        boolean _showError = true, 
        boolean _throwError = true, 
        str _resolvedOutputFilename = '',
        boolean _checkPlaceholders = false)
    {
        boolean fileExists = false;
        if (saveToAzureBlobStorage)
        {
            // Check if the part of the filename is automatically generated and return false if it is
            if (useGuidAsSuffix || useTimestampAsSuffix)
            {
                return false;
            }

            str resolvedOutputFilename = _resolvedOutputFilename;
            if (resolvedOutputFilename == '')
            {
                resolvedOutputFilename = this.getResolvedOutputFilename(false);
            }

            if (resolvedOutputFilename && azureBsContainerName)
            {
                str blobName = this.getAzureBsBlobName(resolvedOutputFilename);
                boolean placeholdersFound = _checkPlaceholders &&
                                           (DocPlaceholderManager::findAnyPlaceholderCandidate(blobName) != '' ||
                                            DocPlaceholderManager::findAnyPlaceholderCandidate(azureBsContainerName) != '');
                // Don't check if placeholders are found.
                if (!placeHoldersFound)
                {
                    fileExists = DocAzureBlobHelper::blobExists(azureBsContainerName, blobName, _showError, _throwError, azureBsAccountId);
                }
            }
            else
            {
                if (_showError)
                {
                    DocGlobalHelper::handleError("@DocentricAX4:SaveToAzureBlobStorageFileExistsOnAzureBlobStorageError", true, funcName(), _throwError);
                }
            }
        }

        return fileExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileExistsOnAzureFiles</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given filename exists in Azure Files.
    /// </summary>
    /// <param name = "_showError">Should error be shown</param>
    /// <param name = "_throwError">Should error be thrown if occurs</param>
    /// <param name = "_resolvedOutputFilename">File name</param>
    /// <param name = "_checkPlaceholders">Should the placeholders be checked</param>
    /// <returns>True if the given file exists; otherwise false</returns>
    public boolean fileExistsOnAzureFiles(
        boolean _showError = true, 
        boolean _throwError = true,
        str _resolvedOutputFilename = '',
        boolean _checkPlaceholders = false)
    {
        boolean fileExists = false;
        if (saveToAzureFiles)
        {
            // Check if the part of the filename is automatically generated and return false if it is
            if (useGuidAsSuffix || useTimestampAsSuffix)
            {
                return false;
            }

            str resolvedOutputFilename = _resolvedOutputFilename;
            if (resolvedOutputFilename == '')
            {
                resolvedOutputFilename = this.getResolvedOutputFilename(false);
            }

            if (resolvedOutputFilename && azureFilesFileShareName)
            {
                str fileName = this.getAzureFilesFullFileName(resolvedOutputFilename);
                boolean placeholdersFound = _checkPlaceholders &&
                                           (DocPlaceholderManager::findAnyPlaceholderCandidate(fileName) != '' ||
                                            DocPlaceholderManager::findAnyPlaceholderCandidate(azureFilesFileShareName) != '');
                // Don't check if placeholders are found.
                if (!placeHoldersFound)
                {
                    fileExists = DocAzureFilesHelper::fileExists(azureFilesFileShareName, fileName, _showError, _throwError, azureFilesAccountId);
                }
            }
            else
            {
                if (_showError)
                {
                    DocGlobalHelper::handleError("@DocentricAX4:SaveToAzureFilesFileExistsOnAzureFilesError", true, funcName(), _throwError);
                }
            }
        }

        return fileExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fileExistsOnFileSystem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given filename exists in File system.
    /// </summary>
    /// <param name = "_showError">Should error be shown</param>
    /// <param name = "_throwError">Should error be thrown if occurs</param>
    /// <param name = "_resolvedOutputFilename">File name</param>
    /// <param name = "_checkPlaceholders">Should the placeholders be checked</param>
    /// <returns>True if the given file exists; otherwise false</returns>
    public boolean fileExistsOnFileSystem(
        boolean _showError = true,
        boolean _throwError = true,
        str _resolvedOutputFilename = '',
        boolean _checkPlaceholders = false)
    {
        boolean fileExists = false;
        if (saveToFileSystem)
        {
            // Check if the part of the filename is automatically generated and return false if it is
            if (useGuidAsSuffix || useTimestampAsSuffix)
            {
                return false;
            }

            str resolvedOutputFilename = _resolvedOutputFilename;
            if (resolvedOutputFilename == '')
            {
                resolvedOutputFilename = this.getResolvedOutputFilename(false);
            }

            if (resolvedOutputFilename && fileSystemFilePath)
            {
                str fullFileName = this.getFileSystemFullFileName(resolvedOutputFilename);
                boolean placeholdersFound = _checkPlaceholders &&
                                           (DocPlaceholderManager::findAnyPlaceholderCandidate(fullFileName) != '' ||
                                            DocPlaceholderManager::findAnyPlaceholderCandidate(fileSystemFilePath) != '');
                // Don't check if placeholders are found.
                if (!placeHoldersFound)
                {
                    fileExists = DocFileSystemMngHelper::fileExistsOnFileSystem(fullFileName);
                }
            }
            else
            {
                if (_showError)
                {
                    DocGlobalHelper::handleError("@DocentricAX4:SaveToFileSystemFileExistsOnFileSystemError", true, funcName(), _throwError);
                }
            }
        }

        return fileExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>escapeOutputFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleans the output filename from invalid characters.
    /// </summary>
    public void escapeOutputFilename()
    {
        outputFilename = DocFileMngHelper::replaceInvalidCharsForFileName(outputFilename);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFilename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the DocPrintDestSettingsFile class from specified filename and output file format.
    /// </summary>
    /// <param name = "_outputFilename">Output filename</param>
    /// <param name = "_outputFormat">Output file format</param>
    /// <returns>An instance of the DocPrintDestSettingsFile class</returns>
    public static DocPrintDestSettingsFile constructFilename(str _outputFilename, DocOutputFileFormat _outputFormat)
    {
        DocPrintDestSettingsFile printDestSettingsFile = new DocPrintDestSettingsFile();
    
        printDestSettingsFile.parmOutputFilename(_outputFilename);
        printDestSettingsFile.parmOutputFileFormat(_outputFormat);
    
        return printDestSettingsFile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the DocPrintDestSettingsFile class from packed container.
    /// </summary>
    /// <param name = "_packedFromPrintDestSettingsFile">Packed container with instance of DocPrintDestSettingsFile class</param>
    /// <returns>An instance of the DocPrintDestSettingsFile class</returns>
    public static DocPrintDestSettingsFile create(container _packedFromPrintDestSettingsFile)
    {
        DocPrintDestSettingsFile printDestSettingsFile;
    
        printDestSettingsFile = new DocPrintDestSettingsFile();
        printDestSettingsFile.unpack(_packedFromPrintDestSettingsFile);
    
        return printDestSettingsFile;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>