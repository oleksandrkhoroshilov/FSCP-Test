<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocEmailMngHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Net.Mail;
using System.IO;
using Docentric.AX.Email;

/// <summary>
/// The DocEmailMngHelper class is a helper class for emailing.
/// </summary>
public class DocEmailMngHelper
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>deleteEmptyAndDuplicatedEmailAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes empty and duplicated email addresses from the input email list, if any.
    /// </summary>
    /// <param name="_emailList">The input email list: email addresses separated by ',' or ';'.</param>
    /// <returns>Cleaned email list.</returns>
    /// <remarks>
    /// Empty or duplicated email address in an email list can exist after placeholders are replaced with the
    /// same or empty strings. (e.g. 'name@company.com;;name2@company.com' contains one empty email address)
    /// </remarks>
    public static str deleteEmptyAndDuplicatedEmailAddresses(str _emailList)
    {
        str             emailListCleaned, emailList, emailListPart;
        int             emailSeparatorPosition;
        Set             emailAddressSet;
        boolean         checkIfStartsOrEndsWithSeparator;
        
        if (_emailList == '')
        {
            return '';
        }
    
        // Remove leading and trailing spaces.
        emailList = strLTrim(strRTrim(_emailList));
    
        // Check if the email list starts or ends with ';' or ','.
        checkIfStartsOrEndsWithSeparator = true;
        while (checkIfStartsOrEndsWithSeparator && emailList != '')
        {
            checkIfStartsOrEndsWithSeparator = false;
    
            if (strStartsWith(emailList, ';') || strStartsWith(emailList, ','))
            {
                emailList = subStr(emailList, 2, strLen(emailList) - 1);
                checkIfStartsOrEndsWithSeparator = true;

                // Remove leading and trailing spaces.
                emailList = strLTrim(strRTrim(emailList));
            }
    
            if (strEndsWith(emailList, ';') || strEndsWith(emailList, ','))
            {
                emailList = subStr(emailList, 1, strLen(emailList) - 1);
                checkIfStartsOrEndsWithSeparator = true;

                // Remove leading and trailing spaces.
                emailList = strLTrim(strRTrim(emailList));
            }
        }
    
        if (emailList == '')
        {
            return '';
        }
    
        // Check if there is at least two addresses in the given email list.
        if (strFind(emailList, ';,', 1, strLen(emailList)) == 0)
        {
            // This is a single email address. We don't have anything to clean. Return.
            return emailList;
        }
    
        emailAddressSet = new Set(Types::String);
        emailListCleaned = '';
        // Find each occurrence of an email separator (';' or ',') and remove
        // 'empty' email addresses from the input email list.
        // At the same time, check if some addresses are repeated in the list.
        emailSeparatorPosition = strFind(emailList, ';,', 1, strLen(emailList));
        while (emailSeparatorPosition > 0)
        {
            emailListPart = subStr(emailList, 1, emailSeparatorPosition - 1);
            emailListPart = strRTrim(emailListPart);
    
            if (emailListPart != '') // can be '' in case that we have, e.g.'name@xxx.com;;name2@yyy.com'.
            {
                if (!emailAddressSet.in(emailListPart))
                {
                    // Append to the cleaned email list in case that it is not already added.
                    if (emailListCleaned)
                    {
                        emailListCleaned = emailListCleaned + ';' + emailListPart;
                    }
                    else
                    {
                        emailListCleaned = emailListPart;
                    }
    
                    emailAddressSet.add(emailListPart);
                }
            }
    
            emailList = subStr(emailList, emailSeparatorPosition + 1, strLen(emailList));
            emailList = strLTrim(emailList);
            emailSeparatorPosition = strFind(emailList, ';,', 1, strLen(emailList));
        }
    
        if (!emailAddressSet.in(emailList))
        {
            // Append to the cleaned email list in case that it is not already added.
            if (emailListCleaned)
            {
                emailListCleaned = emailListCleaned + ';' + emailList;
            }
            else
            {
                emailListCleaned = emailList;
            }
        }
    
        return emailListCleaned;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInvalidEmailAddresses</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes invalid email addresses from the provided email list.
    /// </summary>
    /// <param name = "_emailList">The email list from which to remove the invalid email addresses.</param>
    /// <returns>A list of all invalid email addresses removed.</returns>
    public static List removeInvalidEmailAddresses(List _emailList)
    {
        List removedEmailList = new List(Types::String);

        // If the list is empty there is nothing to check, so return.
        if (_emailList == null || !_emailList.elements())
        {
            return removedEmailList;
        }

        ListIterator emailListIterator = new ListIterator(_emailList);

        while (emailListIterator.more())
        {
            // Trims whitespaces from the beggining and end of the email.
            str currentEmail = strLRTrim(emailListIterator.value());

            if (!DocGlobalHelper::validateEmail(currentEmail))
            {
                removedEmailList.addEnd(currentEmail);
                // Deletes the current list item and moves the iterator cursor to the next list item.
                emailListIterator.delete();
            }
            else
            {
                emailListIterator.next();
            }
        }

        return removedEmailList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEncoding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the .NET encoding for specified encoding type.
    /// </summary>
    /// <param name = "_encoding">Encoding type</param>
    /// <returns>The .NET encoding</returns>
    public static System.Text.Encoding getEncoding(DocEncoding _encoding)
    {
        switch (_encoding)
        {
            case DocEncoding::UTF8:
                return System.Text.Encoding::get_UTF8();
    
            case DocEncoding::UTF7:
                return System.Text.Encoding::get_UTF7();
    
            case DocEncoding::UTF32:
                return System.Text.Encoding::get_UTF32();
    
            case DocEncoding::Unicode:
                return System.Text.Encoding::get_Unicode();
    
            case DocEncoding::ASCII:
                return System.Text.Encoding::get_ASCII();
    
            case DocEncoding::BigEndianUnicode:
                return System.Text.Encoding::get_BigEndianUnicode();
    
            default:
                DocGlobalHelper::handleException(funcName(), strFmt('Unsupported type of encoding (%1)', _encoding));
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSmtpClientFromSysParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the instance of Smtp mail client considering SysEmailParameters.
    /// </summary>
    /// <returns>Instanced SMTP mail client</returns>
    public static DocSmtpMailClient getSmtpClientFromSysParameters()
    {
        DocSmtpMailClient smtpMailClient;
        
        DocParameters docParameters = DocParameters::find();
        SysEmailParameters emailParameters = SysEmailParameters::find();
    
        System.String mailServerName = emailParameters.smtpRelayServerName;
        System.Int32 mailServerPort = emailParameters.smtpPortNumber;
    
        if (System.String::IsNullOrEmpty(mailServerName))
        {
            setPrefix(DocConstant::Docentric);
            throw error("@DocentricAX:MailServerNameHasToBeSet", '', SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(SysEmailParameters),
                                            formControlStr(SysEmailParameters, SMTP_SMTPRelayServerName), "@DocentricAX:FixProblem"));
        }
    
        if (!mailServerPort)
        {
            setPrefix(DocConstant::Docentric);
            throw error("@DocentricAX:MailServerPortHasToBeSet", '', SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(SysEmailParameters),
                                            formControlStr(SysEmailParameters, SMTP_SMTPPortNumber), "@DocentricAX:FixProblem"));
        }
    
        // Instantiate the SMTP client
        smtpMailClient = DocSmtpMailClient::construct(
                                                mailServerName, 
                                                mailServerPort,
                                                emailParameters.SMTPUseNTLM,
                                                emailParameters.SMTPUserName ? true : false,
                                                emailParameters.SMTPUserName,
                                                SysEmailParameters::password(),
                                                emailParameters.SMTPRequireSSL,
                                                docParameters.SmtpSettingsSmtpClientTimeout,
                                                docParameters.SmtpDeliveryFormat);

        return smtpMailClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSmtpClientFromAdditionalAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the SMTP client from the provided Additional From email account.
    /// </summary>
    /// <param name = "_additionalAccount">Additional From email account</param>
    /// <returns>Instanced SMTP mail client</returns>
    public static DocSmtpMailClient getSmtpClientFromAdditionalAccount(DocEmailAccount _additionalAccount)
    {
        DocSmtpMailClient smtpMailClient;
        
        DocParameters docParameters = DocParameters::find();
    
        System.String mailServerName = _additionalAccount.RelayServerName;
        System.Int32 mailServerPort = _additionalAccount.PortNumber;
    
        if (System.String::IsNullOrEmpty(mailServerName))
        {
            setPrefix(DocConstant::Docentric);
            throw error(strFmt("@DocentricAX2:AdditionalAccountMailServerNameMissing", _additionalAccount.UserName), '',
                                            SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(DocParameters),
                                            formControlStr(DocParameters, AdditionalEmailAccountsGrid_RelayServerName), "@DocentricAX:FixProblem"));
        }
    
        if (!mailServerPort)
        {
            setPrefix(DocConstant::Docentric);
            throw error(strFmt("@DocentricAX2:AdditionalAccountMailServerPortMissing", _additionalAccount.UserName), '',
                                            SysInfoAction_Formrun::newFormnameControlnameDesc(formStr(DocParameters),
                                            formControlStr(DocParameters, AdditionalEmailAccountsGrid_PortNumber), "@DocentricAX:FixProblem"));
        }
    
        // Instantiate the SMTP client
        smtpMailClient = DocSmtpMailClient::construct(
                                                mailServerName,
                                                mailServerPort,
                                                false,
                                                _additionalAccount.AuthenticationRequired,
                                                _additionalAccount.AccountUserName,
                                                _additionalAccount.getPassword(),
                                                _additionalAccount.RequireSSL,
                                                docParameters.SmtpSettingsSmtpClientTimeout,
                                                docParameters.SmtpDeliveryFormat);

        smtpMailClient.parmSuppressThrottling(_additionalAccount.SuppressThrottling);
 
        return smtpMailClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSmtpClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the SMTP client that matches to provided 'From' email address.
    /// If the provided 'From' email address is found in Additional From email accounts, then this account will be used to instance an SMTP client.
    /// If the provided 'From' email address is NOT found in Additional From email accounts, then the default SMTP account will be used (defined in Email parameters).
    /// </summary>
    /// <param name = "_fromAddress">'From' email address</param>
    /// <returns>Instanced SMTP mail client</returns>
    public static DocSmtpMailClient getSmtpClient(str _fromAddress)
    {
        DocSmtpMailClient smtpMailClient;
        
        DocEmailAccount additionalAccount = DocEmailAccount::findUserName(_fromAddress);
        if (additionalAccount && additionalAccount.IsEnabled)
        {
            // From found in additional Email accounts: use the corresponding credentials
            // for instantiating the SMTP client
            smtpMailClient = DocEmailMngHelper::getSmtpClientFromAdditionalAccount(additionalAccount);
        }
        else
        {
            // From not found in additional Email accounts: use the system settings
            smtpMailClient = DocEmailMngHelper::getSmtpClientFromSysParameters();
        }

        return smtpMailClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSmtpAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the SMTP account that matches to provided 'From' email address.
    /// If the provided 'From' email address is found in Additional From email accounts, then this account will be used for emailing via SMTP.
    /// If the provided 'From' email address is NOT found in Additional From email accounts, then the default SMTP account will be used (defined in Email parameters).
    /// </summary>
    /// <param name = "_fromAddress">'From' email address</param>
    /// <returns>SMTP account that will be used for the given From address when emailing via SMTP</returns>
    public static str getSmtpAccount(str _fromAddress)
    {
        DocEmailAccount additionalAccount = DocEmailAccount::findUserName(_fromAddress);
        if (additionalAccount && additionalAccount.IsEnabled)
        {
            // From found in additional Email accounts: use the corresponding account.
            return additionalAccount.AccountUserName ? additionalAccount.AccountUserName : additionalAccount.UserName;
        }
        else
        {
            // From not found in additional Email accounts: use the system settings.
            return SysEmailParameters::find().SMTPUserName;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferEncoding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the .NET transfer encoding for the specified transfer encoding type.
    /// </summary>
    /// <param name = "_transferEncoding">Transfer encoding type</param>
    /// <returns>The .NET transfer encoding</returns>
    public static System.Net.Mime.TransferEncoding getTransferEncoding(DocTransferEncoding _transferEncoding)
    {
        switch (_transferEncoding)
        {
            case DocTransferEncoding::SevenBit:
                return System.Net.Mime.TransferEncoding::SevenBit;
    
            case DocTransferEncoding::EightBit:
                return System.Net.Mime.TransferEncoding::EightBit;
    
            case DocTransferEncoding::Base64:
                return System.Net.Mime.TransferEncoding::Base64;
    
            case DocTransferEncoding::QuotedPrintable:
                return System.Net.Mime.TransferEncoding::QuotedPrintable;
    
            case DocTransferEncoding::Unknown:
                return System.Net.Mime.TransferEncoding::Unknown;
    
            default:
                DocGlobalHelper::handleException(funcName(), strFmt('Unsupported type of transfer encoding (%1)', _transferEncoding));
        }

        return System.Net.Mime.TransferEncoding::Unknown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserEmailAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the email address of the provided user.
    /// </summary>
    /// <param name="_userId">User ID. If omitted, current user is used.</param>
    /// <returns>Email address of the provided user.</returns>
    public static str getUserEmailAddress(UserId _userId = curUserId())
    {
        UserInfo user = xUserInfo::find(false, _userId);
        SysUserInfo sysUser = SysUserInfo::find(_userId);
        str userEmailAddress = sysUser.Email ? sysUser.Email : user.networkAlias;
        
        return userEmailAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailAddressesForRole</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of email addresses for users in the specified security role.
    /// </summary>
    /// <param name = "_securityRoleAOTName">A security role</param>
    /// <returns>A semicolon-separated list of email addresses</returns>
    public static str getEmailAddressesForRole(str _securityRoleAOTName)
    {
        UserInfo userInfo;
        SecurityRole securityRole;
        SecurityUserRole securityUserRole;

        str emailAddresses = '';

        while select id
            from userInfo
                where userInfo.enable == NoYes::Yes
            exists join securityUserRole
                where securityUserRole.User == userInfo.id
                   && securityUserRole.AssignmentStatus == RoleAssignmentStatus::Enabled
                   && (securityUserRole.ValidFrom < DateTimeUtil::utcNow() || securityUserRole.ValidFrom == utcDateTimeNull())
                   && (securityUserRole.ValidTo > DateTimeUtil::utcNow() || securityUserRole.ValidTo == utcDateTimeNull())
            exists join securityRole
                where securityRole.RecId == securityUserRole.SecurityRole
                   && securityRole.AOTName == _securityRoleAOTName
        {
            str emailAddress = DocEmailMngHelper::getUserEmailAddress(userInfo.Id);
            if (emailAddress)
            {
                // Concatenate the email addresses
                emailAddresses += (emailAddresses ? '; ' : '') + emailAddress;
            }
        }

        return emailAddresses;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emailReportV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Emails the provided printed report.
    /// </summary>
    /// <param name="_printReportSettings">Print report settings</param>
    /// <param name="_emailPrintDestSettings">Email print destination settings</param>
    /// <param name="_generatedReportContent">The attachment file content, i.e. the generated report that might be signed and encrypted</param>
    /// <param name="_emailExecutionInfo">Email execution info</param>
    /// <param name="_smtpMailClient">
    /// An SMTP client mail instance. If null, then DocEmailMngHelper::getSmtpClient(_mailMessage.get_From().Address)
    /// is invoked in order to get a new instance of SMTP mail client.
    /// </param>
    /// <returns>
    /// Returns false, if sending of the email was canceled.
    /// Returns true, if the mail was successfully send.
    /// Throws an error if sending of the email fails.
    /// </returns>
    public static boolean emailReportV2(
        DocPrintReportSettings _printReportSettings,
        DocPrintDestSettingsEmail _emailPrintDestSettings,
        container _generatedReportContent,
        DocPrintReportToEmailExecutionInfo _emailExecutionInfo,
        DocSmtpMailClient _smtpMailClient = null)
    {
        // Create a wrapper-object around the generated report content, which might be signed and encrypted,
        // to enable subscribers to the events that follow to change it.
        DocPrintedReport reportContent = DocReportingHelper::createPrintedReportFromEmailPrintSettings(_emailPrintDestSettings, _generatedReportContent);

        // Publish event before the emailing of the report starts, i.e. before the outgoing email message is created.
        boolean cancelExecution = DocOutputManagerPublisher::publishEvent_beforeEmailMessageCreated(_printReportSettings, _emailPrintDestSettings, reportContent);
        if (cancelExecution)
        {
            return false;
        }

        // Send email manually if the OpenEmailBeforeSending option is turned on and the report is not executing in batch.
        boolean sendEmailManually = _emailPrintDestSettings.parmOpenEmailBeforeSending() && !DocGlobalHelper::isNonInteractiveSession();

        // Email report using Email processing but only if the email should not be sent manually.
        if (!sendEmailManually && _emailPrintDestSettings.getEmailingMode() == DocEmailSendingMode::EmailProcessing)
        {
            DocEmailMngHelper::emailReportUsingEmailProcessing(_printReportSettings, _emailPrintDestSettings, reportContent.getReportContentContainer(), _emailExecutionInfo);
            return true;         
        }
 
        using (MailMessage mailMessage = DocEmailMngHelper::createEmailMessage(
                                                                _emailPrintDestSettings.parmEmailFrom(),
                                                                _emailPrintDestSettings.parmEmailFromDisplayName(), 
                                                                _emailPrintDestSettings.parmEmailTo(),
                                                                _emailPrintDestSettings.parmEmailCc(), 
                                                                _emailPrintDestSettings.parmEmailBcc(),
                                                                _emailPrintDestSettings.parmEmailSubject(), 
                                                                _emailPrintDestSettings.parmEmailBody(),
                                                                _emailPrintDestSettings.parmIsHtmlBody(),
                                                                _emailPrintDestSettings.getEmailPriority(),
                                                                _emailPrintDestSettings.parmEmailAttachmentName(), 
                                                                reportContent.getReportContentContainer(),
                                                                _emailPrintDestSettings.parmEmailAdditionalAttachments(),
                                                                _emailPrintDestSettings.parmEmailImageMap(),
                                                                _emailPrintDestSettings.parmEmailReplyTo(),
                                                                _emailPrintDestSettings.parmEmailBounceTo(),
                                                                _emailPrintDestSettings.parmOpenEmailBeforeSending(),
                                                                _emailPrintDestSettings.parmReadReceiptAddress(),
                                                                _emailPrintDestSettings.parmDeliveryReceiptCondition()))
        {
            // Publish event that the outgoign email message has been created.
            cancelExecution = DocOutputManagerPublisher::publishEvent_emailMessageCreated(mailMessage,
                _printReportSettings, _emailPrintDestSettings, _emailPrintDestSettings.parmEmailFromDisplayName(), reportContent, _emailPrintDestSettings.getEmailPriority());
            if (cancelExecution)
            {
                return false;
            }

            // Send email.
            if (sendEmailManually)
            {
                // Send email to user to enable manual sending.
                str downloadingMailMessageFilenameWithoutExt = DocOutputManagerPublisher::publishEvent_beforeDownloadEmailMessage(mailMessage, _printReportSettings, _emailPrintDestSettings, reportContent);
                DocEmailMngHelper::sendEmailToUser(mailMessage, downloadingMailMessageFilenameWithoutExt);
            }
            else
            {
                // Send mail message using email provider set in Email parameters.
                DocEmailMngHelper::sendEmailMsgUsingEmailProvider(mailMessage, _smtpMailClient);
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emailReportUsingEmailProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Emails the provided printed report using Email processing, i.e. saving it to the Email sending status table.
    /// </summary>
    /// <param name="_printReportSettings">Print report settings</param>
    /// <param name="_emailPrintDestSettings">Email print destination settings</param>
    /// <param name="_generatedReportContent">The attachment file content, i.e. printed report</param>
    /// <param name="_emailExecutionInfo">Email execution info</param>
    public static void emailReportUsingEmailProcessing(DocPrintReportSettings _printReportSettings,
                                                       DocPrintDestSettingsEmail _emailPrintDestSettings,
                                                       container _generatedReportContent,
                                                       DocPrintReportToEmailExecutionInfo _emailExecutionInfo)
    {
        try
        {
            DocEmailProcessor::emailReport(_printReportSettings, _emailPrintDestSettings, _generatedReportContent, _emailExecutionInfo);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:SendingEmailFailedEmailProcessing",
                _emailPrintDestSettings.parmEmailFrom(), _emailPrintDestSettings.parmEmailTo(), _emailPrintDestSettings.parmEmailSubject()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailToUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends the provided mail message for downloading from the browser.
    /// </summary>
    /// <param name = "_mailMessage">Mail message to download</param>
    /// <param name = "_downloadingMailMessageFilenameWithoutExt">The filename without extenstion of the downloading email message (eml file). If empty, the mail message subject is used.</param>
    public static void sendEmailToUser(MailMessage _mailMessage, str _downloadingMailMessageFilenameWithoutExt = '')
    {
        str fileName;
        if (_downloadingMailMessageFilenameWithoutExt)
        {
            fileName = DocFileMngHelper::replaceInvalidCharsForFileName(_downloadingMailMessageFilenameWithoutExt) + '.eml';
        }
        if (!fileName)
        {
            str subject = _mailMessage.Subject;
            fileName = (subject ? DocFileMngHelper::replaceInvalidCharsForFileName(subject) : 'email') + '.eml';
        }

        try
        {
            using (MemoryStream emlStream = MailHelper::ConvertMailMessageToEml(_mailMessage))
            {
                DocFileMngHelper::sendFileToUser(emlStream, fileName, '', '', '', '', true, true);
            }
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX2:ErrorDownloadingEML");
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), "@DocentricAX2:ErrorDownloadingEML");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFromEmailAddressIfEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the given mail message, check if the From address is set.
    /// If not, sets the From email address to the default Email provider account configured via Email parameters.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    public static void setFromEmailAddressIfEmpty(System.Net.Mail.MailMessage _mailMessage)
    {
        str fromAddress, displayName;

        if (_mailMessage == null)
        {
            DocGlobalHelper::handleException(funcName(), 'Parameter _mailMessage is not set');
        }
        
        if (_mailMessage.get_From())
        {
            fromAddress = _mailMessage.get_From().Address;
            displayName = _mailMessage.get_From().DisplayName;
        }

        // If both From email address and Display name are set, return.
        if (fromAddress && displayName)
        {
            return;
        }
                
        // If the From email address is not set, change it to the value configured in Email parameters.
        try
        {
            boolean fromAddressOrDisplayNameSet = false;
            if (!fromAddress)
            {
                fromAddress = DocEmailMngHelper::getAndValidateDefaultEmailProviderEmailAddress(); // Throws an exception if fromAddress is not found.
                fromAddressOrDisplayNameSet = true;
            }
            if (!displayName)  // fromAddress was already provided or it has been just set to the default from address; otherwise, exception would be thrown.
            {
                displayName = DocEmailMngHelper::getEmailSenderDisplayNameByFromAddress(fromAddress);
                if (displayName == DocConstant::EmailSenderDisplayNameCurrentUserPlaceholder)
                {
                    displayName = DocEmailMngHelper::getUserEmailAddress(curUserId());
                }
                if (displayName)
                {
                    fromAddressOrDisplayNameSet = true;
                }
            }

            // Set From email address and Display name if needed.
            if (fromAddressOrDisplayNameSet)
            {
                MailAddress fromEmailAccount = displayName ? new MailAddress(fromAddress, displayName) : new MailAddress(fromAddress);
                _mailMessage.set_From(fromEmailAccount);
            }
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX:FailedToSetFromAddress");
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), "@DocentricAX:FailedToSetFromAddress");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingEmailProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends an email with the given parameters using the selected email provider.
    /// </summary>
    /// <param name="_mailMessage">Mail message, the System.Net.Mail.MailMessage object.</param>
    /// <param name="_smtpMailClient">
    /// A SMTP mail client instance. If null, then DocEmailMngHelper::getSmtpClient(_mailMessage.get_From().Address)
    /// is invoked in order to get a new instance of SMTP mail client.
    /// </param>
    public static void sendEmailMsgUsingEmailProvider(System.Net.Mail.MailMessage _mailMessage, DocSmtpMailClient _smtpMailClient = null)
    {
        if (DocEmailMngHelper::suppressEmailing(_mailMessage))
        {
            return;
        }

        // Set 'From' email address on the given _mailMessage if empty, using settings from Email parameters.
        DocEmailMngHelper::setFromEmailAddressIfEmpty(_mailMessage);
        
        // Invoke a delegate for changing the email pipeline. 
        // When a delegate subscriber implements a custom email provider, it must return the result object with the following settings:
        // - result.cancelExecution(true) - cancels the execution of the Docentric pipeline
        // - result.booleanResult(true) - the email was successfuly sent
        DocEventHandlerResult result = DocEmailMngHelper::sendEmailMsgUsingEmailProviderInternal(_mailMessage);
        // Cancel the Docentric pipeline execution if an event subscriber requested to do so.
        if (result.cancelExecution())
        {
            return;
        }

        boolean success;
        DocEmailProviderType emailProviderType = DocEmailMngHelper::getEmailProviderTypeByFromAddress(_mailMessage.get_From().Address);
        switch (emailProviderType)
        {
            case DocEmailProviderType::SMTP:
                success = DocEmailMngHelper::sendEmailMsgUsingSmtpClient(_smtpMailClient, _mailMessage);
                break;

            case DocEmailProviderType::Exchange:
                success = DocEmailMngHelper::sendEmailMsgUsingExchange(_mailMessage);
                break;

            case DocEmailProviderType::Graph:
                success = DocEmailMngHelper::sendEmailMsgUsingGraph(_mailMessage);
                break;

            default:
                success = DocEmailMngHelper::sendEmailMsgUsingCustomEmailProvider(_mailMessage);
                break;
        }

        if (!success)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingEmailProviderDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for implementing a custom email pipeline and cancelling the Docentric pipeline.
    /// </summary>
    /// <param name = "_mailMessage">An instance of the System.Net.Mail.MailMessage object.</param>
    /// <param name = "_result">
    /// The handler result that can break Docentric execution flow:
    /// - Set _result.cancelExecution(true), if the Docentric execution flow should be break.
    /// - Set _result.booleanResult(true), if the mail was successfully sent.
    /// </param>
    static delegate void sendEmailMsgUsingEmailProviderDelegate(System.Net.Mail.MailMessage _mailMessage, DocEventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingEmailProviderInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publisher for implementing a custom email pipeline and cancelling the Docentric pipeline.
    /// </summary>
    /// <param name = "_mailMessage">An instance of the System.Net.Mail.MailMessage object.</param>
    /// <returns>An instance of the DocEventHandlerResult object. If _result.booleanResult() == true, the email was successfully sent.</returns>
    private static DocEventHandlerResult sendEmailMsgUsingEmailProviderInternal(System.Net.Mail.MailMessage _mailMessage)
    {
        DocEventHandlerResult result = new DocEventHandlerResult();
        result.cancelExecution(false);
        result.booleanResult(false);

        try
        {
            DocEmailMngHelper::sendEmailMsgUsingEmailProviderDelegate(_mailMessage, result);
            if (result.cancelExecution() && !result.booleanResult())
            {
                throw Exception::Error;
            }
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", staticDelegateStr(DocEmailMngHelper, sendEmailMsgUsingEmailProviderDelegate)));
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", staticDelegateStr(DocEmailMngHelper, sendEmailMsgUsingEmailProviderDelegate)));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingCustomEmailProviderDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for implementing a custom email provider.
    /// </summary>
    /// <param name = "_mailMessage">An instance of the System.Net.Mail.MailMessage object.</param>
    /// <param name = "_result">An instance of the DocEventHandlerResult object. If _result.booleanResult() == true, the email was successfully sent.</param>
    static delegate void sendEmailMsgUsingCustomEmailProviderDelegate(System.Net.Mail.MailMessage _mailMessage, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingCustomEmailProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publisher for implementing a custom email provider.
    /// </summary>
    /// <param name = "_mailMessage">An instance of the System.Net.Mail.MailMessage object.</param>
    /// <returns>An instance of the DocEventHandlerResult object. If _result.booleanResult() == true, the email was successfully sent.</returns>
    private static boolean sendEmailMsgUsingCustomEmailProvider(System.Net.Mail.MailMessage _mailMessage)
    {
        EventHandlerResult result = new EventHandlerResult();
        result.hasResult(false);

        try
        {
            DocEmailMngHelper::sendEmailMsgUsingCustomEmailProviderDelegate(_mailMessage, result);
            if (!result.hasResult())
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodResultError", staticDelegateStr(DocEmailMngHelper, sendEmailMsgUsingCustomEmailProviderDelegate)));
            }
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", staticDelegateStr(DocEmailMngHelper, sendEmailMsgUsingCustomEmailProviderDelegate)));
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:DocDelegateMethodError", staticDelegateStr(DocEmailMngHelper, sendEmailMsgUsingCustomEmailProviderDelegate)));
        }

        return result.hasResult() ? result.booleanResult() : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingExchange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends an email with the given parameters using Exchange email provider.
    /// </summary>
    /// <param name="_mailMessage">Mail message, the System.Net.Mail.MailMessage object.</param>
    /// <returns>True, if the mail message is successfully sent; otherwise false.</returns>
    /// <remarks>This method doesn't throw exceptions</remarks>
    public static boolean sendEmailMsgUsingExchange(System.Net.Mail.MailMessage _mailMessage)
    {
        void handleError()
        {
            DocGlobalHelper::handleError(strFmt("@DocentricAX:SendingEmailFailedExchange", _mailMessage.From.ToString(), _mailMessage.To.ToString(), _mailMessage.Subject));
        }


        boolean sendEmailResult;
        try
        {
            // Instance Exchange mail client.
            SysMailerExchange mailClient = new SysMailerExchange();

            // Send the email.
            sendEmailResult = mailClient.sendNonInteractive(_mailMessage);
            if (!sendEmailResult)
            {
                throw Exception::Error;
            }
        }
    
        catch (Exception::CLRError)
        {
            str clrErrorMsg = DocGlobalHelper::getLastClrExceptionMessage();
    
            setPrefix(DocConstant::Docentric);
            error(clrErrorMsg);
    
            handleError();
        }
    
        catch
        {
            handleError();
        }

        return sendEmailResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingGraph</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends an email with the given parameters using Microsoft Graph email provider.
    /// </summary>
    /// <param name="_mailMessage">Mail message, the System.Net.Mail.MailMessage object.</param>
    /// <returns>True, if the mail message is successfully sent; otherwise false.</returns>
    /// <remarks>This method doesn't throw exceptions</remarks>
    public static boolean sendEmailMsgUsingGraph(System.Net.Mail.MailMessage _mailMessage)
    {
        void handleError()
        {
            DocGlobalHelper::handleError(strFmt("@DocentricAX5:SendingEmailFailedGraph", _mailMessage.From.ToString(), _mailMessage.To.ToString(), _mailMessage.Subject));
        }


        boolean sendEmailResult;
        try
        {
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Uncomment this part when compiling with version higher than 10.0.37. With version 10.0.38 first time SysMailerGraph class 
            // is introduced by Microsoft
            //
            //// Instance Graph mail client.
            //SysMailerGraph mailClient = new SysMailerGraph();
            //
            //// Send the email.
            //sendEmailResult = mailClient.sendNonInteractive(_mailMessage);
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // This is just temporary solution for sending email using reflection due the compilation problems on versions less then 10.0.38
            // when first time SysMailerGraph class is introduced. Delete this part if you have uncommented the part above.
            // 
            // Find the class SysMailerGraph with reflection
            DictClass sysMailerGraphDictClass = new DictClass(className2Id(identifierStr(SysMailerGraph)));
            if (sysMailerGraphDictClass)
            {
                // Invoke sendNonInteractive method by creatinng an instance of SysMailerGraph class
                var sysMailerGraph = sysMailerGraphDictClass.makeObject();
                sendEmailResult = sysMailerGraphDictClass.callObject(identifierStr(sendNonInteractive), sysMailerGraph, _mailMessage);
            }
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            
            if (!sendEmailResult)
            {
                throw Exception::Error;
            }
        }
    
        catch (Exception::CLRError)
        {
            str clrErrorMsg = DocGlobalHelper::getLastClrExceptionMessage();
    
            setPrefix(DocConstant::Docentric);
            error(clrErrorMsg);
    
            handleError();
        }
    
        catch
        {
            handleError();
        }

        return sendEmailResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailMsgUsingSmtpClient</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends an email with the given parameters using Smtp client.
    /// </summary>
    /// <param name="_smtpMailClient">
    /// An SMTP mail client instance. If null, then DocEmailMngHelper::getSmtpClient(_mailMessage.get_From().Address)
    /// is invoked in order to get a new instance of SMTP mail client.
    /// </param>
    /// <param name="_mailMessage">Mail message, the System.Net.Mail.MailMessage object.</param>
    /// <returns>True, if the mail message is successfully sent; otherwise false.</returns>
    /// <remarks>This method doesn't throw exceptions</remarks>
    public static boolean sendEmailMsgUsingSmtpClient(DocSmtpMailClient _smtpMailClient, System.Net.Mail.MailMessage _mailMessage)
    {
        // Instance SMTP mail client.
        DocSysMailerSMTP mailClient = DocSysMailerSMTP::construct(_smtpMailClient);

        // Send the email.
        boolean sendEmailResult = mailClient.sendNonInteractive(_mailMessage);
            
        return sendEmailResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logSuccessToSysEmailHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the information about successfully sent email into the Email history table.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    /// <param name = "_isO365">Indicates whether the provider sending the message is an O365 provider.</param>    
    public static void logSuccessToSysEmailHistory(System.Net.Mail.MailMessage _mailMessage, boolean _isO365)
    {
        SysMailerId mailerId = new SysMailerSMTP().getId();   // 'SMTP'

        try
        {
            SysDictTable dictTable = new SysDictTable(tableNum(SysEmailHistory));
            MethodName   SysEmailHistory_insertNewMethod = tableStaticMethodStr(SysEmailHistory, insertNew);

            if (dictTable && tableHasStaticMethod(dictTable, SysEmailHistory_insertNewMethod))
            {
                SysDictMethod dictMethod = new SysDictMethod(UtilElementType::TableStaticMethod, dictTable.id(), SysEmailHistory_insertNewMethod);

                switch (dictMethod.parameterCnt())
                {
                    case 5:     // since 10.0.12
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, false, SysEmailStatus::Sent);
                        break;
                    case 6:     // since 10.0.15
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, false, SysEmailStatus::Sent, newGuid());
                        break;
                    case 7:     // since 10.0.21
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, _isO365, false, SysEmailStatus::Sent, newGuid());
                        break;
                    default:
                        DocGlobalHelper::handleError('Unexpected parameters count for method SysEmailHistory::insertNew().', true, funcName(), true);
                }
            }
        }
        catch
        {
            exceptionTextFallThrough();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logFailureToSysEmailHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes the information about unsuccessfully sent email into the Email history table.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    /// <param name = "_isO365">Indicates whether the provider sending the message is an O365 provider.</param>
    /// <param name = "_errMsg">Error message</param>
    /// <param name = "_clrErrMsg">CLR error message</param>
    public static void logFailureToSysEmailHistory(System.Net.Mail.MailMessage _mailMessage, boolean _isO365, str _errMsg, str _clrErrMsg = '')
    {
        SysMailerId mailerId = new SysMailerSMTP().getId();   // 'SMTP'

        try
        {
            SysDictTable dictTable = new SysDictTable(tableNum(SysEmailHistory));
            MethodName   SysEmailHistory_insertNewMethod = tableStaticMethodStr(SysEmailHistory, insertNew);

            if (dictTable && tableHasStaticMethod(dictTable, SysEmailHistory_insertNewMethod))
            {
                str errorToLog = _clrErrMsg ? strFmt('%1\n>> %2', _errMsg, _clrErrMsg) : _errMsg;
                SysDictMethod dictMethod = new SysDictMethod(UtilElementType::TableStaticMethod, dictTable.id(), SysEmailHistory_insertNewMethod);

                switch (dictMethod.parameterCnt())
                {
                    case 5:     // since 10.0.12
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, false, SysEmailStatus::Failed, errorToLog);
                        break;
                    case 6:     // since 10.0.15
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, false, SysEmailStatus::Failed, newGuid(), errorToLog);
                        break;
                    case 7:     // since 10.0.21
                        dictTable.callStatic(dictMethod.name(), _mailMessage, mailerId, _isO365, false, SysEmailStatus::Failed, newGuid(), errorToLog);
                        break;
                    default:
                        DocGlobalHelper::handleError('Unexpected parameters count for method SysEmailHistory::insertNew().', true, funcName(), true);
                }
            }
        }
        catch
        {
            exceptionTextFallThrough();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEmailMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an email message with the given parameters.
    /// </summary>
    /// <param name="_senderEmailAddress">Sender (From) email address.</param>
    /// <param name="_senderEmailAccountDisplayName">Sender email account display name.</param>
    /// <param name="_toRecipients">To email address. Can contain multiple recipients separated by commas or semi colons.</param>
    /// <param name="_ccRecipients">Cc email address. Can contain multiple recipients separated by commas or semi colons.</param>
    /// <param name="_bccRecipients">Bcc email address. Can contain multiple recipients separated by commas or semicolons.</param>
    /// <param name="_subject">Email subject.</param>
    /// <param name="_body">Email body.</param>
    /// <param name="_isHtml">Is email message body HTML.</param>
    /// <param name="_mailPriority">Mail priority.</param>
    /// <param name="_attachmentFilename">The attachment file name, if the email attachment exists.</param>
    /// <param name="_attachmentFileContent">The attachment file content, if the email attachment exists.</param>
    /// <param name="_additionalAttachments">Container containing file content of the additional attachments, if any.</param>
    /// <param name="_imageMap">Map containing email embedded images, if any.</param>
    /// <param name="_emailReplyTo">'Reply to' email addresses separated by commas or semicolons.</param>
    /// <param name="_emailBounceTo">'Bounce to' email address.</param>
    /// <param name="_createReadyToSend">Should create a message that can be sent from MS Outlook</param>
    /// <param name="_emailReadReceiptTo">
    /// 'Read receipt' email address. If empty, Read receipt will not be sent.
    /// Can contain token @FROM_ADDRESS@ that will be resolved as the provided Sender (From) email address.
    /// </param>
    /// <param name="_deliveryReceiptCondition">When to send delivery receipt.</param>
    /// <returns>Created email message.</returns>
    public static System.Net.Mail.MailMessage createEmailMessage(
        str _senderEmailAddress, str _senderEmailAccountDisplayName,
        str _toRecipients, str _ccRecipients,
        str _bccRecipients, str _subject,
        str _body, boolean _isHtml = false,
        eMailPriority _mailPriority = eMailPriority::Normal,
        Filename _attachmentFilename = '',
        container _attachmentFileContent = conNull(),
        container _additionalAttachments = conNull(),
        Map _imageMap = null,
        str _emailReplyTo = '',
        str _emailBounceTo = '',
        boolean _createReadyToSend = false,
        str _emailReadReceiptTo = '',
        DocEmailDeliveryReceiptCondition _deliveryReceiptCondition = DocEmailDeliveryReceiptCondition::ServerDefaults)
    {
        List                                  toList, ccList, bccList, replyToList;
        ListEnumerator                        le;
        System.String                         toAddressCurrent, ccAddressCurrent, bccAddressCurrent, replyToAddressCurrent;
        System.String                         sender             = _senderEmailAddress;
        System.String                         senderDisplayName  = _senderEmailAccountDisplayName;
        System.String                         subject            = _subject;
        System.String                         body               = _body;
        System.String                         attachmentFilename = _attachmentFilename;
        System.Boolean                        isHtml             = _isHtml;
    
        boolean                               hasCcRecipients, hasBccRecipients, hasReplyToAddresses;
        System.IO.MemoryStream                attachmentMemoryStream;
    
        int                                   counter;
        container                             additionalAttachment, additionalAttachmentFileContent;
        str                                   additionalAttachmentNameStr;
        System.String                         additionalAttachmentName;
    
        Set                                   permissionSet;
    
        MailMessage                           mailMessage;
        MailAddress                           mailFrom, mailTo, bounceToAddress;
        MailAddressCollection                 mailToCollection, mailCCCollection, mailBCCCollection, mailReplyToCollection;
        AttachmentCollection                  mailAttachementCollection;
        Attachment                            mailAttachment;
        MailPriority                          mailPriority = MailPriority::Normal;
        str                                   clrErrorMsg;
        DocParameters                         docParameters;
        str                                   readReceiptAddress;
        

        void validateParameters()
        {
            if (!_senderEmailAddress)
            {
                DocGlobalHelper::handleException(funcName(), 'Parameter _senderEmailAddress is not set');
            }
            if (!_toRecipients)
            {
                DocGlobalHelper::handleException(funcName(), 'Parameter _toRecipients is not set');
            }
    
            if (!DocGlobalHelper::validateEmail(_senderEmailAddress))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:SenderEmailInvalid", _senderEmailAddress));
            }
    
            if (!DocGlobalHelper::validateEmailList(_toRecipients))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:ToRecipientsInvalid", _toRecipients));
            }
    
            if (_ccRecipients && !DocGlobalHelper::validateEmailList(_ccRecipients))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:CcRecipientsInvalid", _ccRecipients));
            }
    
            if (_bccRecipients && !DocGlobalHelper::validateEmailList(_bccRecipients))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:BccRecipientsInvalidEmailAddresses", _bccRecipients));
            }
    
            if (_emailReplyTo && !DocGlobalHelper::validateEmailList(_emailReplyTo))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX2:ErrorReplyToInvalidAddress", _emailReplyTo));
            }
    
            if (_emailBounceTo && !DocGlobalHelper::validateEmail(_emailBounceTo))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX2:ErrorBounceToInvalidAddress", _emailBounceTo));
            }

            if (readReceiptAddress && !DocGlobalHelper::validateEmail(readReceiptAddress))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX2:ReadReceiptEmailAddressNotValid", readReceiptAddress));
            }
    
            if (_attachmentFilename && _attachmentFileContent == conNull())
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:AttahcmentContentIsNotSet", _attachmentFilename));
            }
    
            if (!_attachmentFilename && _attachmentFileContent != conNull())
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:AttachmentNameNotSet");
            }
        }
    
    
        void cleanUp()
        {
            // Dispose.
            // NOTE: We cannot dispose these objects because the parent MailMessage object is returned by this method.
            //if (mailAttachment != null)
            //{
            //    mailAttachment.Dispose();
            //}
            //if (mailAttachementCollection != null)
            //{
            //    mailAttachementCollection.Dispose();
            //}
    
            // Revert permissions.
            CodeAccessPermission::revertAssert();
        }
    
    
        void handleException()
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt("@DocentricAX:FailedCreateEmailMessage", _senderEmailAddress, _toRecipients, _subject));
        }
    
    
        void addAdditionalAttachment()
        {
            mailAttachementCollection = mailMessage.get_Attachments();
            
            // Check additional attachments.
            // [ [attachmentName, [content]], [attachmentName, [content]], ...]
            for (counter = 1; counter <= conLen(_additionalAttachments); counter++)
            {
                try
                {
                    additionalAttachment = conPeek(_additionalAttachments, counter);
                    additionalAttachmentNameStr = conPeek(additionalAttachment, 1);
                    additionalAttachmentFileContent = conPeek(additionalAttachment, 2);
                }
                catch
                {
                    DocGlobalHelper::handleException(funcName(), "@DocentricAX:ParameterAdditionalAttachmentNotProvided");
                }
    
                if (conLen(additionalAttachment) != 2)
                {
                    DocGlobalHelper::handleException(funcName(), "@DocentricAX:ParameterAdditionalAttachmentNotProvided");
                }
    
                if (additionalAttachmentNameStr == '' || additionalAttachmentFileContent == conNull())
                {
                    continue;
                }
    
                additionalAttachmentName = additionalAttachmentNameStr;
                attachmentMemoryStream = DocGlobalHelper::convertContainerToMemoryStream(additionalAttachmentFileContent);
                mailAttachment = new Attachment(attachmentMemoryStream, additionalAttachmentName);
                mailAttachementCollection.Add(mailAttachment);
            }
        }  
    
        try
        {
            // Resolve token @FROM_ADDRESS@ in Read receipt address.
            readReceiptAddress = _emailReadReceiptTo;
            if (_emailReadReceiptTo == DocConstant::EmailFromAddressPlaceholder)
            {
                readReceiptAddress = _senderEmailAddress;
            }

            // Validate parameters.
            validateParameters();
    
            // Assert permissions.
            permissionSet = new Set(Types::Class);
            permissionSet.add(new InteropPermission(InteropKind::ClrInterop));
            //permissionSet.add(new FileIOPermission(_attachmentFilename, 'rw'));
            CodeAccessPermission::assertMultiple(permissionSet);
    
            // Mail priority.
            switch (_mailPriority)
            {
                case eMailPriority::High:
                    mailPriority = MailPriority::High;
                    break;
    
                case eMailPriority::Low:
                    mailPriority = MailPriority::Low;
                    break;
    
                case eMailPriority::Normal:
                    mailPriority = MailPriority::Normal;
                    break;
            }
    
            // Make list of To recipients.
            if(strScan(_toRecipients, ';', 1, strLen(_toRecipients)))
            {
                toList = DocGlobalHelper::getEmailList(_toRecipients, ';');
            }
            else if(strScan(_toRecipients, ',', 1, strLen(_toRecipients)))
            {
                toList = DocGlobalHelper::getEmailList(_toRecipients, ',');
            }
            else
            {
                toList = new List(Types::String);
                toList.addEnd(_toRecipients);
            }
    
            // Make list of Cc recipients if exist.
            hasCcRecipients = false;
            if (_ccRecipients)
            {
                hasCcRecipients = true;
                if (strScan(_ccRecipients, ';', 1, strLen(_ccRecipients)))
                {
                    ccList = DocGlobalHelper::getEmailList(_ccRecipients, ';');
                }
                else if (strScan(_ccRecipients, ',', 1, strLen(_ccRecipients)))
                {
                    ccList = DocGlobalHelper::getEmailList(_ccRecipients, ',');
                }
                else
                {
                    ccList = new List(Types::String);
                    ccList.addEnd(_ccRecipients);
                }
            }
    
            // Make list of Bcc recipients if exist.
            hasBccRecipients = false;
            if (_bccRecipients)
            {
                hasBccRecipients = true;
                if (strScan(_bccRecipients, ';', 1, strLen(_bccRecipients)))
                {
                    bccList = DocGlobalHelper::getEmailList(_bccRecipients, ';');
                }
                else if (strScan(_bccRecipients, ',', 1, strLen(_bccRecipients)))
                {
                    bccList = DocGlobalHelper::getEmailList(_bccRecipients, ',');
                }
                else
                {
                    bccList = new List(Types::String);
                    bccList.addEnd(_bccRecipients);
                }
            }

            // Make list of Reply-To addresses if exists.
            hasReplyToAddresses = false;
            if (_emailReplyTo)
            {
                hasReplyToAddresses = true;
                if (strScan(_emailReplyTo, ';', 1, strLen(_emailReplyTo)))
                {
                    replyToList = DocGlobalHelper::getEmailList(_emailReplyTo, ';');
                }
                else if (strScan(_emailReplyTo, ',', 1, strLen(_emailReplyTo)))
                {
                    replyToList = DocGlobalHelper::getEmailList(_emailReplyTo, ',');
                }
                else
                {
                    replyToList = new List(Types::String);
                    replyToList.addEnd(_emailReplyTo);
                }
            }
    
    
            // Get the first To recipient.
            le = toList.getEnumerator();
            le.moveNext();
            toAddressCurrent = strLTrim(strRTrim(le.current()));
    
            // Create the email.
            if (_senderEmailAccountDisplayName)
            {
                mailFrom = new MailAddress(sender, senderDisplayName);
            }
            else
            {
                mailFrom = new MailAddress(sender);
            }
            mailTo  = new MailAddress(toAddressCurrent);
            mailMessage = new MailMessage(mailFrom, mailTo);            
    
            // Handle multiple To participants.
            mailToCollection = mailMessage.get_To();
            while (le.moveNext())
            {
                toAddressCurrent = strLTrim(strRTrim(le.current()));
                if (!System.String::IsNullOrEmpty(toAddressCurrent))
                {
                    mailToCollection.Add(toAddressCurrent);
                }
            }
    
            // Handle multiple Cc participants.
            if (hasCcRecipients)
            {
                le = ccList.getEnumerator();
                mailCCCollection = mailMessage.get_CC();
                while (le.moveNext())
                {
                    ccAddressCurrent = strLTrim(strRTrim(le.current()));
                    if (!System.String::IsNullOrEmpty(ccAddressCurrent))
                    {
                        mailCCCollection.Add(ccAddressCurrent);
                    }
                }
            }
    
            // Handle multiple Bcc participants.
            if (hasBccRecipients)
            {
                le = bccList.getEnumerator();
                mailBCCCollection = mailMessage.get_Bcc();
                while (le.moveNext())
                {
                    bccAddressCurrent = strLTrim(strRTrim(le.current()));
                    if (!System.String::IsNullOrEmpty(bccAddressCurrent))
                    {
                        mailBCCCollection.Add(bccAddressCurrent);
                    }
                }
            }

            // Handle multiple Reply-to addresses.
            if (hasReplyToAddresses)
            {
                le = replyToList.getEnumerator();
                mailReplyToCollection = mailMessage.get_ReplyToList();
                while (le.moveNext())
                {
                    replyToAddressCurrent = strLTrim(strRTrim(le.current()));
                    if (!System.String::IsNullOrEmpty(replyToAddressCurrent))
                    {
                        mailReplyToCollection.Add(replyToAddressCurrent);
                    }
                }
            }

            // Handle Bounce-to address.
            if (_emailBounceTo)
            { 
                bounceToAddress = new MailAddress(strLTrim(strRTrim(_emailBounceTo)));
                mailMessage.set_Sender(bounceToAddress);
            }

            // Handle _createReadyToSend.
            if (_createReadyToSend)
            {
                // Create message that can be sent from MS Outlook.
                System.Collections.Specialized.NameValueCollection mailHeaders = mailMessage.get_Headers();
                mailHeaders.Add('X-Unsent', '1');
            }

            // Handle Read receipt address.
            if (readReceiptAddress)
            {
                System.Collections.Specialized.NameValueCollection mailHeaders = mailMessage.get_Headers();
                mailHeaders.Add('Disposition-Notification-To', readReceiptAddress);
            }

            // Handle Delivery receipt notifications.
            DocEmailMngHelper::setMailMessageDeliveryNotification(mailMessage, _deliveryReceiptCondition);
    
            // Handle subject, body and images.
            docParameters = DocParameters::find();
    
            // Set subject.
            mailMessage.set_Subject(subject);
            mailMessage.set_SubjectEncoding(
                DocEmailMngHelper::getEncoding(docParameters.SmtpMailMsgBodyAndSubjectEncoding));
    
            // Set body.
            if (_body)
            {
                // Note that if the body is empty, it will not be treated as HTML nor Encoding will be set.
                mailMessage.set_Body(body);
                mailMessage.set_IsBodyHtml(isHtml);
                mailMessage.set_BodyEncoding(
                    DocEmailMngHelper::getEncoding(docParameters.SmtpMailMsgBodyAndSubjectEncoding));
                mailMessage.set_BodyTransferEncoding(
                    DocEmailMngHelper::getTransferEncoding(docParameters.SmtpMailMsgBodyTransferEncoding));
            }
                
            // Add images.
            if (_imageMap)
            {
                MapEnumerator e = _imageMap.getEnumerator();

                while (e.moveNext())
                {
                    DocEmailMngHelper::addBodyImage(mailMessage, e.currentKey(), e.currentValue());
                }
            }

            // Set priority.
            mailMessage.set_Priority(mailPriority);
    
            // Set attachments if needed.
            if (_attachmentFilename && _attachmentFileContent)
            {
                mailAttachementCollection = mailMessage.get_Attachments();
                attachmentMemoryStream = DocGlobalHelper::convertContainerToMemoryStream(_attachmentFileContent);
                mailAttachment = new Attachment(attachmentMemoryStream, attachmentFilename);
                mailAttachementCollection.Add(mailAttachment);
            }

            // Add additional attachments.
            if (_additionalAttachments)
            {
                addAdditionalAttachment();            
            }
    
            cleanUp();
        }
    
        catch (Exception::CLRError)
        {
            clrErrorMsg = DocGlobalHelper::getLastClrExceptionMessage();
    
            cleanUp();
    
            setPrefix(DocConstant::Docentric);
            error(clrErrorMsg);
    
            handleException();
        }
    
        catch
        {
            cleanUp();
            handleException();
        }

        return mailMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMailMessageDeliveryNotification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the mail message delivery notification.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    /// <param name = "_deliveryReceiptCondition">Send delivery receipt condition</param>
    public static void setMailMessageDeliveryNotification(System.Net.Mail.MailMessage _mailMessage, DocEmailDeliveryReceiptCondition _deliveryReceiptCondition)
    {
        // Learn more about Delivery notifications here: https://www.emailarchitect.net/easendmail/sdk/html/o_deliverynotificationoptions.htm
        // Server defaults
        if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::ServerDefaults)
        {
            // We will not set anything here because we want to achieve the same behaviour we had
            // before introducing this option on Docentric report setup.
            //_mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::None;
        }

        // Always
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::Always)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::OnFailure | DeliveryNotificationOptions::OnSuccess | DeliveryNotificationOptions::Delay;
        }

        // Success
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::Success)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::OnSuccess;
        }
            
        // Failure
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::Failure)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::OnFailure;
        }

        // Delay
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::Delay)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::Delay;
        }
            
        // Delay or failure
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::DelayOrFailure)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::OnFailure | DeliveryNotificationOptions::Delay;
        }
            
        // Delay or success
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::DelayOrSuccess)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::OnSuccess | DeliveryNotificationOptions::Delay;
        }

        // Never
        else if (_deliveryReceiptCondition == DocEmailDeliveryReceiptCondition::Never)
        {
            _mailMessage.DeliveryNotificationOptions = DeliveryNotificationOptions::Never;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBodyImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an embedded image to the given mail message (as a related body part).
    /// </summary>
    /// <param name = "_mailMessage">Email message - the System.Net.Mail.MailMessage object.</param>
    /// <param name = "_contentId">A content ID for the related part.</param>
    /// <param name = "_image">Image content (container).</param>
    public static void addBodyImage(MailMessage _mailMessage, str _contentId, Bitmap _image)
    {
        if (!_contentId)
        {
            DocGlobalHelper::handleException(funcName(), 'Missing contentId');
        }

        if (!_image)
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Empty image content for CID %1', _contentId));
        }
        
        try
        {
            AlternateView avHtml;
            AlternateViewCollection alternativeViews = _mailMessage.AlternateViews;
            DocGlobalHelper::assert(alternativeViews != null);

            // All images are added to one alternate view
            if (alternativeViews.Count > 0)
            {
                avHtml = alternativeViews.get_Item(0);
            }
            else
            {
                avHtml = AlternateView::CreateAlternateViewFromString(_mailMessage.Body, _mailMessage.BodyEncoding, 'text/html');
                alternativeViews.Add(avHtml);
            }

            // Convert the image container to the image stream and add it to the linkedResource object by reference
            MemoryStream imageStream = DocGlobalHelper::convertContainerToMemoryStream(_image);

            str contentType = DocGlobalHelper::getImageMIMEContentType(imageStream);

            LinkedResource linkedResource = new LinkedResource(imageStream, contentType);
            linkedResource.ContentId = _contentId;
            LinkedResourceCollection linkedResources = avHtml.LinkedResources;
            linkedResources.Add(linkedResource);
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt('Error adding content for CID %1', _contentId));
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Error adding content for CID %1', _contentId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendEmailUsingEmailProvider</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends an email with the given parameters using Smtp client on the server side.
    /// </summary>
    /// <param name="_senderEmailAddress">Sender (From) email address.</param>
    /// <param name="_senderEmailAccountDisplayName">Sender email account display name.</param>
    /// <param name="_toRecipients">To email address. Can contain multiple recipients separated by commas or semi colons.</param>
    /// <param name="_ccRecipients">Cc email address. Can contain multiple recipients separated by commas or semi colons.</param>
    /// <param name="_bccRecipients">Bcc email address. Can contain multiple recipients separated by commas or semicolons.</param>
    /// <param name="_subject">Email subject.</param>
    /// <param name="_body">Email body.</param>
    /// <param name="_isHtml">Is email message body HTML.</param>
    /// <param name="_mailPriority">Mail priority.</param>
    /// <param name="_attachmentFilename">The attachment file name, if the email attachment exists.</param>
    /// <param name="_attachmentFileContent">The attachment file content, if the email attachment exists.</param>
    /// <param name="_additionalAttachments">Container containing file content of the additional attachments, if any.</param>
    /// <param name="_smtpMailClient">
    /// An SMTP mail client instance. If null, then DocEmailMngHelper::getSmtpClient(_mailMessage.get_From().Address)
    /// is invoked in order to get a new instance of SMTP mail client.
    /// </param>
    /// <param name="_imageMap">Map containing email embedded images, if any.</param>
    /// <param name="_emailReplyTo">'Reply to' email addresses separated by commas or semicolons.</param>
    /// <param name="_emailBounceTo">'Bounce to' email address.</param>
    /// <param name="_createReadyToSend">Should create a message that can be sent from MS Outlook</param>
    /// <param name="_emailReadReceiptTo">
    /// 'Read receipt' email address. If empty, Read receipt will not be sent.
    /// Can contain token @FROM_ADDRESS@ that will be resolved as the provided Sender (From) email address.
    /// </param>
    /// <param name="_deliveryReceiptCondition">When to send delivery receipt.</param>
    public static server void sendEmailUsingEmailProvider(
        str _senderEmailAddress, str _senderEmailAccountDisplayName,
        str _toRecipients, str _ccRecipients, str _bccRecipients,
        str _subject, str _body, boolean _isHtml = false,
        eMailPriority _mailPriority = eMailPriority::Normal,
        Filename _attachmentFilename = '',
        container _attachmentFileContent = conNull(),
        container _additionalAttachments = conNull(),
        DocSmtpMailClient _smtpMailClient = null,
        Map _imageMap = null,
        str _emailReplyTo = '', str _emailBounceTo = '',
        boolean _createReadyToSend = false,
        str _emailReadReceiptTo = '', 
        DocEmailDeliveryReceiptCondition _deliveryReceiptCondition = DocEmailDeliveryReceiptCondition::ServerDefaults)
    {
        using (MailMessage mailMessage = DocEmailMngHelper::createEmailMessage(
                                                                _senderEmailAddress, _senderEmailAccountDisplayName,
                                                                _toRecipients, _ccRecipients, _bccRecipients, _subject,
                                                                _body, _isHtml, _mailPriority,
                                                                _attachmentFilename, _attachmentFileContent,
                                                                _additionalAttachments, _imageMap,
                                                                _emailReplyTo, _emailBounceTo, _createReadyToSend,
                                                                _emailReadReceiptTo, _deliveryReceiptCondition))
        {
            DocEmailMngHelper::sendEmailMsgUsingEmailProvider(mailMessage, _smtpMailClient);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultEmailProviderEmailAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the email address of the currently selected non-interactive (batch) Email provider (SMTP, Exchange or Graph) from Email parameters.
    /// </summary>
    /// <returns>Email address set to be used with the default Email provider</returns>
    public static str getDefaultEmailProviderEmailAddress()
    {
        str emailProviderEmailAddress;
        
        // Select the current default Email provider.
        str emailProviderTypeStr = SysEmailParameters::find().MailerNonInteractive;

        // Get the Email provider account's email address.
        switch (emailProviderTypeStr)
        {
            case DocConstant::EmailProviderSMTP:
                SysEmailParameters emailParameters = SysEmailParameters::find();
                emailProviderEmailAddress = emailParameters.SMTPUserName;

                // Starting from the 3.3.5 version:
                // If the username is set but it's not a valid email address, it can still be a valid account for Exchange OnPrem, e.g. COMPANY\username.
                // In this case we will assume this and use the current user email. Emailing will work if the entered account
                // is configured to allow users to send emails on behalf of it.
                if (emailProviderEmailAddress != '' && !DocGlobalHelper::validateEmail(emailProviderEmailAddress))
                {
                    emailProviderEmailAddress = DocEmailMngHelper::getUserEmailAddress();
                }

                // Starting from the 3.3.3 version:
                // If the username is not set but the outgoing mail server is, we will make an exception
                // here and as the default sender address we will provide the current user email.
                // This can be a real-world scenario in on-premises environments or when using smtp4dev in non-production
                // or when authentication not required, e.g. when SMTP Relay is used.
                if (emailProviderEmailAddress == '' && emailParameters.SMTPRelayServerName != '')
                {
                    emailProviderEmailAddress = DocEmailMngHelper::getUserEmailAddress();
                }
                break;

            case DocConstant::EmailProviderExchange:
                emailProviderEmailAddress = DocEmailMngHelper::getUserEmailAddress();
                break;

            case DocConstant::EmailProviderGraph:
                emailProviderEmailAddress = DocEmailMngHelper::getUserEmailAddress();
                break;

            default:
                emailProviderEmailAddress = DocEmailMngHelper::getUserEmailAddress();
                break;
        }
        
        return emailProviderEmailAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAndValidateDefaultEmailProviderEmailAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and validate the email address of the currently selected non-interactive (batch) Email provider (SMTP, Exchange or Graph) from Email parameters.
    /// </summary>
    /// <returns>Email address set to be used with the default Email provider</returns>
    public static str getAndValidateDefaultEmailProviderEmailAddress()
    {
        str fromMailAddress = DocEmailMngHelper::getDefaultEmailProviderEmailAddress();

        // Check if the From address is inferred from the default email provider.
        if (fromMailAddress == '')
        {
            if (SysEmailParameters::find().MailerNonInteractive == '')
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:BatchEmailProviderNotSet");
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == 255)  // Unsupported email provider
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:BatchEmailProviderNotSupported", SysEmailParameters::find().MailerNonInteractive));
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::SMTP)
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:EmailAccountForSMTPNotSet");
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Exchange)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailUserAccountForExchangeNotSet", curUserId()));
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Graph)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:EmailUserAccountForGraphNotSet", curUserId()));
            }
        }

        // Check if the From address is valid.
        if (!DocGlobalHelper::validateEmail(fromMailAddress))
        {
            if (DocEmailMngHelper::getDefaultEmailProviderType() == 255)  // Unsupported email provider
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:BatchEmailProviderNotSupported", SysEmailParameters::find().MailerNonInteractive));
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::SMTP)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailAccountForSMTPInvalid", fromMailAddress));
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Exchange)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailUserAccountForExchangeInvalid", fromMailAddress, curUserId()));
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == DocEmailProviderType::Graph)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:EmailUserAccountForGraphInvalid", fromMailAddress, curUserId()));
            }
        }

        // Note that only non-empty and valid email address is returned.
        return fromMailAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailProviderTypeByFromAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the non-interactive Email provider ID based on the 'From' address.
    /// If the given 'From' address is found in Additional email accounts, then this account is used for emailing.
    /// If the given 'From' address is not found in Additional email accounts, the default Email account 
    /// (i.e. the system non-interactive or batch email provider) is used for emailing.
    /// </summary>
    /// <param name = "_fromAddress">The given 'From' email address</param>
    /// <returns>Email provider type: SMTP or Exchange</returns>
    public static DocEmailProviderType getEmailProviderTypeByFromAddress(str _fromAddress)
    {
        DocEmailAccount additionalAccount = DocEmailAccount::findUserName(_fromAddress);
        if (additionalAccount && additionalAccount.IsEnabled)
        {
            // 'From' address found in additional Email accounts: return the corresponding Email provider type.
            return additionalAccount.AccountType;
        }
        else
        {
            // 'From' address not found in additional Email accounts: return the system (i.e. default) Email provider type.
            if (SysEmailParameters::find().MailerNonInteractive == '')
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX4:BatchEmailProviderNotSetError");
            }
            else if (DocEmailMngHelper::getDefaultEmailProviderType() == 255)  // Unsupported email provider
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:BatchEmailProviderNotSupportedError", SysEmailParameters::find().MailerNonInteractive));
            }

            return DocEmailMngHelper::getDefaultEmailProviderType();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailSenderDisplayNameByFromAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets Email sender display name based on the 'From' address.
    /// If the given 'From' address is found in Additional email accounts, then this account is used for emailing.
    /// If the given 'From' address is not found in Additional email accounts, the default Email account
    /// (i.e. the system non-interactive or batch email provider) is used for emailing.
    /// In both cases we need to return the corresponding email sender display name.
    /// </summary>
    /// <param name = "_fromAddress">The given 'From' email address</param>
    /// <returns>Email sender display name</returns>
    public static str getEmailSenderDisplayNameByFromAddress(str _fromAddress)
    {
        if (_fromAddress != '')
        {
            DocEmailAccount additionalAccount = DocEmailAccount::findUserName(_fromAddress);
            if (additionalAccount && additionalAccount.IsEnabled)
            {
                // 'From' address found in additional Email accounts: return the corresponding Email sender display name.
                return additionalAccount.EmailSenderDisplayName;
            }
        }
        
        // 'From' address is not provided or not found in additional Email accounts: return the system (i.e. default) Email sender display name.
        return DocParameters::find().EmailAccountDisplayName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultEmailProviderType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default email provider type (i.e. non-interactive mailer): SMTP, Exchange or Graph mail server.
    /// </summary>
    /// <returns>The default email provider type</returns>
    public static DocEmailProviderType getDefaultEmailProviderType()
    {
        str emailProviderId = SysEmailParameters::find().MailerNonInteractive;
        switch (emailProviderId)
        {
            case DocConstant::EmailProviderSMTP:
                return DocEmailProviderType::SMTP;

            case DocConstant::EmailProviderExchange:
                return DocEmailProviderType::Exchange;

            case DocConstant::EmailProviderGraph:
                return DocEmailProviderType::Graph;
        }
        return symbol2Enum(enumNum(DocEmailProviderType), emailProviderId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>suppressEmailing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the emailing was suppressed.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    /// <returns>True if the emailing was suppressed; otherwise false</returns>
    public static boolean suppressEmailing(System.Net.Mail.MailMessage _mailMessage)
    {
        DocSuppressOutgoingEmails suppressOutgoingEmails = DocParameters::find().SuppressOutgoingEmails;
        switch (suppressOutgoingEmails)
        {
            case DocSuppressOutgoingEmails::No:
                return false;

            case DocSuppressOutgoingEmails::Yes:
                DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:SuppressOutgoingEmailsWarningMsg", ''));
                return true;

            case DocSuppressOutgoingEmails::YesWithDownload:
                // Download the outgoing email message if not executing in batch.
                if (!DocGlobalHelper::isNonInteractiveSession())
                {
                    DocEmailMngHelper::sendEmailToUser(_mailMessage);
                }
                DocGlobalHelper::handleWarning(strFmt("@DocentricAX3:SuppressOutgoingEmailsWarningMsg", "@DocentricAX3:SuppressOutgoingEmailsWithDownloadWarningMsg" + ' '));
                return true;

            default:
                DocGlobalHelper::handleException(funcName(), strFmt('Unsupported element (%1) of the enum (%2)', suppressOutgoingEmails, enumStr(DocSuppressOutgoingEmails)));
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replaceCIDWithBase64EmbeddedImages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces embedded CID images with Base64 encoded images in the provided email message.
    /// </summary>
    /// <param name = "_mailMessage">Email message</param>
    public static void replaceCIDWithBase64EmbeddedImages(System.Net.Mail.MailMessage _mailMessage)
    {
        if (_mailMessage == null)
        {
            return;
        }

        // Replace embedded CID images with Base64 encoded images
        AlternateViewCollection alternateViews = _mailMessage.AlternateViews;

        for (int i = 0; i < alternateViews.Count; i++)
        {
            AlternateView alternateView = alternateViews.get_Item(i);
            if (alternateView.ContentType.MediaType != 'text/html')
            {
                continue;
            }

            LinkedResourceCollection linkedResources = alternateView.LinkedResources;

            for (int j = 0; j < linkedResources.Count; j++)
            {
                LinkedResource linkedResource = linkedResources.get_Item(j);

                if (linkedResource.ContentId == null || linkedResource.ContentStream == null || (!(linkedResource.ContentStream is MemoryStream)) ||
                    linkedResource.ContentType.MediaType == null || !linkedResource.ContentType.MediaType.StartsWith('image/', System.StringComparison::OrdinalIgnoreCase))
                {
                    continue;
                }

                str cidString = System.String::Format('cid:{0}', linkedResource.ContentId);
                str base64Image = DocGlobalHelper::convertToBase64String((linkedResource.ContentStream as MemoryStream).ToArray());
                str dataString = System.String::Format('data:{0};base64,{1}', linkedResource.ContentType.MediaType, base64Image);
                _mailMessage.Body = _mailMessage.Body.Replace(cidString, dataString);

                // Delete CID attachment
                linkedResources.RemoveAt(j);
                j--;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>