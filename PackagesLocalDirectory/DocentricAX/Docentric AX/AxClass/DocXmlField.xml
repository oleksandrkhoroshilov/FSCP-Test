<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocXmlField</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// A utility class to quickly build an XML fragment by using table buffers and calculated values.
/// </summary>
public class DocXmlField
{
    boolean       isCalculatedField;
    boolean       isDefaultDimension;
    boolean       isLedgerDimension;
    boolean       isUserDefEnum;

    FieldId       fieldId;
    SysDictField  sysDictField;
    TableId       tableId;
    SysDictTable  sysDictTable;
    FieldName     fieldName;
    int           edtId;
    SysDictType   sysDictType;
    EnumId        enumId;
    SysDictEnum   sysDictEnum;
    anytype       fieldValue;

    str           fieldLabelValue;
    LabelId       fieldLabelId;

    LanguageId    languageId;

    boolean       isArrayEdtField;
    Map           dimensions; // Map(Types::String, Types::Container)
    Map           dimensionDynamicAccounts; // Map(Types::String, Types::Container)
    str           ledgerDimensionDisplayValue;

    DocXmlRecord  parent;

    DocXmlRecordBuildingContext recordBuildingContext;
    

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getlabelRepository</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the label repository capable to resolve D365FO labels (i.e. system labels), GER labels, User-defined and Custom Fields labels.
    /// </summary>
    /// <returns>Label repository</returns>
    public DocDataSourceProviderLabelRepository getlabelRepository()
    {
        return this.recordBuildingContext().getlabelRepository();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clones the entire field.
    /// </summary>
    /// <param name="_recordBuildingContext">Record building context that contains caching structures, etc.</param>
    /// <returns>Cloned field.</returns>
    public DocXmlField clone(DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        str             existingEdtName, existingEnumName;
        DocXmlField     newField;
        str             fieldLabelIdOrValue;
    
        fieldLabelIdOrValue = this.getFieldLabelId();
        if (!fieldLabelIdOrValue)
        {
            fieldLabelIdOrValue = this.getFieldLabel();
        }

        if (this.isUserDefEnum())
        {
            str enumValueName, enumValueLabelIdOrValue;
            [enumValueName, enumValueLabelIdOrValue] = this.getFieldValue();
            newField = DocXmlField::constructCalculatedFieldUserDefEnum(this.getFieldName(), enumValueName, enumValueLabelIdOrValue, 
                                                                        fieldLabelIdOrValue, this.getLanguageId(), _recordBuildingContext);
        }
        else if (this.isCalculatedField())
        {
            existingEnumName = '';
            if (this.sysDictEnum() != null)
            {
                existingEnumName = this.sysDictEnum().name();
            }
    
            existingEdtName = '';
            if (this.sysDictType() != null)
            {
                existingEdtName = this.sysDictType().name();
            }
    
            newField = DocXmlField::constructCalculatedField(this.getFieldName(), existingEdtName, existingEnumName,
                                                             this.getFieldValue(), fieldLabelIdOrValue, this.getLanguageId(),
                                                             _recordBuildingContext);
        }
        else
        {
            newField = DocXmlField::constructField(this.sysDictTable().id(), this.sysDictField().name(),
                                                   this.getFieldValue(), fieldLabelIdOrValue, this.getLanguageId(),
                                                   _recordBuildingContext);
            newField.setFieldName(this.getFieldName());  // In case that field name was changed.
            if (fieldLabelIdOrValue == '')  // In case that the field label was reset, it should be kept that way.
            {
                newField.setFieldLabel('');
            }
        }
    
        return newField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XML attribute for the field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_recordBuildingContext">An instance of the DocXmlRecordBuildingContext object</param>
    /// <returns>XML attribute representing the field</returns>
    private XmlAttribute createXmlAttribute(XmlDocument _parentXmlDoc, DocXmlRecordBuildingContext _recordBuildingContext)
    {
        XmlAttribute xmlAttr;
    
        if (this.isDimensionField() || this.isEnumField() || this.isArrayEdtField() || this.isUserDefEnum())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a non-dimension, non-enum or non-array edt field');
        }
    
        if (sysDictType)
        {
            xmlAttr = DocDataSourceProviderHelper::createXmlAttrFromEdt(
                            _parentXmlDoc, this.getFieldName(), this.getFieldValue(), sysDictType.id(), _recordBuildingContext);
        }
        else
        {
            xmlAttr = DocDataSourceProviderHelper::createXmlAttrFromValue(
                            _parentXmlDoc, this.getFieldName(), this.getFieldValue(), enumId);
        }
    
    
        return xmlAttr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlElementFromUserDefEnumField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XML element for User-defined Enum field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <returns>XML element representing User-defined Enum field</returns>
    private XmlElement createXmlElementFromUserDefEnumField(XmlDocument _parentXmlDoc)
    {
        XmlElement          xmlElementEnum;
        XmlAttribute        xmlAtrrEnum;
        str                 enumLabel;
    
    
        if (!this.isUserDefEnum())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a User-defined Enum field');
        }
    
        // Create an XML element named as the field.
        xmlElementEnum = _parentXmlDoc.createElement(this.getFieldName());
    
        // Create attributes Name and Text.
        str enumValueName, enumValueLabelIdOrValue;
        [enumValueName, enumValueLabelIdOrValue] = this.getFieldValue();

        // Create the 'Name' attribute.
        xmlAtrrEnum = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrUserDefEnumName);
        xmlAtrrEnum.value(enumValueName);
        xmlElementEnum.setAttributeNode(xmlAtrrEnum);
    
        // Create the 'Label' attribute.
        xmlAtrrEnum = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrUserDefEnumLabel);
        if (DocLabelHelper::isLabelIdForDsProvider(enumValueLabelIdOrValue))
        {
            enumLabel = this.getlabelRepository().resolveDdspLabel(enumValueLabelIdOrValue, this.getLanguageId());
        }
        else
        {
            enumLabel = enumValueLabelIdOrValue;
        }
        xmlAtrrEnum.value(enumLabel);
        xmlElementEnum.setAttributeNode(xmlAtrrEnum);
    
        return xmlElementEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlElementFromEnumField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XML element for Enum field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <returns>XML element representing Enum field</returns>
    private XmlElement createXmlElementFromEnumField(XmlDocument _parentXmlDoc)
    {
        XmlElement          xmlElementEnum;
        XmlAttribute        xmlAtrrEnum;
        str                 enumLabel;
    
    
        if (!this.isEnumField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for an Enum field');
        }
    
        // Create an XML element named as the field.
        xmlElementEnum = _parentXmlDoc.createElement(this.getFieldName());
    
        // Create attributes Name, Value and Text.
    
        // Create the 'Value' attribute.
        xmlAtrrEnum = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrEnumValue);
        xmlAtrrEnum.value(int2str(enum2int(this.getFieldValue())));
        xmlElementEnum.setAttributeNode(xmlAtrrEnum);
    
        // Create the 'Name' attribute.
        xmlAtrrEnum = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrEnumName);
        xmlAtrrEnum.value(this.sysDictEnum().value2Symbol(this.getFieldValue()));
        xmlElementEnum.setAttributeNode(xmlAtrrEnum);
    
        // Create the 'Text' attribute.
        xmlAtrrEnum = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrEnumText);
        enumLabel = this.recordBuildingContext().getLabelValueForEnumValue(this.sysDictEnum().id(), this.getFieldValue(), this.getLanguageId());
        if (!enumLabel)
        {
            enumLabel = this.sysDictEnum().value2Symbol(this.getFieldValue());
        }
        xmlAtrrEnum.value(enumLabel);
        xmlElementEnum.setAttributeNode(xmlAtrrEnum);
    
        return xmlElementEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlElementFromArrayEdtField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XML element for Array EDT field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <returns>XML element representing Array EDT field</returns>
    private XmlElement createXmlElementFromArrayEdtField(XmlDocument _parentXmlDoc)
    {
        XmlElement          xmlElementEdtArray;
        XmlAttribute        xmlAtrrEdtArray_Value, xmlAtrrEdtArray_Elem;
    
    
        if (!this.isArrayEdtField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for an array EDT field');
        }
    
        try
        {
            // Create an XML element named as the field.
            xmlElementEdtArray = _parentXmlDoc.createElement(this.getFieldName());
    
            // Create the 'Value' attribute.
            anytype arrayEdtElementValue;
            Docentric.AX.Framework.Utilities.EdtArrayHelper::TryGetValue(fieldValue, 0, arrayEdtElementValue);
            xmlAtrrEdtArray_Value = DocDataSourceProviderHelper::createXmlAttrFromEdt(
                                        _parentXmlDoc, DocConstantDSP::XmlAttrArrayEdtValue, arrayEdtElementValue, sysDictType.id(), this.recordBuildingContext());
            xmlElementEdtArray.setAttributeNode(xmlAtrrEdtArray_Value);

            // Create an attribute for each of the array element.
            Array arrayEdtDef;  // Array([ArrayElementName (str), ArrayElementLabel (str)])
            arrayEdtDef = this.recordBuildingContext().getArrayEdtDefinition(edtId);
            str elementName, elementLabelId;
            for (int i = 1; i <= arrayEdtDef.lastIndex(); i++)
            {
                [elementName, elementLabelId] = arrayEdtDef.value(i);
                Docentric.AX.Framework.Utilities.EdtArrayHelper::TryGetValue(fieldValue, i, arrayEdtElementValue);

                xmlAtrrEdtArray_Elem = DocDataSourceProviderHelper::createXmlAttrFromEdt(
                                           _parentXmlDoc, elementName, arrayEdtElementValue, sysDictType.id(), this.recordBuildingContext());
                xmlElementEdtArray.setAttributeNode(xmlAtrrEdtArray_Elem);
            }
        }
        catch (Exception::CLRError)
        {
            if (sysDictTable)
            {
                DocGlobalHelper::handleClrException(funcName(), strFmt('Failed to serialize the field (%1) from the table (%2) that is of Array EDT type (%3)',
                                                                       this.getFieldName(), sysDictTable.name(), sysDictType.name()));
            }
            else
            {
                DocGlobalHelper::handleClrException(funcName(), strFmt('Failed to serialize the field (%1) of the Array EDT type (%2)', this.getFieldName(), sysDictType.name()));
            }
        }
        catch
        {
            if (sysDictTable)
            {
                DocGlobalHelper::handleException(funcName(), strFmt('Failed to serialize the field (%1) from the table (%2) that is of Array EDT type (%3)',
                                                                    this.getFieldName(), sysDictTable.name(), sysDictType.name()));
            }
            else
            {
                DocGlobalHelper::handleException(funcName(), strFmt('Failed to serialize the field (%1) of the Array EDT type (%2)', this.getFieldName(), sysDictType.name()));
            }
        }
    
        return xmlElementEdtArray;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXmlElementsFromDimensionField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XML element for Dimension field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <returns>XML element representing Dimension field</returns>
    private XmlElement createXmlElementsFromDimensionField(XmlDocument _parentXmlDoc)
    {
        XmlElement          xmlElementDim, xmlElementDimDynamicAccounts, xmlElementDimAttribute;
        XmlAttribute        xmlAtrrDim;
        MapEnumerator       mapEnumerator;
        str                 dimName, dimLabelId, dimDisplayValue, dimDescription;
    
    
        if (!this.isDimensionField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a dimension field');
        }
    
        // Create an XML element of type 'DefaultDimension' or 'LedgerDimensionBase'
        xmlElementDim = _parentXmlDoc.createElement(this.getFieldName());
    
        // For each dimension add new child element 'Name' with attributes 'DisplayValue' and 'Description'.
        mapEnumerator = dimensions.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            dimName = mapEnumerator.currentKey();
            [dimLabelId, dimDisplayValue, dimDescription] =  mapEnumerator.currentValue();
    
            // Create an XML element named as the system name of the current dimension.
            xmlElementDimAttribute = _parentXmlDoc.createElement(dimName);
            xmlElementDim.appendChild(xmlElementDimAttribute);
    
            // Set an attribute 'DisplayValue'
            xmlAtrrDim = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrDimensionDisplayValue);
            xmlAtrrDim.value(dimDisplayValue);
            xmlElementDimAttribute.setAttributeNode(xmlAtrrDim);
    
            // Set an attribute 'Description'
            xmlAtrrDim = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrDimensionDescription);
            xmlAtrrDim.value(dimDescription);
            xmlElementDimAttribute.setAttributeNode(xmlAtrrDim);
        }
    
    
        if (this.isLedgerDimension())
        {
            // Add attribute 'LedgerDimensionDisplayValue' to the parent element.
            xmlAtrrDim = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrLedgerDimensionDisplayValue);
            xmlAtrrDim.value(ledgerDimensionDisplayValue);
            xmlElementDim.setAttributeNode(xmlAtrrDim);
    
            // Create an XML element for Dynamic accounts.
            xmlElementDimDynamicAccounts = _parentXmlDoc.createElement(DocConstantDSP::XmlElemDimensionDynamicAccounts);
            xmlElementDim.appendChild(xmlElementDimDynamicAccounts);
    
            // For each dynamics account add new child element 'Name' with attributes 'DisplayValue' and 'Description'.
            mapEnumerator = dimensionDynamicAccounts.getEnumerator();
            while (mapEnumerator.moveNext())
            {
                dimName = mapEnumerator.currentKey();
                [dimLabelId, dimDisplayValue, dimDescription] =  mapEnumerator.currentValue();
    
                // Create an XML element named as the system name of the current dimension.
                xmlElementDimAttribute = _parentXmlDoc.createElement(dimName);
                xmlElementDimDynamicAccounts.appendChild(xmlElementDimAttribute);
    
                // Set an attribute 'DisplayValue'
                xmlAtrrDim = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrDimensionDisplayValue);
                xmlAtrrDim.value(dimDisplayValue);
                xmlElementDimAttribute.setAttributeNode(xmlAtrrDim);
    
                // Set an attribute 'Description'
                xmlAtrrDim = _parentXmlDoc.createAttribute(DocConstantDSP::XmlAttrDimensionDescription);
                xmlAtrrDim.value(dimDescription);
                xmlElementDimAttribute.setAttributeNode(xmlAtrrDim);
            }
        }
    
        return xmlElementDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdAttribute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XSD attribute for the field.
    /// </summary>
    /// <param name="_parentXmlDoc">Parent XML document.</param>
    /// <returns>XML element representing XSD attribute for the field.</returns>
    private XmlElement createXsdAttribute(XmlDocument _parentXmlDoc)
    {
        // Returns e.g. <xs:attribute name="Street" type="xs:string"></xs:attribute>
    
        XmlElement  xsdAttrElement;
    
        if (this.isDimensionField() || this.isEnumField() || this.isArrayEdtField() || this.isUserDefEnum())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a non-dimension, non-enum or non-array edt field');
        }
    
        if (sysDictType)
        {
            xsdAttrElement = DocDataSourceProviderHelper::createXsdAttrElementFromEdt(_parentXmlDoc,
                                this.getFieldName(), sysDictType.id(), this.getFieldLabelId(), this.getFieldLabel(), this.recordBuildingContext());
        }
        else
        {
            xsdAttrElement = DocDataSourceProviderHelper::createXsdAttrElementFromValue(_parentXmlDoc,
                                this.getFieldName(), this.getFieldValue(), enumId, this.getFieldLabelId(), this.getFieldLabel());
        }
    
        return xsdAttrElement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdElementsFromDimensionField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XSD attribute for Dimension field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXsdElement">Parent XSD element</param>
    /// <returns>XML element representing XSD element for Dimension field</returns>
    private XmlElement createXsdElementsFromDimensionField(XmlDocument _parentXmlDoc, XmlElement _parentXsdElement)
    {
        XmlElement                      xsdElementParentDimension, xsdAnnotation;
        XmlElement                      xsdComplexTypeParentXsdElement, xsdChoiceParentXsdElement;
        XmlAttribute                    xsdElementNameAttr, xsdElementTypeAttr;
    
    
        if (!this.isDimensionField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a dimension field');
        }
    
        xsdComplexTypeParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, _parentXsdElement, 'xs:complexType');
        xsdChoiceParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexTypeParentXsdElement, 'xs:choice');
    
        // Create XSD element with name of the field, e.g. 'DefaultDimension' or 'LedgerDimension'
        xsdElementParentDimension = _parentXmlDoc.createElement2('xs:element', DocConstantDSP::XmlShemaNamespaceUri);
    
        xsdElementNameAttr = _parentXmlDoc.createAttribute('name');
        xsdElementNameAttr.value(this.getFieldName());
        xsdElementParentDimension.setAttributeNode(xsdElementNameAttr);
    
        xsdElementTypeAttr = _parentXmlDoc.createAttribute('type');
        if (this.isDefaultDimension())
        {
            xsdElementTypeAttr.value(DocConstantDSP::ComplexTypeDefaultDimension);
        }
        else
        {
            xsdElementTypeAttr.value(DocConstantDSP::ComplexTypeLedgerDimension);
        }
        xsdElementParentDimension.setAttributeNode(xsdElementTypeAttr);
    
        xsdChoiceParentXsdElement.appendChild(xsdElementParentDimension);
    
        // Create annotation for the field label.
        if (this.getFieldLabelId())
        {
            xsdAnnotation = DocDataSourceProviderHelper::createXsdAnnotationLabel(
                                _parentXmlDoc, this.getFieldLabelId(), this.getFieldLabel());
            xsdElementParentDimension.appendChild(xsdAnnotation);
        }
    
        return xsdElementParentDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdElementsFromUserDefEnumField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XSD attribute for User-defined Enum field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXsdElement">Parent XSD element</param>
    /// <returns>XML element representing XSD element for User-defined Enum field</returns>
    private XmlElement createXsdElementsFromUserDefEnumField(XmlDocument _parentXmlDoc, XmlElement _parentXsdElement)
    {
        XmlElement       xsdElementEnum, xsdAnnotation;
        XmlElement       xsdComplexTypeParentXsdElement, xsdChoiceParentXsdElement;
        XmlAttribute     xsdElementNameAttr, xsdElementTypeAttr;
    
    
        if (!this.isUserDefEnum())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for a User-defined Enum field');
        }
    
        xsdComplexTypeParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, _parentXsdElement, 'xs:complexType');
        xsdChoiceParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexTypeParentXsdElement, 'xs:choice');
    
        // Create an XML element named as the field name and with XML attributes: Name, Text and Value.
        xsdElementEnum = _parentXmlDoc.createElement2('xs:element', DocConstantDSP::XmlShemaNamespaceUri);
        xsdChoiceParentXsdElement.appendChild(xsdElementEnum);
    
        xsdElementNameAttr = _parentXmlDoc.createAttribute('name');
        xsdElementNameAttr.value(this.getFieldName());
        xsdElementEnum.setAttributeNode(xsdElementNameAttr);
    
        xsdElementTypeAttr = _parentXmlDoc.createAttribute('type');
        xsdElementTypeAttr.value(DocConstantDSP::ComplexTypeUserDefEnum);
        xsdElementEnum.setAttributeNode(xsdElementTypeAttr);
    
        // Create annotation for the field label.
        if (this.getFieldLabelId() || this.getFieldLabel())
        {
            xsdAnnotation = DocDataSourceProviderHelper::createXsdAnnotationLabel(
                                _parentXmlDoc, this.getFieldLabelId(), this.getFieldLabel());
            xsdElementEnum.appendChild(xsdAnnotation);
        }
    
        return xsdElementEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdElementsFromEnumField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XSD attribute for Enum field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXsdElement">Parent XSD element</param>
    /// <returns>XML element representing XSD element for Enum field</returns>
    private XmlElement createXsdElementsFromEnumField(XmlDocument _parentXmlDoc, XmlElement _parentXsdElement)
    {
        XmlElement       xsdElementEnum, xsdAnnotation;
        XmlElement       xsdComplexTypeParentXsdElement, xsdChoiceParentXsdElement;
        XmlAttribute     xsdElementNameAttr, xsdElementTypeAttr;
    
    
        if (!this.isEnumField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for an Enum field');
        }
    
        xsdComplexTypeParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, _parentXsdElement, 'xs:complexType');
        xsdChoiceParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexTypeParentXsdElement, 'xs:choice');
    
        // Create an XML element named as the field name and with XML attributes: Name, Text and Value.
        xsdElementEnum = _parentXmlDoc.createElement2('xs:element', DocConstantDSP::XmlShemaNamespaceUri);
        xsdChoiceParentXsdElement.appendChild(xsdElementEnum);
    
        xsdElementNameAttr = _parentXmlDoc.createAttribute('name');
        xsdElementNameAttr.value(this.getFieldName());
        xsdElementEnum.setAttributeNode(xsdElementNameAttr);
    
        xsdElementTypeAttr = _parentXmlDoc.createAttribute('type');
        xsdElementTypeAttr.value(DocConstantDSP::ComplexTypeEnum);
        xsdElementEnum.setAttributeNode(xsdElementTypeAttr);
    
        // Create annotation for the field label.
        if (this.getFieldLabelId())
        {
            xsdAnnotation = DocDataSourceProviderHelper::createXsdAnnotationLabel(
                                _parentXmlDoc, this.getFieldLabelId(), this.getFieldLabel());
            xsdElementEnum.appendChild(xsdAnnotation);
        }
    
        return xsdElementEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXsdElementsFromArrayEdtField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds XSD attribute for Array EDT field.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXsdElement">Parent XSD element</param>
    /// <returns>XML element representing XSD element for Array EDT field</returns>
    private XmlElement createXsdElementsFromArrayEdtField(XmlDocument _parentXmlDoc, XmlElement _parentXsdElement)
    {
        XmlElement       xsdElementArrayEdt, xsdAnnotation;
        XmlElement       xsdComplexTypeParentXsdElement, xsdChoiceParentXsdElement;
        XmlAttribute     xsdElementNameAttr;
    
    
        if (!this.isArrayEdtField())
        {
            DocGlobalHelper::handleException(funcName(), 'The method can be used only for an Array EDT field');
        }
    
        xsdComplexTypeParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, _parentXsdElement, 'xs:complexType');
        xsdChoiceParentXsdElement = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexTypeParentXsdElement, 'xs:choice');
    
        // Create an XML element named as the field name and with XML attributes named as 'Value' and all belonging Array Elements' names.
        xsdElementArrayEdt = _parentXmlDoc.createElement2('xs:element', DocConstantDSP::XmlShemaNamespaceUri);
        xsdChoiceParentXsdElement.appendChild(xsdElementArrayEdt);
    
        xsdElementNameAttr = _parentXmlDoc.createAttribute('name');
        xsdElementNameAttr.value(this.getFieldName());
        xsdElementArrayEdt.setAttributeNode(xsdElementNameAttr);
    
        // Create annotation for the field label.
        if (this.getFieldLabelId())
        {
            xsdAnnotation = DocDataSourceProviderHelper::createXsdAnnotationLabel(
                                _parentXmlDoc, this.getFieldLabelId(), this.getFieldLabel());
            xsdElementArrayEdt.appendChild(xsdAnnotation);

            // Add the <xse:arrayEdt /> element within the <xs:appinfo> element.
            /*
            <xs:appinfo>
                <xse:arrayEdt />
                <xse:label xse:text="LABEL TRANSLATION" xse:refCode="@SYS12345" />
            </xs:appinfo>
            */

            XmlElement appInfoElement = xsdAnnotation.firstChild();
            XmlElement arrayEdtElem = _parentXmlDoc.createElement2(
                DocConstantDSP::XmlDsPackageDocentricExtNamespacePrefix + ':' + DocConstantDSP::XsdElementArrayEdt, DocConstantDSP::XmlDsPackageDocentricExtNamespaceUrl);
            appInfoElement.appendChild(arrayEdtElem);
        }

        // Now create XSD nodes for the XML attributes named as 'Value' and all belonging Array Elements' names.
        /* Need to generate <xs:element> and <xs:complexType>.
          <xs:element name="AttributeContainer">
            <xs:complexType>
                <xs:attribute name="Value" type="xs:integer"></xs:attribute>
                <xs:attribute name="Purpose" type="xs:integer"></xs:attribute>
                <xs:attribute name="CostCenter" type ="xs:integer"></xs:attribute>
            </xs:complexType>
          </xs:element>
        */

        // Complex type XML element.
        XmlElement xsdComplexType = _parentXmlDoc.createElement2('xs:complexType', DocConstantDSP::XmlShemaNamespaceUri);
        xsdElementArrayEdt.appendChild(xsdComplexType);

        // 'Value' attribute.
        XmlElement xsdAttrElement_Value, xsdAttrElement_Elem;
        xsdAttrElement_Value = DocDataSourceProviderHelper::createXsdAttrElementFromEdt(_parentXmlDoc,
                DocConstantDSP::XmlAttrArrayEdtValue, sysDictType.id(), this.getFieldLabelId(), this.getFieldLabel(), this.recordBuildingContext());
        xsdComplexType.appendChild(xsdAttrElement_Value);

        // Create XML element for XSD attributes for each of the array element.
        Array arrayEdtDef;  // Array([ArrayElementName (str), ArrayElementLabel (str)])
        arrayEdtDef = this.recordBuildingContext().getArrayEdtDefinition(edtId);
        str elementName, elementLabelId;
        for (int i = 1; i <= arrayEdtDef.lastIndex(); i++)
        {
            [elementName, elementLabelId] = arrayEdtDef.value(i);
            xsdAttrElement_Elem = DocDataSourceProviderHelper::createXsdAttrElementFromEdt(_parentXmlDoc,
                elementName, sysDictType.id(), elementLabelId, DocLabelHelper::resolveSysLabel(elementLabelId, languageId), this.recordBuildingContext());

            xsdComplexType.appendChild(xsdAttrElement_Elem);
        }

        return xsdElementArrayEdt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Dimensions Map(Types::String, Types::Container).
    /// </summary>
    /// <returns>Map(Dimension name, [Dimension label code, Dimension display value, Dimension description])</returns>
    public Map dimensions()
    {
        return dimensions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills the Dimensions map.
    /// </summary>
    private void fillDimensions()
    {
        DefaultDimensionView                    defaultDimensionView;
        DimensionStorage                        dimensionStorage;
        DimensionAttributeLevelValueAllView     dimAttrView;
        DimensionAttribute                      dimAttr;
        Common                                  dimAtrrViewCommon;
        SysDictTable                            dictTableBackingEntity;
        utcdatetime                             dateMin = DateTimeUtil::minValue();
        utcdatetime                             dateMax = DateTimeUtil::maxValue();
        str                                     dynamicAccountName;


        if (!isDefaultDimension && !isLedgerDimension)
        {
            return;
        }

        dimensions = new Map(Types::String, Types::Container);
        dimensionDynamicAccounts = new Map(Types::String, Types::Container);

        if (!fieldValue)
        {
            return;
        }

        // It inherits default dimension.
        if (isDefaultDimension)
        {
            while select defaultDimensionView
                  where defaultDimensionView.DefaultDimension == fieldValue
            {
                dictTableBackingEntity = this.recordBuildingContext().getSysDictTable(defaultDimensionView.BackingEntityType);

                dimAtrrViewCommon = dictTableBackingEntity.makeRecord();

                select firstonly validTimeState(dateMin, dateMax) * from dimAtrrViewCommon
                where dimAtrrViewCommon.(defaultDimensionView.KeyAttribute) == defaultDimensionView.EntityInstance;

                dimensions.insert(defaultDimensionView.Name,                    // Dimension name
                             [this.recordBuildingContext().getLabelForTable(dictTableBackingEntity.id()),   // Dimension label code
                              defaultDimensionView.DisplayValue,                                            // Dimension display value
                              dimAtrrViewCommon.(defaultDimensionView.NameAttribute)]);                     // Dimension description
            }

            return;
        }

        // It inherits ledger base dimension.
        dimensionStorage = DimensionStorage::findById(fieldValue);
        ledgerDimensionDisplayValue = dimensionStorage.getComboDisplayValue();

        while select * from dimAttrView
              where dimAttrView.ValueCombinationRecId == fieldValue
              join BackingEntityType, Name, Type, KeyAttribute, NameAttribute from dimAttr
              where dimAttr.RecId == dimAttrView.DimensionAttribute
        {
            dictTableBackingEntity = this.recordBuildingContext().getSysDictTable(dimAttr.BackingEntityType);

            dimAtrrViewCommon = dictTableBackingEntity.makeRecord();

            select firstonly validTimeState(dateMin, dateMax) * from dimAtrrViewCommon
            where dimAtrrViewCommon.(dimAttr.KeyAttribute) == dimAttrView.EntityInstance;

            if (dimAttr.Type != DimensionAttributeType::DynamicAccount)
            {
                dimensions.insert(dimAttr.Name,                                // Dimension name
                             [this.recordBuildingContext().getLabelForTable(dictTableBackingEntity.id()),  // Dimension label ID
                              dimAttrView.DisplayValue,                                                    // Dimension display value
                              dimAtrrViewCommon.(dimAttr.NameAttribute)]);                                 // Dimension description
            }
            else
            {
                dynamicAccountName = dimAttr.Name;
                if (strStartsWith(dimAttr.Name, DocConstantDSP::SystemGeneratedAttribute))
                {
                    dynamicAccountName = subStr(dimAttr.Name, strLen(DocConstantDSP::SystemGeneratedAttribute) + 1,
                                                              strLen(dimAttr.Name) - strLen(DocConstantDSP::SystemGeneratedAttribute));
                }

                dimensionDynamicAccounts.insert(dynamicAccountName,             // Dimension name
                                           [this.recordBuildingContext().getLabelForTable(dictTableBackingEntity.id()),  // Dimension label ID
                                            dimAttrView.DisplayValue,                                                    // Dimension display value
                                            dimAtrrViewCommon.(dimAttr.NameAttribute)]);                                 // Dimension description
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets label value (not label ID) of the field.
    /// </summary>
    /// <returns>Label value of the field.</returns>
    public str getFieldLabel()
    {
        return fieldLabelValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldLabelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets label ID of the field.
    /// </summary>
    /// <returns>Label ID of the field.</returns>
    public LabelId getFieldLabelId()
    {
        return fieldLabelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Field name. It will result in a name of the field (XML attribute) in resulting data source (XML).
    /// </summary>
    /// <returns>Field name</returns>
    public str getFieldName()
    {
        return fieldName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Field value. It will result in a value of the field (XML attribute) in resulting data source (XML).
    /// </summary>
    /// <returns>Field value</returns>
    public anytype getFieldValue()
    {
        return fieldValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the field language ID.
    /// </summary>
    /// <returns>The field language ID</returns>
    public LanguageId getLanguageId()
    {
        return languageId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent record.
    /// </summary>
    /// <returns>Parent record</returns>
    public DocXmlRecord getParent()
    {
        return parent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculatedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is field calculated.
    /// Calculated field can be added to both types of the parent record:
    /// - table buffer based
    /// - calculated record
    /// </summary>
    /// <returns>True if the field is calculated; otherwise false</returns>
    public boolean isCalculatedField()
    {
        return isCalculatedField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserDefEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the (calculated) field a user-defined enum field.
    /// </summary>
    /// <returns>True, if the field is a user-defined enum field; otherwise false</returns>
    /// <remarks>Applicable for GER and Custom Fields enums.</remarks>
    public boolean isUserDefEnum()
    {
        return isUserDefEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isArrayEdtField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is an array EDT field.
    /// </summary>
    /// <returns>True if the field is an an array EDT field; otherwise false</returns>
    public boolean isArrayEdtField()
    {
        return isArrayEdtField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the field represent a default dimension.
    /// </summary>
    /// <returns>True if the field is a default dimension; otherwise false</returns>
    public boolean isDefaultDimension()
    {
        return isDefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDimensionField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the field is a dimension field.
    /// </summary>
    /// <returns>True if the field is a dimension field; otherwise false</returns>
    public boolean isDimensionField()
    {
        return isDefaultDimension || isLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEnumField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Is the field is an enum field.
    /// </summary>
    /// <returns>True if the field is an enum field; otherwise false</returns>
    public boolean isEnumField()
    {
        if (DocGlobalHelper::isEnumBoolean(enumId))
        {
            return false;
        }
    
        return enumId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the field represent a Ledger dimension.
    /// </summary>
    /// <returns>True if the field is a Ledger dimension; otherwise false</returns>
    public boolean isLedgerDimension()
    {
        return isLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionDisplayValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the display value of the Ledger dimension field.
    /// </summary>
    /// <returns>The display value of the Ledger dimension field.</returns>
    public str ledgerDimensionDisplayValue()
    {
        return ledgerDimensionDisplayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(DocDataFieldType _dataFieldType,
                       TableId _tableId, FieldId _fieldId, anytype _fieldValue,
                       str _calculatedFieldName, int _edtId, EnumId _enumId,
                       str _fieldLabelIdOrValue, LanguageId _languageId,
                       DocXmlRecordBuildingContext _recordBuildingContext)
    {
        recordBuildingContext = _recordBuildingContext;
    
        isCalculatedField = DocDataFieldType::CalculatedField == _dataFieldType || DocDataFieldType::CalculatedUserDefEnumField == _dataFieldType;
        isUserDefEnum = DocDataFieldType::CalculatedUserDefEnumField == _dataFieldType;
    
        if (isCalculatedField)
        {
            fieldName = _calculatedFieldName;
    
            // EDT.
            edtId = _edtId;
            sysDictType = recordBuildingContext.getSysDictType(edtId);
    
            // Enum.
            if (sysDictType != null && sysDictType.enumId())
            {
                enumId = sysDictType.enumId();
            }
            else
            {
                enumId = _enumId;
            }
            sysDictEnum = recordBuildingContext.getSysDictEnum(enumId);
        }
        else
        {
            fieldId = _fieldId;
            sysDictField = recordBuildingContext.getSysDictField(_tableId, _fieldId);
    
            fieldName = sysDictField.name();
    
            tableId = _tableId;
            sysDictTable = recordBuildingContext.getSysDictTable(tableId);
    
            enumId = sysDictField.enumId();
            edtId = sysDictField.typeId();
    
            sysDictEnum = recordBuildingContext.getSysDictEnum(enumId);
            sysDictType = recordBuildingContext.getSysDictType(edtId);
        }

        fieldValue = _fieldValue;

        // Handles ASCII control characters in the string which are not supported by XML v. 1.0.
        if (recordBuildingContext.asciiControlCharactersHandlingMode() != DocAsciiControlCharactersHandling::NoAction && fieldValue != null && typeOf(fieldValue) == Types::String)
        {
            fieldValue = DocGlobalHelper::handleAsciiControlCharactersInString(fieldValue, recordBuildingContext.asciiControlCharactersHandlingMode());
        }
    
        isArrayEdtField = false;
        if (sysDictType && sysDictType.arraySize() > 1)
        {
            isArrayEdtField = true;
        }
    
        languageId = _languageId;
        this.setFieldLabelIdAndValue(_fieldLabelIdOrValue);
    
        isDefaultDimension = false;
        isLedgerDimension = false;
        if (sysDictType)
        {
            if (recordBuildingContext.isEdtExtendingDefaultDimension(edtId))
            {
                isDefaultDimension = true;
            }
            else if (recordBuildingContext.isEdtExtendingLedgerDimension(edtId))
            {
                isLedgerDimension = true;
            }
            else if (recordBuildingContext.isEdtExtendingDimensionEnumeration(edtId))
            {
                if (sysDictTable)
                {
                    DocGlobalHelper::handleException(funcName(), strFmt('Dimension EDTs (%1) with base type DimensionEnumeration are not supported. Field: %2, Table: %3.',
                                                                         sysDictType.name(), fieldName, sysDictTable.name()));
                }
                else
                {
                    DocGlobalHelper::handleException(funcName(), strFmt('Dimension EDTs (%1) with base type DimensionEnumeration are not supported. Field: %2.', sysDictType.name(), fieldName));
                }
            }
        }
    
        this.fillDimensions();
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordBuildingContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of the DocXmlRecordBuildingContext object.
    /// </summary>
    /// <returns>An instance of the DocXmlRecordBuildingContext object</returns>
    public DocXmlRecordBuildingContext recordBuildingContext()
    {
        return recordBuildingContext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serializeToXmlAndAppend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends the XML element representing the field to the parent XML element.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXmlElement">Parent XML element</param>
    public void serializeToXmlAndAppend(XmlDocument _parentXmlDoc, XmlElement _parentXmlElement)
    {
        XmlElement     xmlElement;
        XmlAttribute   xmlAttr;
    
    
        if (this.isDimensionField())
        {
            xmlElement = this.createXmlElementsFromDimensionField(_parentXmlDoc);
            _parentXmlElement.appendChild(xmlElement);
        }
        else if (this.isEnumField())
        {
            xmlElement = this.createXmlElementFromEnumField(_parentXmlDoc);
            _parentXmlElement.appendChild(xmlElement);
        }
        else if (this.isUserDefEnum())
        {
            xmlElement = this.createXmlElementFromUserDefEnumField(_parentXmlDoc);
            _parentXmlElement.appendChild(xmlElement);
        }
        else if (this.isArrayEdtField())
        {
            xmlElement = this.createXmlElementFromArrayEdtField(_parentXmlDoc);
            _parentXmlElement.appendChild(xmlElement);
        }
        else
        {
            xmlAttr = this.createXmlAttribute(_parentXmlDoc, this.recordBuildingContext());
            if (xmlAttr != null)
            {
                _parentXmlElement.setAttributeNode(xmlAttr);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>serializeToXsdAndAppend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends XML element representing XSD attribute for the field to the parent XSD element.
    /// </summary>
    /// <param name = "_parentXmlDoc">Parent XML document</param>
    /// <param name = "_parentXsdElement">Parent XSD element</param>
    public void serializeToXsdAndAppend(XmlDocument _parentXmlDoc, XmlElement _parentXsdElement)
    {
        XmlElement xsdComplexType, xsdChoice;
        XmlElement xsdAttr;
    
    
        xsdComplexType = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, _parentXsdElement, 'xs:complexType');
        if (this.isDimensionField())
        {
            xsdChoice = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexType, 'xs:choice');
            if (xsdChoice == null)
            {
                // Create <xs:choice> element.
                xsdChoice = DocDataSourceProviderHelper::createXsdChoiceElement(_parentXmlDoc);
                xsdComplexType.appendChild(xsdChoice);
            }
    
            this.createXsdElementsFromDimensionField(_parentXmlDoc, _parentXsdElement);
        }
        else if (this.isEnumField())
        {
            xsdChoice = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexType, 'xs:choice');
            if (xsdChoice == null)
            {
                // Create <xs:choice> element.
                xsdChoice = DocDataSourceProviderHelper::createXsdChoiceElement(_parentXmlDoc);
                xsdComplexType.appendChild(xsdChoice);
            }
    
            this.createXsdElementsFromEnumField(_parentXmlDoc, _parentXsdElement);
        }
        else if (this.isUserDefEnum())
        {
            xsdChoice = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexType, 'xs:choice');
            if (xsdChoice == null)
            {
                // Create <xs:choice> element.
                xsdChoice = DocDataSourceProviderHelper::createXsdChoiceElement(_parentXmlDoc);
                xsdComplexType.appendChild(xsdChoice);
            }
    
            this.createXsdElementsFromUserDefEnumField(_parentXmlDoc, _parentXsdElement);
        }
        else if (this.isArrayEdtField())
        {
            xsdChoice = DocDataSourceProviderHelper::selectXsdElement(_parentXmlDoc, xsdComplexType, 'xs:choice');
            if (xsdChoice == null)
            {
                // Create <xs:choice> element.
                xsdChoice = DocDataSourceProviderHelper::createXsdChoiceElement(_parentXmlDoc);
                xsdComplexType.appendChild(xsdChoice);
            }
    
            this.createXsdElementsFromArrayEdtField(_parentXmlDoc, _parentXsdElement);
        }
        else
        {
            xsdAttr = this.createXsdAttribute(_parentXmlDoc);
            xsdComplexType.appendChild(xsdAttr);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldLabel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new field label value (not label ID).
    /// </summary>
    /// <param name="_fieldLabelValue">
    /// Label value of the field, that will be a friendly name of the data field
    /// in the resulting data source.
    /// </param>
    public void setFieldLabel(str _fieldLabelValue)
    {
        if (_fieldLabelValue && DocLabelHelper::isLabelIdForDsProvider(_fieldLabelValue))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setFieldLabel: Provided parameter (%1) is a valid label ID. Use the setFieldLabelId() method instead.', _fieldLabelValue));
        }
    
        this.setFieldLabelIdAndValue(_fieldLabelValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldLabelId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new field label Id and field label value resolved in the language of the field.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </summary>
    /// <param name="_fieldLabelId">Field label ID.</param>
    public void setFieldLabelId(LabelId _fieldLabelId)
    {
        if (_fieldLabelId && !DocLabelHelper::isLabelIdForDsProvider(_fieldLabelId))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method setFieldLabelId: Provided parameter (%1) is not a valid label ID', _fieldLabelId));
        }
    
        this.setFieldLabelIdAndValue(_fieldLabelId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldLabelIdAndValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets field label ID and resolves field label value in the language of the field
    /// in case that the _labelIdOrValue parameter is a label ID. Otherwise, sets field label ID
    /// to an empty string and field label value to the value of the _labelIdOrValue parameter.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </summary>
    /// <param name="_labelIdOrValue">Label ID (code) or value (text).</param>
    private void setFieldLabelIdAndValue(str _labelIdOrValue)
    {
        if (_labelIdOrValue)
        {
            // Check if this is a label ID.
            if (strScan(_labelIdOrValue, '@', 1, 1))
            {
                fieldLabelId = _labelIdOrValue;
                if (this.recordBuildingContext().isDesignTime())
                {
                    // Note: Resolving the label will be skiped in the runtime because of the performance.
                    fieldLabelValue = this.getlabelRepository().resolveDdspLabel(_labelIdOrValue, languageId);
                }
                else
                {
                    fieldLabelValue = '';
                }
    
                // Add the new label to the common label map.
                this.recordBuildingContext().ensureLabel(fieldLabelId);
            }
            else
            {
                fieldLabelId = '';
                fieldLabelValue = _labelIdOrValue;
            }
        }
        else
        {
            fieldLabelId = '';
            fieldLabelValue = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changes field name which was initially set during construction via <c>constructField</c> method.
    /// </summary>
    /// <param name="_newFieldName">New field name.</param>
    /// <remarks>Use this method to change XML attribute name in resulting XML.</remarks>
    public void setFieldName(str _newFieldName)
    {
        XmlDocument    testXmlDoc;
        XmlAttribute   testNameXmlAttr;
    
        if (!_newFieldName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method setFieldName: Parameter _newFieldName is not provided');
        }
    
        testXmlDoc = XmlDocument::newBlank();
        try
        {
            //BP Deviation Documented
            testNameXmlAttr = testXmlDoc.createAttribute(_newFieldName);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setFieldName: Parameter _newFieldName (%1) has invalid value for XML attribute. Parent record: %2', _newFieldName, this.getParent().getRecordName()));
        }
    
        if (this.getParent() != null && this.getParent().containField(_newFieldName))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method setFieldName: New field name (%1) already exists within the parent record (%2)', _newFieldName, this.getParent().getRecordName()));
        }
    
        fieldName = _newFieldName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFieldValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets new field value.
    /// </summary>
    /// <param name="_newFieldValue">New field value that has to be the same type as the existing field value.</param>
    /// <returns>True if the new field value is set; otherwise false</returns>
    public boolean setFieldValue(anytype _newFieldValue)
    {
        if (this.sysDictEnum())
        {
            if (Types::Enum == typeOf(_newFieldValue) || Types::Integer == typeOf(_newFieldValue))
            {
                // Note: There is no mechanism to check whether concrete enum types are matched.
                fieldValue = _newFieldValue;
                return true;
            }
    
            return false;
        }

        // Handles ASCII control characters in the string which are not supported by XML v. 1.0.
        if (recordBuildingContext.asciiControlCharactersHandlingMode() != DocAsciiControlCharactersHandling::NoAction && _newFieldValue != null && typeOf(_newFieldValue) == Types::String)
        {
            _newFieldValue = DocGlobalHelper::handleAsciiControlCharactersInString(_newFieldValue, recordBuildingContext.asciiControlCharactersHandlingMode());
        }

        if (this.sysDictType())
        {
            if (this.sysDictType().baseType() == typeOf(_newFieldValue))
            {
                fieldValue = _newFieldValue;
                return true;
            }
    
            return false;
        }
    
        if (typeOf(_newFieldValue) == typeOf(fieldValue))
        {
            fieldValue = _newFieldValue;
            return true;
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the new language of the field and automatically reset the field label value
    /// as well, in case that the field label ID is set.
    /// </summary>
    /// <param name="_languageId">Language ID.</param>
    public void setLanguageId(LanguageId _languageId)
    {
        languageId = _languageId;
    
        if (fieldLabelId)
        {
            // Reset the field label value.
            this.setFieldLabelIdAndValue(fieldLabelId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the parent XML record.
    /// </summary>
    /// <param name = "_parent">Parent XML record</param>
    public void setParent(DocXmlRecord _parent)
    {
        if (_parent != null && parent != null && _parent != parent)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Method setParent: Cannot set the parent record (%1) of the field (%2) because it already has a parent (%3) in the record tree. Remove or clone this field first.',
                           _parent.getRecordName(), this.getFieldName(), parent.getRecordName()));
        }
    
        parent = _parent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets SysDictEnum if the field is based on enum.
    /// </summary>
    /// <returns>SysDictEnum if the field is based on enum.</returns>
    /// <remarks>Applicable for both table buffer based and calculated fields.</remarks>
    public SysDictEnum sysDictEnum()
    {
        return sysDictEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets SysDictField for table buffer based field.
    /// </summary>
    /// <returns>SysDictField for table buffer based field.</returns>
    public SysDictField sysDictField()
    {
        return sysDictField;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets SysDictTable for table buffer based field.
    /// </summary>
    /// <returns>SysDictTable for table buffer based field.</returns>
    public SysDictTable sysDictTable()
    {
        return sysDictTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets SysDictType if the field is based on EDT.
    /// </summary>
    /// <returns>SysDictType if the field is based on EDT.</returns>
    /// <remarks>Applicable for both table buffer based and calculated fields.</remarks>
    public SysDictType sysDictType()
    {
        return sysDictType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCalculatedField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs calculated field (a DocXmlField instance) that can be append to both types of records:
    /// to a calculated record or to a table buffer based record (DocXmlRecord instance).
    /// NOTE: If used within the generateXmlDataSource() method of the data source provider class,
    /// either the language of the record builder or the language from the data source provider class
    /// (stored in dsProvider.parmParams().parmLanguageId()) should be used for the _languageId parameter.
    /// </summary>
    /// <param name="_calculatedFieldName">Name of the field.</param>
    /// <param name="_edtName">Name of extended data type if the calculated field is based on it. Use the extendedTypeStr() method to provide it.</param>
    /// <param name="_enumName">Name of enum type if the calculated field is based on it. Use the enumStr() method to provide it.</param>
    /// <param name="_fieldValue">Value of the field.</param>
    /// <param name="_fieldLabelIdOrValue">
    /// A label ID or value of the field. This label value will be mapped in the Friendly name of the data field in the resulting XML data source.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <param name="_languageId">Language of the field. If set, label ID will be resolved in this language.</param>
    /// <param name="_recordBuildingContext">Record building context that contains caching structures, etc.</param>
    /// <returns>
    /// New DocXmlField instance, which will result as an XML attribute in the resulting XML.
    /// Name of the field will be name of the mapped XML attribute.
    /// </returns>
    public static DocXmlField constructCalculatedField(str _calculatedFieldName,
                                                       ExtendedDataTypeName _edtName, EnumName _enumName,
                                                       anytype _fieldValue, str _fieldLabelIdOrValue = '',
                                                       LanguageId _languageId = currentUserLanguage(),
                                                       DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        SysDictType         sysDictType;
        EnumId              enumId;
        ExtendedTypeId      edtId;
        Types               inferredBaseType;
        EnumName            inferredEnumName;
        str                 fieldNameFirstLetterUpp;
    
    
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method constructCalculatedField: Parameter _calculatedFieldName is not provided');
        }
    
        if (!_recordBuildingContext.isValidCalculatedFieldName(_calculatedFieldName))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method constructCalculatedField: Parameter _calculatedFieldName (%1) has invalid value for XML Attribute', _calculatedFieldName));
        }
    
        // Calculate inferredBaseType.
        inferredBaseType = Types::AnyType;
        if (_enumName)
        {
            enumId = enumName2Id(_enumName);
            if (enumId == 0)
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Method constructCalculatedField: For the parameter _calculatedFieldName (%1), enum (%2) does not exist', _calculatedFieldName, _enumName));
            }
    
            inferredBaseType = Types::Enum;
            inferredEnumName = _enumName;
        }
    
        if (_edtName)
        {
            edtId = extendedTypeName2Id(_edtName);
            sysDictType = _recordBuildingContext.getSysDictType(edtId);
            if (!sysDictType)
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Method constructCalculatedField: For the parameter _calculatedFieldName (%1), EDT (%2) does not exist', _calculatedFieldName, _edtName));
            }
    
            if (enumId != 0 && sysDictType.enumId() != enumId)
            {
                DocGlobalHelper::handleException(funcName(),
                    strFmt('Method constructCalculatedField: For the parameter _calculatedFieldName (%1), EDT (%2) has as a base type enum (%3) that differs from the provided enum (%4)',
                           _calculatedFieldName, sysDictType.name(), enumId2Name(sysDictType.enumId()), _enumName));
            }
    
            inferredBaseType = sysDictType.baseType();
            if (sysDictType.enumId() != 0)
            {
                inferredEnumName = enumId2Name(sysDictType.enumId());
            }
        }
    
        // Check if the field value is set.
        if (typeOf(_fieldValue) == Types::AnyType)
        {
            // It can happen that underlying table record doesn't exist, e.g. if we have a query with outer join based DSP.
            // But this will be possible to happen only in design-time data source generation.
            if (inferredBaseType != Types::AnyType)
            {
                _fieldValue = Global::nullValueFromType(inferredBaseType);
            }
        }
    
        // Check the field value.
        if (typeOf(_fieldValue) == Types::AnyType &&
            _fieldValue != conNull())  // added because of an CIL error related to empty container.
        {
            DocGlobalHelper::handleException(funcName(), 
                strFmt('Method constructCalculatedField: For the parameter _calculatedFieldName (%1), _fieldValue is not initialized', _calculatedFieldName));
        }
    
        if (typeOf(_fieldValue) == Types::Class ||
            typeOf(_fieldValue) == Types::Record ||
            typeOf(_fieldValue) == Types::void)
        {
            if (_recordBuildingContext.skipFieldIfErrorOccurs())
            {
                return null;
            }
            else
            {
                DocGlobalHelper::handleException(funcName(), 
                    strFmt('Method constructCalculatedField: Not supported type (%1) of the _fieldValue for the parameter _calculatedFieldName (%2)',
                           typeOf(_fieldValue), _calculatedFieldName));
            }
        }
    
        if (typeOf(_fieldValue) == typeOf(null))
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('Method constructCalculatedField: For the parameter _calculatedFieldName (%1), the provided field value is null', _calculatedFieldName));
        }
    
        if (inferredBaseType != Types::Enum && typeOf(_fieldValue) == Types::Enum)
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt('For the parameter _calculatedFieldName (%1), the provided field value (%2) is of an enum type that is not specified. Use the addCalculatedFieldEnum() or addCalculatedFieldEdt() method instead.',
                       _calculatedFieldName, _fieldValue));
        }
    
        // Check if the field value matches the provided base type.
        if (inferredBaseType != Types::AnyType)
        {
            switch (inferredBaseType)
            {
                case Types::Enum:
                    if (typeOf(_fieldValue) != Types::Enum && typeOf(_fieldValue) != Types::Integer)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided enum type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredEnumName));
                    }
                    break;
    
                case Types::Integer:
                case Types::Time:
                    if (typeOf(_fieldValue) != Types::Integer && typeOf(_fieldValue) != Types::Time)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided base type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredBaseType));
                    }
                    break;
    
                case Types::Int64:
                    if (typeOf(_fieldValue) != Types::Int64 && typeOf(_fieldValue) != Types::Integer &&
                        typeOf(_fieldValue) != Types::Time)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided base type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredBaseType));
                    }
                    break;
    
                case Types::Real:
                    if (typeOf(_fieldValue) != Types::Real && typeOf(_fieldValue) != Types::Int64 &&
                        typeOf(_fieldValue) != Types::Integer && typeOf(_fieldValue) != Types::Time)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided base type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredBaseType));
                    }
                    break;
    
                case Types::String:
                case Types::RString:
                case Types::VarString:
                    if (typeOf(_fieldValue) != Types::String && typeOf(_fieldValue) != Types::RString &&
                        typeOf(_fieldValue) != Types::VarString)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided base type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredBaseType));
                    }
                    break;
    
                default:
                    if (typeOf(_fieldValue) != inferredBaseType)
                    {
                        DocGlobalHelper::handleException(funcName(),
                            strFmt('For the parameter _calculatedFieldName (%1), type (%2) of the provided field value (%3) is not of the provided base type (%4)',
                                   _calculatedFieldName, typeOf(_fieldValue), _fieldValue, inferredBaseType));
                    }
            }
        }
    
        // Capitalize the first letter of the field name.
        fieldNameFirstLetterUpp = DocGlobalHelper::capitalizeFirstLetter(_calculatedFieldName);
    
        // Construct the field.
        return new DocXmlField(DocDataFieldType::CalculatedField, 0, 0, _fieldValue, fieldNameFirstLetterUpp,
                               edtId, enumId, _fieldLabelIdOrValue, _languageId,
                               _recordBuildingContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs field (a DocXmlField instance) that can be append only to a table buffer based record (a DocXmlRecord instance).
    /// NOTE: If used within the generateXmlDataSource() method of the data source provider class,
    /// either the language of the record builder or the language from the data source provider class
    /// (stored in dsProvider.parmParams().parmLanguageId()) should be used for the _languageId parameter.
    /// </summary>
    /// <param name="_tableId">Table ID that provided field belongs. Use the tableNum() method to provide it.</param>
    /// <param name="_fieldName">Field name. Use the fieldStr() method to provide it.</param>
    /// <param name="_fieldValue">Value of the field.</param>
    /// <param name="_overridingLabelIdOrValue">
    /// Overriding label ID or label value. If ommited, a label of the underlying field is used.
    /// WARNING: For providing label ID use the literalStr() method.
    /// </param>
    /// <param name="_languageId">Language of the field. If set, label ID will be resolved in this language.</param>
    /// <param name="_recordBuildingContext">Record building context that contains caching structures, etc.</param>
    /// <returns>
    /// New DocXmlField instance, which will result as an XML attribute in the resulting XML.
    /// Name of the field will be name of the mapped XML attribute.
    /// </returns>
    public static DocXmlField constructField(TableId _tableId, FieldName _fieldName, anytype _fieldValue,
                                             str _overridingLabelIdOrValue = '',
                                             LanguageId _languageId = currentUserLanguage(),
                                             DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        str         labelIdOrValue;
        FieldId     fieldId;
    
        if (!_tableId)
        {
            DocGlobalHelper::handleException(funcName(), 'Method constructField: Parameter _tableId is not provided');
        }
        if (!_fieldName)
        {
            DocGlobalHelper::handleException(funcName(), 'Method constructField: Parameter _fieldName is not provided');
        }
    
        if (!tableId2name(_tableId))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method constructField: For the parameter _fieldName: %1, table with ID (%2) does not exist', _fieldName, _tableId));
        }
    
        fieldId = fieldName2id(_tableId, _fieldName);
        if (!fieldId)
        {
            DocGlobalHelper::handleException(funcName(),
                    strFmt('Method constructField: Field (%1) does not belong to the table (%2)', _fieldName, tableId2name(_tableId)));
        }
    
        // Get the field label.
        if (_overridingLabelIdOrValue)
        {
            labelIdOrValue = _overridingLabelIdOrValue;
        }
        else
        {
            labelIdOrValue = _recordBuildingContext.getLabelForField(_tableId, fieldId);
        }
    
        return new DocXmlField(DocDataFieldType::TableBufferField, _tableId, fieldId, _fieldValue, '', 0, 0, labelIdOrValue, _languageId, _recordBuildingContext);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCalculatedFieldUserDefEnum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs calculated field (a DocXmlField instance) based on a user-defined enum
    /// (from GER or Custom Fields) that can be append to both types of records:
    /// to a calculated record or to a table buffer based record (DocXmlRecord instance).
    /// NOTE: If used within the generateXmlDataSource() method of the data source provider class,
    /// either the language of the record builder or the language from the data source provider class
    /// (stored in dsProvider.parmParams().parmLanguageId()) should be used for the _languageId parameter.
    /// </summary>
    /// <param name="_calculatedFieldName">Name of the field.</param>
    /// <param name="_enumValueName">Name of the selected user-defined enum node.</param>
    /// <param name="_enumValueLabelIdOrValue">Label ID (or Label Value, if Label ID is not provided) of the selected user-defined enum node.</param>
    /// <param name="_fieldLabelIdOrValue">
    /// A label ID or value of the field. This label value will be mapped in the Friendly name of the data field in the resulting XML data source.
    /// </param>
    /// <param name="_languageId">Language of the field. If set, label ID will be resolved in this language.</param>
    /// <param name="_recordBuildingContext">Record building context that contains caching structures, etc.</param>
    /// <returns>
    /// New DocXmlField instance, which will result as an XML attribute in the resulting XML.
    /// Name of the field will be name of the mapped XML attribute.
    /// </returns>
    public static DocXmlField constructCalculatedFieldUserDefEnum(str _calculatedFieldName,
                                                                  str _enumValueName, str _enumValueLabelIdOrValue, // selected enum node Name and Label ID or Value
                                                                  str _fieldLabelIdOrValue = '',
                                                                  LanguageId _languageId = currentUserLanguage(),
                                                                  DocXmlRecordBuildingContext _recordBuildingContext = new DocXmlRecordBuildingContext())
    {
        if (!_calculatedFieldName)
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method %1: Parameter _calculatedFieldName is not provided', funcName()));
        }

        if (!_recordBuildingContext.isValidCalculatedFieldName(_calculatedFieldName))
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method %1: Parameter _calculatedFieldName (%2) has invalid value for XML Attribute', funcName(), _calculatedFieldName));
        }
    
        if (!_enumValueName)
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Method %1: Parameter _enumValueName is not provided', funcName()));
        }

        // Capitalize the first letter of the field name.
        str fieldNameFirstLetterUpp = DocGlobalHelper::capitalizeFirstLetter(_calculatedFieldName);
    
        // Construct the field.
        return new DocXmlField(DocDataFieldType::CalculatedUserDefEnumField, 0, 0, [_enumValueName, _enumValueLabelIdOrValue], 
                               fieldNameFirstLetterUpp, 0, 0, _fieldLabelIdOrValue, _languageId, _recordBuildingContext);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>