<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocGlobalHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Dynamics.AX.Framework.Utilities.UrlHelper;
using Microsoft.Dynamics.ApplicationPlatform.Environment;
using Docentric.AX.Framework.Utilities;
using Docentric.AX.Framework.Cache;

/// <summary>
/// The DocGlobalHelper class is a helper class that contains useful helper methods.
/// </summary>
public class DocGlobalHelper
{
    private static str clientEndpoint = '';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>navigateToUrl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Navigates to the specified public URL.
    /// </summary>
    /// <param name = "_url">URL</param>
    /// <param name = "_openInNewTab">Should the URL page be opened in a new tab</param>
    /// <param name = "_showExitWarning">Should the exit warning be displayed</param>
    public static void navigateToUrl(str _url, boolean _openInNewTab = false, boolean _showExitWarning = false)
    {
        if (_url)
        {
            Browser br = new Browser();
            br.navigate(_url, _openInNewTab, _showExitWarning);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateRecordUrl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a valid URL that opens the underlying entity.
    /// </summary>
    /// <param name = "_menuItemName">A menu item name</param>
    /// <param name = "_menuItemType">A menu item type</param>
    /// <param name = "_dataSourceName">A data source name</param>
    /// <param name = "_fieldNameValueMap">A map with a field name and its value </param>
    /// <param name = "_dataAreaId">A data area Id</param>
    /// <returns>A generated URL</returns>
    /// <remarks>
    /// Due to performance issues when repeatedly calling the method (e.g. when generating deep links
    /// for the report), an instance of the UrlGenerator object is cached. For each instantiation
    /// of the UrlGenerator object, an instance of the EntryptioEngine object is created, which takes
    /// a lot of time and causes the performance loss.
    /// </remarks>
    public static str generateRecordUrl(
        str _menuItemName, 
        MenuItemType _menuItemType,
        DataSourceName _dataSourceName, 
        Map _fieldNameValueMap /* Map(Types::String, Types::String) */, 
        DataAreaId _dataAreaId = curExt())
    {
        str errorMsg = strFmt("@DocentricAX5:GeneratingLinkFailed", _menuItemName);

        try
        {
            boolean addToCache = false;
            const int CacheExpirationInSeconds = 5*60;  // Cache expiration is set to 5 min
        
            DocCacheManager cache = DocCacheManager::GetInstance();
            str key = strFmt('%1_%2', classStr(DocGlobalHelper), staticMethodStr(DocGlobalHelper, generateRecordUrl));

            // Get an instance of the UrlGenerator object from the cache
            UrlGenerator urlGenerator = cache.Get(key);
            // Create a new instance of the UrlGenerator object if it is not in the cache
            if (urlGenerator == null)
            {
                addToCache = true;
                urlGenerator = new UrlGenerator();
            }

            urlGenerator.HostUrl = DocGlobalHelper::getClientEndpoint();
            urlGenerator.MenuItemName = _menuItemName;
            urlGenerator.MenuItemType = _menuItemType;
            urlGenerator.Partition = getCurrentPartition();
            urlGenerator.Company = _dataAreaId;
            // Check whether a new instance of the RequestQueryParameterCollection object needs to be created
            if (!addToCache)
            {
                urlGenerator.RequestQueryParameterCollection = new RequestQueryParameterCollection();
            }

            if (_dataSourceName != '' && _fieldNameValueMap != null)
            {
                MapEnumerator mapEnumerator = _fieldNameValueMap.getEnumerator();
                var requestQueryParameterCollection = urlGenerator.RequestQueryParameterCollection;
                while (mapEnumerator.moveNext())
                {
                    requestQueryParameterCollection.UpdateOrAddEntry(_dataSourceName, mapEnumerator.currentKey(), mapEnumerator.currentValue());
                }
            }
 
            str generatedUrl = urlGenerator.GenerateFullUrl().AbsoluteUri;

            // Check whether an instance of the UrlGenerator object needs to be added to the cache 
            if (addToCache)
            {
                cache.Add(key, urlGenerator, CacheExpirationInSeconds);
            }
            return generatedUrl;
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrError(funcName(), errorMsg);
        }
        catch (Exception::Internal)
        {
            DocGlobalHelper::handleClrError(funcName(), errorMsg);
        }
        catch
        {
            DocGlobalHelper::handleError(errorMsg, true, funcName());
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClientEndPoint</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets client root URL. (code based on SysWorkflowHelper::getClientEndpoint)
    /// </summary>
    /// <returns>HostURL (on On-Prem it contains namespaces/AXSF/)</returns>
    public static str getClientEndPoint()
    {
        if (!clientEndpoint)
        {
            IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();

            if (!(environment && environment.Infrastructure))
            {
                return '';
            }

            var clientUrl = environment.Infrastructure.HostUrl;

            if (!clientUrl.EndsWith('/'))
            {
                clientUrl += '/';
            }

            clientEndpoint = clientUrl;
        }

        return clientEndpoint;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAADTenantId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the AAD TenantId from app.config.
    /// </summary>
    /// <returns>AADTenantId</returns>
    public static str getAADTenantId()
    {
        IApplicationEnvironment environment = EnvironmentFactory::GetApplicationEnvironment();

        if (!(environment && environment.Aad))
        {
            return '';
        }

        return environment.Aad.AADTenantId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openMenuItemInNewWindow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the given menu item in a new browser window.
    /// </summary>
    /// <param name = "_menuItemName">Menu item name</param>
    /// <param name = "_menuItemType">MenuItemType</param>
    public static void openMenuItemInNewWindow(str _menuItemName, MenuItemType _menuItemType)
    {
        new Browser().navigate(DocGlobalHelper::generateUrlForMenuItem(_menuItemName, _menuItemType), true, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateUrlForMenuItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates URL for the given menu item.
    /// </summary>
    /// <param name = "_menuItemName">Menu item name</param>
    /// <param name = "_menuItemType">MenuItemType</param>
    /// <returns>Generated URL for the given menu item</returns>
    public static str generateUrlForMenuItem(str _menuItemName, MenuItemType _menuItemType)
    {
        Args args = new Args();
        args.menuItemName(_menuItemName);
        args.menuItemType(_menuItemType);

        FormRun formRun = ClassFactory.formRunClass(args);
        formRun.init();

        return URLUtility::generateUrl(FormRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginFromUrl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Origin from the url.
    /// </summary>
    /// <returns>
    /// Origin from url. For example, for url like https://test.dynamics.com/namespace/{guid}/default.htm it will return https://test.dynamics.com
    /// </returns>
    public static str getOriginFromUrl()
    {
        str result = null;

        System.Uri currentUrl = DocGlobalHelper::GetCurrentUri();
        if (currentUrl)
        {
            result = currentUrl.GetLeftPart(System.UriPartial::Authority);
        }
        
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeploymentLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Deployment location from a URL.
    /// </summary>
    /// <returns>
    /// A Deployment location. Return is based on extracting the url before the ending slash which is the deployment location.
    /// For example for url like https://test.dynamics.com/namespace/{guid}/default.htm it will return https://test.dynamics.com/namespace/{guid}
    /// </returns>
    public static str getDeploymentLocation()
    {
        str result = null;

        System.Uri currentUrl = DocGlobalHelper::getCurrentUri();
        if (currentUrl)
        {
            System.String partialStringUri = currentUrl.GetLeftPart(System.UriPartial::Path);
            result = partialStringUri.Substring(0, partialStringUri.LastIndexOf('/'));
        }
        
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentUri</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current request URL.
    /// </summary>
    /// <returns>The current request URL</returns>
    public static System.Uri getCurrentUri()
    {
        Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext sessionContext;
        System.Uri currentUrl = null;

        sessionContext = Microsoft.Dynamics.Client.ServerForm.Contexts.SessionContext::get_Current();
        if (sessionContext)
        {
            currentUrl = sessionContext.get_RequestUrl();
        }

        return currentUrl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClientURLQueryValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of the query paramter from the client URL.
    /// </summary>
    /// <param name = "_queryParameter">The query parameter of the request on the client.</param>
    /// <returns>The value in the URL if the query parameter exists.</returns>
    public static str getClientURLQueryValue(str _queryParameter)
    {
        if (!hasGUI())
        {
            return '';
        }

        str value = '';
        System.Uri uri = DocGlobalHelper::getCurrentUri();
        if (uri)
        {
            System.String url = Microsoft.Dynamics.AX.Framework.Utilities.UrlHelper.UrlUtility::GetUrl(uri);
            if (url)
            {
                System.Uri decodedUri = new System.Uri(url);
                System.String[] modeKeyValue = System.Web.HttpUtility::ParseQueryString(decodedUri.Query).GetValues(_queryParameter);
                    
                if (modeKeyValue != null && modeKeyValue.Length >= 1)
                {
                    value = modeKeyValue.Get(0);
                }
            }
        }
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTableRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record for specified RecId from the specified table.
    /// </summary>
    /// <param name = "_tableId">Table Id</param>
    /// <param name = "_recId">Record Id</param>
    /// <param name = "_dataAreaId">Data area Id</param>
    /// <returns>Table record</returns>
    public static Common getTableRecord(TableId _tableId, RefRecId _recId, DataAreaId _dataAreaId = '')
    {
        utcdatetime dateMin = DateTimeUtil::minValue();
        utcdatetime dateMax = DateTimeUtil::maxValue();
    
        if (!_tableId)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParameterNotSet", varStr(_tableId)));
        }
    
        DictTable dictTable = new DictTable(_tableId);
    
        if (dictTable == null)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:TableDoesNotExist", _tableId));
        }
    
        Common tableRecord = dictTable.makeRecord();
    
        if (_dataAreaId)
        {
            changecompany(_dataAreaId)
            {
                select firstonly validTimeState(dateMin, dateMax) * from tableRecord
                where tableRecord.RecId == _recId;
            }
        }
        else
        {
            select firstonly validTimeState(dateMin, dateMax) * from tableRecord
            where tableRecord.RecId == _recId;
        }

        return tableRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAotResourceContent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the AOT resource as stream.
    /// </summary>
    /// <param name = "_resourceName">AOT resource name</param>
    /// <returns>AOT resource as stream</returns>
    public static System.IO.Stream getAotResourceContent(str _resourceName)
    {
        System.IO.Stream stream = null;

        if (_resourceName == '')
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParameterNotSet", varStr(_resourceName)));
        }

        try
        {
            stream = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetResourceContentStream(_resourceName);
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:ErrorRetrievingResource", _resourceName));
        }
        catch (Exception::Internal)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:ErrorRetrievingResource", _resourceName));
        }

        return stream;
    }

]]></Source>
			</Method>
			<Method>
				<Name>aotResourceExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the specified AOT resource exists.
    /// </summary>
    /// <param name = "_resourceName">AOT resource name</param>
    /// <returns>True if the AOT resource exists; otherwise false</returns>
    public static boolean aotResourceExists(str _resourceName)
    {
        Microsoft.Dynamics.AX.Metadata.MetaModel.AxResource resource = null;

        if (_resourceName == '')
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParameterNotSet", varStr(_resourceName)));
        }

        try
        {
            resource = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetResource(_resourceName);
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:ErrorRetrievingResource", _resourceName));
        }
        catch (Exception::Internal)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:ErrorRetrievingResource", _resourceName));
        }

        if (resource == null)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capitalizeFirstLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the specified input string with a capital letter.
    /// </summary>
    /// <param name = "_inputStr">Input string</param>
    /// <returns>The input string with a capital letter</returns>
    public static str capitalizeFirstLetter(str _inputStr)
    {
        return strUpr(subStr(_inputStr, 1, 1)) + subStr(_inputStr, 2, strLen(_inputStr) - 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>capitalizeFirstLetterOfEachWord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the specified input string with a capital letter of each word.
    /// </summary>
    /// <param name = "_inputStr">Input string</param>
    /// <returns>The input string with a capital letter of each word.</returns>
    public static str capitalizeFirstLetterOfEachWord(str _inputStr)
    {
        int n = strScan(_inputStr, ' ', 1, strLen(_inputStr));
        while (n)
        {
            n++;
            _inputStr = strPoke(_inputStr, strUpr(subStr(_inputStr, n, 1)), n);
            n = strScan(_inputStr, ' ', n, strLen(_inputStr));
        }
        return _inputStr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>containsTags</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether _inputString contains the specified tags. The _matchAllTags flag specifies the match mode:
    /// - if false, the method checks whether _inputString contains ANY of the specified tags
    /// - if true, the method checks whether _inputString contains ALL of the specified tags
    /// </summary>
    /// <param name = "_inputString">Input string</param>
    /// <param name = "_tags">Tags separated by semicolons or commas</param>
    /// <param name = "_matchAllTags">Specifies whether to match all the tags</param>
    /// <returns>True if _inputString contains the specified tags depending on the match mode</returns>
    public static boolean containsTags(str _inputString, str _tags, boolean _matchAllTags = false)
    {
        if (_tags && !_inputString)
        {
            return false;
        }
        if (!_tags)
        {
            return true;
        }

        System.String inputString = _inputString;
        System.String tags = _tags;

        System.String[] delimiters = new System.String[2]();
        delimiters.SetValue(',', 0);
        delimiters.SetValue(';', 1);

        System.String[] inputStringArray = inputString.Split(delimiters, System.StringSplitOptions::RemoveEmptyEntries);
        System.String[] tagsArray = tags.Split(delimiters, System.StringSplitOptions::RemoveEmptyEntries);
                
        System.Collections.IEnumerator inputStringArrayEnumerator = inputStringArray.GetEnumerator();
        System.Collections.IEnumerator tagsArrayEnumerator = tagsArray.GetEnumerator();

        int cntEqual = 0;   // the number of matched tags
        while (tagsArrayEnumerator.MoveNext())
        {
            System.String tagValue = tagsArrayEnumerator.Current;

            // Go through the input string array and compare if the selected tag matches with the tag in the list
            inputStringArrayEnumerator.Reset();
            while (inputStringArrayEnumerator.MoveNext())
            {
                System.String inputValue = inputStringArrayEnumerator.Current;
                if (inputValue.Trim().Equals(tagValue.Trim(), System.StringComparison::InvariantCultureIgnoreCase))
                {
                    // Increase the number of matched tags 
                    cntEqual++;

                    if (_matchAllTags == false)
                    {
                        return true;
                    }
                    break;
                }
            }
        }
        return (cntEqual == tagsArray.Length ? true : false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImageMIMEContentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the image MIME tyoe from the specified image stream
    /// </summary>
    /// <param name = "_imageStream">Image stream</param>
    /// <returns>Image MIME type</returns>
    public static str getImageMIMEContentType(System.IO.MemoryStream _imageStream)
    {
        str defaultContentType = 'image/png';   // fallback value if the content type cannot be detected
        System.Int64 originalPosition = 0;

        try
        {
            originalPosition = _imageStream.Position;

            _imageStream.Position = 0;
            System.Drawing.Image image = System.Drawing.Image::FromStream(_imageStream, false, false);

            if (!image)
            {
                return defaultContentType;
            }

            if (image.RawFormat.Equals(System.Drawing.Imaging.ImageFormat::Bmp))
            {
                return 'image/bmp';
            }
            else if (image.RawFormat.Equals(System.Drawing.Imaging.ImageFormat::Gif))
            {
                return 'image/gif';
            }
            else if (image.RawFormat.Equals(System.Drawing.Imaging.ImageFormat::Jpeg))
            {
                return 'image/jpg';
            }
            else if (image.RawFormat.Equals(System.Drawing.Imaging.ImageFormat::Png))
            {
                return 'image/png';
            }
            else if (image.RawFormat.Equals(System.Drawing.Imaging.ImageFormat::Tiff))
            {
                return 'image/tiff';
            }
        }

        // If an exception is thrown, most probably the given binary is not a valid image.
        catch
        {
            // Swallow the exception and return the fallback value 'image/png'.
            exceptionTextFallThrough();
        }
        finally
        {
            // Revert the stream to the original position.
            _imageStream.Position = originalPosition;
        }

        return defaultContentType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertNonBlobToBlobContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// (FOR PACKED OBJECTS) Converts a non-blob container to a blob container.
    /// </summary>
    /// <param name = "_nonBlobContainer">Container which doesn't contain a blob (document or image) but a packed object, i.e. result of a pack() class method</param>
    /// <returns>Blob container which can be used with other methods to be converted to bytes or a base64 string</returns>
    public static container convertNonBlobToBlobContainer(container _nonBlobContainer)
    {
        container blobContainer;
    
        if (_nonBlobContainer)
        {
            try
            {
                ContainerClass containerClass = new ContainerClass(_nonBlobContainer);
                blobContainer = containerClass.toBlob();
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:NonBlobToBlobContainerConversionFailed", true);
            }
            catch
            {
                DocGlobalHelper::handleError("@DocentricAX5:NonBlobToBlobContainerConversionFailed", true, funcName(), true);
            }
        }
    
        return blobContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertBlobToNonBlobContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// (FOR PACKED OBJECTS) Converts a blob container to a non-blob container.
    /// </summary>
    /// <param name = "_blobContainer">Container which contains a blob which is not a document or image but a packed object, i.e. result of a pack() class method</param>
    /// <returns>Non-blob container which can be used with an unpack() class method</returns>
    public static container convertBlobToNonBlobContainer(container _blobContainer)
    {
        container nonBlobContainer;
    
        if (_blobContainer)
        {
            try
            {
                nonBlobContainer = ContainerClass::blob2Container(_blobContainer);
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:BlobToNonBlobContainerConversionFailed", true);
            }
            catch
            {
                DocGlobalHelper::handleError("@DocentricAX5:BlobToNonBlobContainerConversionFailed", true, funcName(), true);
            }
        }
    
        return nonBlobContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertBytesToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified byte array into a container.
    /// </summary>
    /// <param name = "_bytes">Byte array</param>
    /// <returns>Container</returns>
    public static container convertBytesToContainer(System.Byte[] _bytes)
    {
        container bytesAsContainer;
   
        if (_bytes != null)
        {
            int byteCount = _bytes.get_Length();
            if (byteCount > 0)
            {
                try
                {
                    using (System.IO.MemoryStream memoryStream = new System.IO.MemoryStream(_bytes))
                    {
                        Binary binary = Binary::constructFromMemoryStream(memoryStream);
                        bytesAsContainer = binary.getContainer();
                    }

                }
                catch (Exception::CLRError)
                {
                    DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:ByteArrayToContainerConversionFailed", true);
                }
                catch
                {
                    DocGlobalHelper::handleError("@DocentricAX5:ByteArrayToContainerConversionFailed", true, funcName(), true);
                }
    
                return bytesAsContainer;
            }
        }
    
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertBytesToMemoryStream</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified byte array into a memory stream.
    /// </summary>
    /// <param name = "_bytes">Btyte array</param>
    /// <returns>Memory stream</returns>
    public static System.IO.MemoryStream convertBytesToMemoryStream(System.Byte[] _bytes)
    {
        System.IO.MemoryStream  memoryStream;
    
        void cleanUp()
        {
            if (memoryStream != null)
            {
                memoryStream.Close();
                memoryStream.Dispose();
            }
        }
    
        if (_bytes != null)
        {
            int  byteCount = _bytes.get_Length();
            if (byteCount > 0)
            {
                try
                {
                    memoryStream = new System.IO.MemoryStream(_bytes);
                    if (memoryStream == null)
                    {
                        throw Exception::Error;
                    }
                    memoryStream.Position = 0;
                }
                catch (Exception::CLRError)
                {
                    cleanUp();
                    DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:ByteArrayToMemoryStreamConversionFailed", true);
                }
                catch
                {
                    cleanUp();
                    DocGlobalHelper::handleError("@DocentricAX5:ByteArrayToMemoryStreamConversionFailed", true, funcName(), true);
                }
    
                return memoryStream;
            }
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertContainerToBytes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified container to a byte array.
    /// </summary>
    /// <param name = "_container">Container which contains a blob</param>
    /// <returns>Byte array</returns>
    public static System.Byte[] convertContainerToBytes(container _container)
    {
        System.Byte[] bytes;
    
        if (_container != conNull())
        {
            try
            {
                Binary binary = Binary::constructFromContainer(_container);
                using (System.IO.MemoryStream memoryStream = binary.getMemoryStream())
                {
                    bytes = memoryStream.ToArray();
                }
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:ContainerToByteArrayConversionFailed", true);
            }
            catch
            {
                DocGlobalHelper::handleError("@DocentricAX5:ContainerToByteArrayConversionFailed", true, funcName(), true);
            }
    
            return bytes;
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertContainerToMemoryStream</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified container to a memory stream.
    /// </summary>
    /// <param name = "_container">Container which contains a blob</param>
    /// <returns>Memory stream</returns>
    public static System.IO.MemoryStream convertContainerToMemoryStream(container _container)
    {
        System.IO.MemoryStream memoryStream;
    
        if (_container != conNull())
        {
            try
            {
                Binary binary = Binary::constructFromContainer(_container);
                memoryStream = binary.getMemoryStream();
                if (memoryStream == null)
                {
                    throw Exception::Error;
                }
                memoryStream.Position = 0;
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:ContainerToMemoryStreamConversionFailed");
            }
            catch (Exception::Internal)
            {
                DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:ContainerToMemoryStreamConversionFailed");
            }
    
            return memoryStream;
        }
    
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertMemoryStreamToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified memory stream to a container.
    /// </summary>
    /// <param name = "_memoryStream">Memory stream</param>
    /// <returns>Container which contains a blob</returns>
    public static container convertMemoryStreamToContainer(System.IO.MemoryStream _memoryStream)
    {
        container bytesAsContainer;

        if (_memoryStream != null && _memoryStream.Length > 0)
        {
            try
            {
                using (System.IO.MemoryStream copyMemoryStream = DocGlobalHelper::copyMemoryStream(_memoryStream))
                {
                    Binary binary = Binary::constructFromMemoryStream(copyMemoryStream);
                    bytesAsContainer = binary.getContainer();
                }
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrError(funcName(), "@DocentricAX5:MemoryStreamToContainerConversionFailed", true);
            }
            catch
            {
                DocGlobalHelper::handleError("@DocentricAX5:MemoryStreamToContainerConversionFailed", true, funcName(), true);
            }
    
            return bytesAsContainer;
        }
    
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyMemoryStream</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a copy of a specified memory stream.
    /// </summary>
    /// <param name = "_originalMemoryStream">Source memory stream</param>
    /// <returns>A copy of a source memory stream</returns>
    public static System.IO.MemoryStream copyMemoryStream(System.IO.MemoryStream _originalMemoryStream)
    {
        System.IO.MemoryStream copyMemoryStream;

        try
        {
            copyMemoryStream = new System.IO.MemoryStream(_originalMemoryStream.Length);
            _originalMemoryStream.Position = 0;
            _originalMemoryStream.CopyTo(copyMemoryStream);
            _originalMemoryStream.Position = 0;
        
            copyMemoryStream.Position = 0;
        }
        catch (Exception::CLRError)
        {
            if (copyMemoryStream != null)
            {
                copyMemoryStream.Close();
                copyMemoryStream.Dispose();
            }
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:MemoryStreamCopyingFailed");
        }

        return copyMemoryStream;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertFromBase64String</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified base64 encoded string to a byte array.
    /// </summary>
    /// <param name = "_base64String">Base64 encoded string</param>
    /// <returns>Byte array</returns>
    public static System.Byte[] convertFromBase64String(str _base64String)
    {
        System.Byte[] bytes;

        if (_base64String != '')
        {
            try
            {
                bytes = System.Convert::FromBase64String(_base64String);
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:Base64ToByteArrayConversionFailed");
            }
        }

        return bytes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertToBase64String</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a specified byte array to a base64 encoded string.
    /// </summary>
    /// <param name = "_bytes">Byte array</param>
    /// <returns>Base64 encoded string</returns>
    public static str convertToBase64String(System.Byte[] _bytes)
    {
        str base64String;

        if (_bytes != null)
        {
            try
            {
                base64String = System.Convert::ToBase64String(_bytes);
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:ByteArrayToBase64ConversionFailed");
            }
        }

        return base64String;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertBase64StringToText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the provided base64 encoded to decoded text.
    /// </summary>
    /// <param name = "_base64String">Base64 encoded string</param>
    /// <returns>Decoded text string</returns>
    public static str convertBase64StringToText (str _base64String)
    {
        str text;

        try
        {
            text = System.Text.Encoding::UTF8.getString(DocGlobalHelper::convertFromBase64String(_base64String));
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:Base64ToTextConversionFailed");
        }

        return text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertTextToBase64String</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the provided text to a base64 string.
    /// </summary>
    /// <param name = "_text">Plain text.</param>
    /// <returns>Encoded based64 string</returns>
    public static str convertTextToBase64String(str _text)
    {
        str base64String;

        try
        {
            base64String = DocGlobalHelper::convertToBase64String(System.Text.Encoding::UTF8.GetBytes(_text));
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:TextToBase64ConversionFailed");
        }

        return base64String;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeChecksum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates a checksum of a specified base64 encoded string.
    /// It is a wrapper around our .net method.
    /// </summary>
    /// <param name = "_value">Base64 encoded string for which the checksum is calculated</param>
    /// <param name = "_algorithm">DocChecksumAlgorithmAX enum with algorithm type (MD5, SHA1, SHA256 or SHA512)</param>
    /// <returns>String representing the calculated checksum</returns>
    public static str computeChecksum(str _value, DocChecksumAlgorithmAX _algorithm = DocChecksumAlgorithmAX::SHA1)
    {
        // It isn't possible to calculate the checksum of an empty string.
        if (_value == '')
        {
            return '';
        }

        // Skip new line and carriage return characters when calculating the checksum.
        str value = strRem(strRem(_value, '\r'), '\n');

        // Transform the AX enum into .net enum
        DocChecksumAlgorithm algorithm;
        switch (_algorithm)
        {
            case DocChecksumAlgorithmAX::MD5:
                algorithm = DocChecksumAlgorithm::MD5;
                break;
                
            case DocChecksumAlgorithmAX::SHA1:
                algorithm = DocChecksumAlgorithm::SHA1;
                break;
                
            case DocChecksumAlgorithmAX::SHA256:
                algorithm = DocChecksumAlgorithm::SHA256;
                break;
                
            case DocChecksumAlgorithmAX::SHA512:
                algorithm = DocChecksumAlgorithm::SHA512;
                break;

            default:
                algorithm = DocChecksumAlgorithm::SHA1;
        }

        // Calculate the checkusm
        var checksum = DocChecksumHelper::ComputeHash(value, algorithm);

        return any2Str(checksum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>escapeString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a specified input string with escaped characters.
    /// </summary>
    /// <param name = "_string">Input string</param>
    /// <param name = "_maxLenght">The lenght of the string to be escaped</param>
    /// <returns>Escaped input string</returns>
    public static str escapeString(str _string, int _maxLenght = 0)
    {
        str escapedString;
    
    
        if (_string == '')
        {
            return _string;
        }
    
        if (_maxLenght == 0)
        {
            escapedString = _string;
        }
        else
        {
            escapedString = subStr(_string, 1, _maxLenght);
        }
    
        escapedString = strReplace(escapedString, @'\', '_');
        escapedString = strReplace(escapedString, @'/', '_');
        escapedString = strReplace(escapedString, @'*', '_');
        escapedString = strReplace(escapedString, @'?', '_');
        escapedString = strReplace(escapedString, @'!', '_');
        escapedString = strReplace(escapedString, @'"', '_');
        escapedString = strReplace(escapedString, @"'", '_');
        escapedString = strReplace(escapedString, @'<', '_');
        escapedString = strReplace(escapedString, @'>', '_');
        escapedString = strReplace(escapedString, @'|', '_');
        escapedString = strReplace(escapedString, @'@', '_');
        escapedString = strReplace(escapedString, @'{', '_');
        escapedString = strReplace(escapedString, @'}', '_');
        escapedString = strReplace(escapedString, @'[', '_');
        escapedString = strReplace(escapedString, @']', '_');
        escapedString = strReplace(escapedString, @'(', '_');
        escapedString = strReplace(escapedString, @')', '_');
        escapedString = strReplace(escapedString, @'#', '_');
        escapedString = strReplace(escapedString, @'%', '_');
        escapedString = strReplace(escapedString, @'€', '_');
        escapedString = strReplace(escapedString, @'$', '_');
        escapedString = strReplace(escapedString, @'&', '_');
        escapedString = strReplace(escapedString, @'=', '_');
        escapedString = strReplace(escapedString, @'+', '_');
        escapedString = strReplace(escapedString, @'-', '_');
        escapedString = strReplace(escapedString, @':', '_');
        escapedString = strReplace(escapedString, @'.', '_');
        escapedString = strReplace(escapedString, @',', '_');
        escapedString = strReplace(escapedString, @';', '_');
        escapedString = strReplace(escapedString, @' ', '_');
    
        escapedString = strReplace(escapedString, @'Ž', '_');
        escapedString = strReplace(escapedString, @'ž', '_');
        escapedString = strReplace(escapedString, @'Č', '_');
        escapedString = strReplace(escapedString, @'č', '_');
        escapedString = strReplace(escapedString, @'Ć', '_');
        escapedString = strReplace(escapedString, @'ć', '_');
        escapedString = strReplace(escapedString, @'Š', '_');
        escapedString = strReplace(escapedString, @'š', '_');
        escapedString = strReplace(escapedString, @'Đ', '_');
        escapedString = strReplace(escapedString, @'đ', '_');
    
        return escapedString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAOSInstanceName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current AOS instance name.
    /// </summary>
    /// <returns>
    /// Current running AOS instance name (ex. SF:AOS1, Batch:BATCHAOS1, IIS:MVUKP41, Sync:AOS1).
    /// </returns>
    public static str getAOSInstanceName()
    {
        SysClientSessions    clientSessions;
        SysServerSessions    serverSessions;
        int                  serverId;
        str                  aosInstanceName = ''; 

        str instanceNameShort(str _instanceName)
        {
            container instanceTypes = ['Batch', 'Sync'];

            for (int i = 1; i <= conLen(instanceTypes); i++)
            {
                str type = conPeek(instanceTypes, i);

                if (strScan(_instanceName, type, 1, strLen(_instanceName)))
                {
                    return type;
                }
            }

            return _instanceName;
        }
    
        xSession currentSession = new xSession();
        SysDictClass dictClass = new SysDictClass(classnum(xSession));
    
        SkipAOSValidationPermission skipAos = new SkipAOSValidationPermission();
        ExecutePermission executePerm = new ExecutePermission();
    
        select firstonly ServerId from clientSessions where clientSessions.SessionId == sessionid();
        if (clientSessions)
        {
            serverId = clientSessions.ServerId;
        }
        else
        {
            if (dictClass.hasObjectMethod('serverId'))
            {
                executePerm.assert();
                serverId = dictClass.callObject('serverId', currentSession);
                CodeAccessPermission::revertAssert();
            }
        }
    
    
        skipAos.assert();
    
        serverSessions.skipAosValidation(true);
        select firstOnly serverSessions where serverSessions.ServerId == serverId;
        if (serverSessions)
        {
            aosInstanceName = serverSessions.aosId;

            if (!strFind(aosInstanceName, ':', 1, strLen(aosInstanceName)))
            {
                aosInstanceName = instanceNameShort(serverSessions.Instance_Name) + ':' + aosInstanceName;
            }
        }
    
        CodeAccessPermission::revertAssert();
    
        return aosInstanceName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getServerHostname</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the server hostname from the AOS instance name, without the origin prefix.
    /// </summary>
    /// <returns>Server hostname</returns>
    public static str getServerHostname()
    {
        System.String aosInstanceName = DocGlobalHelper::getAOSInstanceName();

        return aosInstanceName.Contains(':') ? aosInstanceName.Split(':').GetValue(1) : aosInstanceName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLcsEnvironmentId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the LCS Environment ID as written in the web.config file.
    /// </summary>
    /// <returns>LCS Environment ID</returns>
    public static str getLcsEnvironmentId()
    {
        return System.Configuration.ConfigurationManager::get_AppSettings().Get('LCS.EnvironmentId');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAppBuildNo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the application build number.
    /// </summary>
    /// <returns>Application build number</returns>
    public static str getAppBuildNo()
    {
        return ApplicationVersion::applBuildNo();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUserFormatLanguageId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date and number format language id of current user.
    /// </summary>
    /// <returns>The date and number format language id</returns>
    public static LanguageId getUserFormatLanguageId()
    {
        return SrsReportRunUtil::getFormatLanguageId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCultureInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates specific culture or culture from given culture name.
    /// </summary>
    /// <param name="_languageId">Language ID i.e. culture name.</param>
    /// <returns>Specific culture if exists, otherwise culture.</returns>
    public static System.Globalization.CultureInfo getCultureInfo(LanguageId _languageId = DocGlobalHelper::getUserFormatLanguageId())
    {
        System.Globalization.CultureInfo ci;
    
        System.String languageIdString = _languageId;
    
        SysInfologLevel currentInfoLogLevel = infolog.infologLevel();
        infolog.setInfoLogLevel(SysInfologLevel::None);
    
        try
        {
            // Try to create specific culture.
            ci = System.Globalization.CultureInfo::CreateSpecificCulture(languageIdString);
        }
        catch (Exception::CLRError)
        {
            // Failed to create specific culture.
            try
            {
                // Try to create culture info from languageId as a culture name.
                ci = new System.Globalization.CultureInfo(languageIdString);
            }
            catch (Exception::CLRError)
            {
                ci = null;
            }
            catch (Exception::Internal)
            {
                ci = null;
            }
        }
    
        infolog.setInfoLogLevel(currentInfoLogLevel);
    
        return ci;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCultureInfoStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the culture name for the specified language.
    /// </summary>
    /// <param name = "_languageId">Language ID i.e. culture name</param>
    /// <returns>The culture name if exists; otherwise empty string</returns>
    public static str getCultureInfoStr(LanguageId _languageId = DocGlobalHelper::getUserFormatLanguageId())
    {
        System.Globalization.CultureInfo ci = DocGlobalHelper::getCultureInfo(_languageId);
    
        if (ci != null)
        {
            return ci.get_Name();
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts anytype value to string using general format and culture info.
    /// </summary>
    /// <param name = "_value">The value to convert to string</param>
    /// <param name = "_cultureInfo">Culture info</param>
    /// <param name = "_applyTimeZone">Should apply selected timezone</param>
    /// <returns>Converted anytype value to string</returns>
    public static str formatData(anytype _value, System.Globalization.CultureInfo _cultureInfo, DocApplyTimeZone _applyTimeZone = DocApplyTimezone::None)
    {
        if (_cultureInfo)
        {
            switch (typeOf(_value))
            {
                case Types::Date:
                    System.DateTime d = _value;
                    
                    // Arabic callendar (UmAlQuraCalendar) does not support dates before 4/30/1900 (01/01/18 in Arabic calendar)
                    if (d < _cultureInfo.Calendar.MinSupportedDateTime)
                    {
                        d = _cultureInfo.Calendar.MinSupportedDateTime;
                    }
                    return d.ToString('d', _cultureInfo);
            
                case Types::UtcDateTime:
                    System.DateTime dt;
                    switch (_applyTimeZone)
                    {
                        case DocApplyTimeZone::None:
                            dt = _value;
                            break;
                        case DocApplyTimeZone::UserPreferredTimeZone:
                            dt = DateTimeUtil::applyTimeZoneOffset(_value, DateTimeUtil::getUserPreferredTimeZone());
                            break;
                        case  DocApplyTimeZone::CompanyTimeZone:
                            dt = DateTimeUtil::applyTimeZoneOffset(_value, DateTimeUtil::getCompanyTimeZone());
                            break;
                        case DocApplyTimeZone::ClientMachineTimeZone:
                            dt = DateTimeUtil::applyTimeZoneOffset(_value, DateTimeUtil::getClientMachineTimeZone());
                            break;
                        case DocApplyTimeZone::OriginatingTimeZone:
                            dt = DateTimeUtil::applyTimeZoneOffset(_value, DateTimeUtil::getOriginatingTimeZone(_value));
                            break;
                    }

                    // Arabic callendar (UmAlQuraCalendar) does not support dates before 4/30/1900 (01/01/18 in Arabic calendar)
                    if (dt < _cultureInfo.Calendar.MinSupportedDateTime)
                    {
                        dt = _cultureInfo.Calendar.MinSupportedDateTime;
                    }
                    return dt.ToString('g', _cultureInfo);
            
                case Types::Real:
                    System.Decimal r = _value;
                    return r.ToString('n', _cultureInfo);
            }
        }
        
        return strFmt('%1', _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDateValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date value form the specified query range.
    /// </summary>
    /// <param name = "_qbr">Query range</param>
    /// <returns>Date value from the specified query range</returns>
    public static date getDateValueFromQueryBuildRange(QueryBuildRange _qbr)
    {
        date qbrDateValue = dateNull();
        str valueToConvert = DocGlobalHelper::getInvariantStrValueFromQueryBuildRange(_qbr);
    
        if (!valueToConvert)
        {
            return qbrDateValue;
        }
    
        int posStart = 1 + strScan(valueToConvert, '\'', 1, strLen(valueToConvert));
        int number = strScan(valueToConvert, '\'', posStart, strLen(valueToConvert)) - posStart;
        valueToConvert = subStr(valueToConvert, posStart, number);
    
        if (!valueToConvert)
        {
            return qbrDateValue;
        }
    
        System.DateTime dateTimeValue;
        try
        {
            dateTimeValue = System.DateTime::Parse(valueToConvert, System.Globalization.CultureInfo::get_InvariantCulture());
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:QueryBuildRangeParseError", _qbr.toString()));
        }
        catch (Exception::Internal)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:QueryBuildRangeParseError", _qbr.toString()));
        }
    
        utcDateTime qbrUtcDateTimeValue = dateTimeValue;
        qbrDateValue = DateTimeUtil::date(qbrUtcDateTimeValue);
    
        return qbrDateValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnumValueAsInteger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the specified enum value as integer.
    /// </summary>
    /// <param name = "_enumValue">Enum value</param>
    /// <returns>Enum value as integer</returns>
    public static Integer getEnumValueAsInteger(anytype _enumValue)
    {
        int enumValueInt;
    
        if (typeOf(_enumValue) == Types::Enum)
        {
            enumValueInt = enum2int(_enumValue);
        }
        else if (typeOf(_enumValue) == Types::Integer)
        {
            enumValueInt = _enumValue;
        }
        else
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:ParameterNotEnumOrIntegerError", varStr(_enumValue), _enumValue));
        }
    
        return enumValueInt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInfoLogMessages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all concatenated messages from the infolog. Messages are
    /// deleted from the infolog if _deleteMsg flag is true.
    /// </summary>
    /// <param name = "_startLine">A start line number</param>
    /// <param name = "_multiLinePrefix">A string added at the beginning of each infolog message</param>
    /// <param name = "_deleteMsg">Should delete the messages from the infolog</param>
    /// <returns><c>SysInfoLogStr</c> with infolog messages.</returns>
    public static SysInfoLogStr getInfoLogMessages(int _startLine = 1, str _multiLinePrefix = '>> ', boolean _deleteMsg = false) 
    {
        SysInfoLogStr infologMessages = '';
        int infologLineCount = infologLine();

        for (Counter counter = _startLine; counter <= infologLineCount; counter++)
        {
            SysInfologMessageStruct infologMessageStruct = SysInfologMessageStruct::construct(infolog.text(counter));

            infologMessages += (infologLineCount > 1 ? _multiLinePrefix : '') + infologMessageStruct.message();

            if (counter < infologLineCount)
            {
                infologMessages += '\r\n';
            }
        }
        if (_deleteMsg)
        {
            infolog.cut(_startLine, infologLineCount);
        }
    
        return infologMessages;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInfoLogMessagesAndErrorCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the infolog messages and error code.
    /// </summary>
    /// <param name = "_startLine">A start line number</param>
    /// <returns>A container with error code and inflog messages</returns>
    public static container getInfoLogMessagesAndErrorCode(int _startLine = 1)
    {
        str errorCode, finalErrorMsg;
        
        int numOfLines = infologLine();
        container allInfologLines = infolog.copy(1, numOfLines);

        int processToLine = _startLine;
                
        for (int i = numOfLines; i >= processToLine; i--)
        {
            SysInfologMessageStruct infologMessageStruct = SysInfologMessageStruct::construct(infolog.text(i));
            str errorMsg = infologMessageStruct.message();
            if (errorMsg)
            {
                if (finalErrorMsg)
                {
                    finalErrorMsg = finalErrorMsg + '>> ' + errorMsg;
                }
                else
                {
                    finalErrorMsg = errorMsg;
                }
            }
            if (finalErrorMsg && i > processToLine && numOfLines > processToLine)
            {
                finalErrorMsg = finalErrorMsg + '\r\n';
            }

            container infoLogLine = conPeek(allInfologLines, i + 1);
            str infoLogErrorCode = conPeek(infologLine, 3);
            if (infoLogErrorCode != '' && errorCode == '')
            {
                errorCode = infoLogErrorCode;
            }
        }

        return [errorCode, finalErrorMsg];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIntValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the int value from a specified query build range.
    /// </summary>
    /// <param name = "_qbr">Query build range</param>
    /// <returns>Int value</returns>
    public static int getIntValueFromQueryBuildRange(QueryBuildRange _qbr)
    {    
        int qbrIntValue = 0;
        str valueToConvert = DocGlobalHelper::getInvariantStrValueFromQueryBuildRange(_qbr);
    
        if (!valueToConvert)
        {
            return qbrIntValue;
        }
    
        qbrIntValue = str2int(valueToConvert);
    
        return qbrIntValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInt64ValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the int64 value from a specified query build range.
    /// </summary>
    /// <param name = "_qbr">Query build range</param>
    /// <returns>Int64 value</returns>
    public static int64 getInt64ValueFromQueryBuildRange(QueryBuildRange _qbr)
    {
        int64 qbrInt64Value = 0;
        str valueToConvert = DocGlobalHelper::getInvariantStrValueFromQueryBuildRange(_qbr);
    
        if (!valueToConvert)
        {
            return qbrInt64Value;
        }
    
        qbrInt64Value = str2int64(valueToConvert);
    
        return qbrInt64Value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvariantStrValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the invariant string value from a specified query build range.
    /// </summary>
    /// <param name = "_qbr">Query build range</param>
    /// <returns>Invariant string value</returns>
    public static str getInvariantStrValueFromQueryBuildRange(QueryBuildRange _qbr)
    {
        str qbrInvariantStrValue = '';
    
        str qbrStrValue = _qbr.toString();
        int valuePos = strScan(qbrStrValue, '=', 1, strLen(qbrStrValue));
    
        if (strScan(qbrStrValue, '=', valuePos + 1, strLen(qbrStrValue)))
        {
            DocGlobalHelper::handleException(funcName(), "@DocentricAX5:WrongFormatError");
        }
    
        if (valuePos)
        {
            qbrInvariantStrValue = strLTrim(strRTrim(subStr(qbrStrValue, valuePos + 1, strLen(qbrStrValue))));
        }
    
        return qbrInvariantStrValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRealValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the real value from a specified query build range.
    /// </summary>
    /// <param name = "_qbr">Query build range</param>
    /// <returns>Real value</returns>
    public static real getRealValueFromQueryBuildRange(QueryBuildRange _qbr)
    {
        real qbrRealValue = 0;

        str valueToConvert = DocGlobalHelper::getInvariantStrValueFromQueryBuildRange(_qbr);
        if (!valueToConvert)
        {
            return qbrRealValue;
        }
    
        try
        {
            qbrRealValue = System.Decimal::Parse(valueToConvert, System.Globalization.CultureInfo::get_InvariantCulture());
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:QueryBuildRangeParseError", _qbr.toString()));
        }
    
        return qbrRealValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUtcDateTimeValueFromQueryBuildRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the UTC datetime value from a specified query build range.
    /// </summary>
    /// <param name = "_qbr">Query build range</param>
    /// <returns>UTC datetime value</returns>
    public static utcDateTime getUtcDateTimeValueFromQueryBuildRange(QueryBuildRange _qbr)
    {
        System.DateTime dateTimeValue;
    
        utcDateTime qbrUtcDateTimeValue = utcdatetimenull();
        str valueToConvert = DocGlobalHelper::getInvariantStrValueFromQueryBuildRange(_qbr);
    
        if (!valueToConvert)
        {
            return qbrUtcDateTimeValue;
        }
    
        int posStart = 1 + strScan(valueToConvert, '\'', 1, strLen(valueToConvert));
        int number = strScan(valueToConvert, '\'', posStart, strLen(valueToConvert)) - posStart;
        valueToConvert = subStr(valueToConvert, posStart, number);
    
        if (!valueToConvert)
        {
            return qbrUtcDateTimeValue;
        }
    
        try
        {
            dateTimeValue = System.DateTime::Parse(valueToConvert, System.Globalization.CultureInfo::get_InvariantCulture());
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:QueryBuildRangeParseError", _qbr.toString()));
        }
    
        qbrUtcDateTimeValue = dateTimeValue;
    
        return qbrUtcDateTimeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastClrExceptionMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the message string of the last common language runtime exception that was thrown.
    /// </summary>
    /// <returns>The message string of the last common language runtime exception that was thrown.</returns>
    public static str getLastClrExceptionMessage()
    {
        System.Exception exception = CLRInterop::getLastException();
        
        return DocGlobalHelper::getClrExceptionMessage(exception);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClrExceptionMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Concatenates all the messages from the provided system exception.
    /// </summary>
    /// <param name = "_ex">Exception</param>
    /// <param name = "_message">Error message</param>
    /// <returns>Concatenated error messages</returns>
    private static str getClrExceptionMessage(System.Exception _ex, str _message = '')
    {
        while (_ex != null)
        {
            // Check if the exception is of type TargetInvocationException
            if (_message == '' && _ex is System.Reflection.TargetInvocationException)
            {
                var innerException = _ex.get_InnerException();
                if (innerException ==  null)
                {
                    _message = _ex.get_Message();
                    break;
                }

                _ex = innerException;
                continue;
            }

            _message = (_message ? strFmt('%1\r\n', _message) : '') + _ex.get_Message();

            // Check if the exception is of type AggregateException
            if (_ex is System.AggregateException)
            {
                var agrEx = _ex as System.AggregateException;

                var exs = agrEx.get_InnerExceptions();
                if (exs != null && exs.Count > 0)
                {
                    var exsEnumerator = exs.GetEnumerator();
                    while (exsEnumerator.MoveNext())
                    {
                        _ex = exsEnumerator.Current;
                        _message = DocGlobalHelper::getClrExceptionMessage(_ex, _message);
                    }
                    _ex = null;
                }
            }
            else
            {
                _ex = _ex.get_InnerException();
            }
        }

        return _message;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastInfoLogMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last message from the infolog.
    /// </summary>
    /// <returns><c>SysInfoLogStr</c> with infolog message.</returns>
    public static SysInfoLogStr getLastInfoLogMessage()
    {
        SysInfologMessageStruct infologMessageStruct = SysInfologMessageStruct::construct(infolog.text(infologLine()));
        return infologMessageStruct.message();
    }

]]></Source>
			</Method>
			<Method>
				<Name>guid2strWithoutBraces</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a specified GUID without braces.
    /// </summary>
    /// <param name = "_guid">GUID</param>
    /// <returns>GUID without braces</returns>
    public static str guid2strWithoutBraces(guid _guid)
    {
        str strGuidWithBraces = guid2str(_guid);
    
        return subStr(strGuidWithBraces, 2, strLen(strGuidWithBraces) - 2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleClrError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a CLR error. If no CLR exception is specified, the last CLR exception is handled.
    /// </summary>
    /// <param name = "_errorSource">Error source</param>
    /// <param name = "_exceptionCustomMsg">Exception custom message</param>
    /// <param name = "_throw">Flag indicating whether the exception should be thrown</param>
    /// <param name = "_showPrefix">Flag indicating whether the prefix should be shown</param>
    /// <param name = "_ex">CLR exception</param>
    public static void handleClrError(
        str _errorSource = '',
        str _exceptionCustomMsg = '',
        boolean _throw = false,
        boolean _showPrefix = true,
        System.Exception _ex = null)
    {
        str exceptionMsg;
    
        if (_ex == null)
        {
            // Get the last CLR exception.
            exceptionMsg = DocGlobalHelper::getLastClrExceptionMessage();
        }
        else
        {
            exceptionMsg = DocGlobalHelper::getClrExceptionMessage(_ex);
        }
    
        if (_showPrefix && !_errorSource)
        {
            setPrefix(DocConstant::Docentric);
        }
        if (_showPrefix && _errorSource)
        {
            setPrefix(DocConstant::Docentric);
            setPrefix(_errorSource);
        }
    
        if (_exceptionCustomMsg)
        {
            if (exceptionMsg)
            {
                error(exceptionMsg);
            }
            error(_exceptionCustomMsg);
        }
        else
        {
            if (exceptionMsg)
            {
                error(exceptionMsg);
            }
        }

        if (_throw)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleClrException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a CLR exception. If no CLR exception is specified, the last CLR exception is handled.
    /// </summary>
    /// <param name = "_errorSource">Error source</param>
    /// <param name = "_exceptionCustomMsg">Exception custom message</param>
    /// <param name = "_exceptionType">Exception type</param>
    /// <param name = "_errorCode">Error code</param>
    /// <param name = "_ex">CLR exception</param>
    public static void handleClrException(
        str _errorSource = '',
        str _exceptionCustomMsg = '',
        Exception _exceptionType = Exception::Error,
        str _errorCode = '',
        System.Exception _ex = null)
    {
        str exceptionMsg;
    
        if (_ex == null)
        {
            // Get the last CLR exception.
            exceptionMsg = DocGlobalHelper::getLastClrExceptionMessage();
        }
        else
        {
            exceptionMsg = DocGlobalHelper::getClrExceptionMessage(_ex);
        }
    
        if (_exceptionType == Exception::Error)
        {
            setPrefix(DocConstant::Docentric);
            if (_errorSource)
            {
                setPrefix(_errorSource);
            }
            else
            {
                setPrefix(funcName());
            }
    
            if (_exceptionCustomMsg)
            {
                if (exceptionMsg)
                {
                    error(exceptionMsg);
                }

                if (_errorCode == '')
                {
                    throw error(_exceptionCustomMsg);
                }
                else
                {
                    throw error(_exceptionCustomMsg, _errorCode);
                }
            }
            else
            {
                if (exceptionMsg)
                {
                    if (_errorCode == '')
                    {
                        throw error(exceptionMsg);
                    }
                    else
                    {
                        throw error(exceptionMsg, _errorCode);
                    }
                }
                else
                {
                    throw Exception::Error;
                }
            }
        }
    
        switch (_exceptionType)
        {
            case Exception::Warning:
                if (exceptionMsg || _exceptionCustomMsg)
                {
                    setPrefix(DocConstant::Docentric);
                    if (_errorSource)
                    {
                        setPrefix(_errorSource);
                    }
                    if (exceptionMsg)
                    {
                        warning(exceptionMsg);
                    }
                    if (_exceptionCustomMsg)
                    {
                        warning(_exceptionCustomMsg);
                    }
                }
                break;
    
            case Exception::Info:
                if (exceptionMsg || _exceptionCustomMsg)
                {
                    setPrefix(DocConstant::Docentric);
                    if (exceptionMsg)
                    {
                        info(exceptionMsg);
                    }
                    if (_exceptionCustomMsg)
                    {
                        info(_exceptionCustomMsg);
                    }
                }
                break;
    
            default:
                setPrefix(DocConstant::Docentric);
                error("@DocentricAX5:UnexpectedExceptionTypeError");
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles an error.
    /// </summary>
    /// <param name = "_errorMsg">Error message</param>
    /// <param name = "_showPrefix">Flag indicating whether the prefix should be shown</param>
    /// <param name = "_errorSource">Error source</param>
    /// <param name = "_throw">Flag indicating whether the exception should be thrown</param>
    /// <param name = "_errorCode">Error code</param>
    public static void handleError(
        str _errorMsg,
        boolean _showPrefix = true,
        str _errorSource  = '',
        boolean _throw = false,
        str _errorCode = '')
    {
        if (_showPrefix && !_errorSource)
        {
            setPrefix(DocConstant::Docentric);
        }
        if (_showPrefix && _errorSource)
        {
            setPrefix(DocConstant::Docentric);
            setPrefix(_errorSource);
        }
    
        if (_throw)
        {
            if (_errorCode == '')
            {
                throw error(_errorMsg);
            }
            else
            {
                throw error(_errorMsg, _errorCode);
            }
        }
        else
        {
            if (_errorCode == '')
            {
                error(_errorMsg);
            }
            else
            {
                error(_errorMsg, _errorCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleException</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles an exception. 
    /// </summary>
    /// <param name = "_errorSource">Error source</param>
    /// <param name = "_exceptionMsg">Exception message</param>
    /// <param name = "_errorCode">Error code</param>
    public static void handleException(str _errorSource  = '', str _exceptionMsg = 'Error occurred', str _errorCode = '')
    {
        setPrefix(DocConstant::Docentric);
        if (_errorSource)
        {
            setPrefix(_errorSource);
        }
        else
        {
            setPrefix(funcName());
        }
    
        if (_errorCode == '')
        {
            throw error(_exceptionMsg);
        }
        else
        {
            throw error(_exceptionMsg, _errorCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles an info.
    /// </summary>
    /// <param name = "_infoMsg">Info message</param>
    /// <param name = "_showPrefix">Flag indicating whether the prefix should be shown</param>
    /// <param name = "_infoSource">Info source</param>
    public static void handleInfo(str _infoMsg, boolean _showPrefix = true, str _infoSource  = '')
    {
        if (_showPrefix && !_infoSource)
        {
            setPrefix(DocConstant::Docentric);
        }
        if (_showPrefix && _infoSource)
        {
            setPrefix(DocConstant::Docentric);
            setPrefix(_infoSource);
        }
    
        info(_infoMsg);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleWarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles a warning.
    /// </summary>
    /// <param name = "_warningMsg">Warning message</param>
    /// <param name = "_showPrefix">Flag indicating whether the prefix should be shown</param>
    /// <param name = "_warningSource">Warning source</param>
    /// <param name = "_throw">Flag indicating whether a warning should be thrown as an exception</param>
    public static void handleWarning(str _warningMsg, boolean _showPrefix = true, str _warningSource  = '', boolean _throw = false)
    {
        if (_showPrefix && !_warningSource)
        {
            setPrefix(DocConstant::Docentric);
        }
        if (_showPrefix && _warningSource)
        {
            setPrefix(DocConstant::Docentric);
            setPrefix(_warningSource);
        }
    
        if (_throw)
        {
            throw warning(_warningMsg);
        }
        else
        {
            warning(_warningMsg);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles an assert.
    /// </summary>
    /// <param name = "_condition">Assert condition</param>
    /// <param name = "_msg">Assert message</param>
    public static void assert(boolean _condition, str _msg = '')
    {
        if (_condition)
        {
            return;
        }

        _msg += (_msg ? '\n' : '') + 'Assertion failed. Stack trace:\n' + DocGlobalHelper::stackTrace();

        DocGlobalHelper::handleError(_msg, true, '', true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>stackTrace</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a stack trace as a string.
    /// </summary>
    /// <returns>Stack trace as a string</returns>
    static str stackTrace()
    {
        container   stackCon = xSession::xppCallStack();
        str         ret = '';

        for (int i = 3; i < conLen(stackCon); i += 2)
        {
            str method = conPeek(stackCon, i);
            str line = conPeek(stackCon, i+1);
            
            // skip the assert method itself
            if (strScan(method, classStr(DocGlobalHelper), 1, strLen(method)) &&
                (strScan(method, staticMethodStr(DocGlobalHelper, stackTrace), 1, strLen(method)) ||
                 strScan(method, staticMethodStr(DocGlobalHelper, assert), 1, strLen(method))) )
            {
                continue;
            }
                
            ret += strFmt('%1  %2:%3', (ret ? '\n' : ''), method, line);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEnumBoolean</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a flag indicating whether a specified enum represent a boolean value.
    /// </summary>
    /// <param name = "_enumId">Enum Id</param>
    /// <returns>True if the specified enum represents a boolean value; otherwise false</returns>
    public static boolean isEnumBoolean(int _enumId)
    {
        if (_enumId)
        {
            if (enumNum(boolean) == _enumId ||
                enumNum(NoYes) == _enumId ||
                enumNum(NoYesBlank) == _enumId ||
                enumNum(NoYesCombo) == _enumId)
            {
                return true;
            }
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUrlCandidate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given string starts with 'http://' or 'https://'.
    /// </summary>
    /// <param name="_urlCandidate">URL candidate.</param>
    /// <returns>True if the given string represents an URL candidate.</returns>
    public static boolean isUrlCandidate(str _urlCandidate)
    {
        const str HttpScheme = 'http://';
        const str HttpsScheme = 'https://';
    
        if (strStartsWith(_urlCandidate, HttpScheme) || strStartsWith(_urlCandidate, HttpsScheme))
        {
            return true;
        }
    
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveXmlToMemoryStream</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the given XML document to a memory stream.
    /// </summary>
    /// <param name="_xmlDocumentStr">XML document to be saved to a memory stream.</param>
    /// <returns>Memory stream with the given XML document as bytes.</returns>
    public static System.IO.MemoryStream saveXmlToMemoryStream(str _xmlDocumentStr)
    {
        System.Xml.XmlDocument xmlDoc;
        System.IO.MemoryStream xmlMemoryStream;
    
    
        if (!_xmlDocumentStr)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:ParameterEmptyStringError", varStr(_xmlDocumentStr)));
        }
    
        System.String xmlDocString = _xmlDocumentStr;
    
        try
        {
            xmlDoc = new System.Xml.XmlDocument();
            xmlDoc.LoadXml(xmlDocString);
        }
        catch (Exception::CLRError)
        {
            CodeAccessPermission::revertAssert();
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:FailedToLoadXMLDocumentFromStringError", _xmlDocumentStr));
        }
        catch
        {
            CodeAccessPermission::revertAssert();
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:FailedToLoadXMLDocumentFromStringError", _xmlDocumentStr));
        }
    
        try
        {
            xmlMemoryStream = new System.IO.MemoryStream();
            xmlDoc.Save(xmlMemoryStream);
        }
        catch (Exception::CLRError)
        {
            CodeAccessPermission::revertAssert();
            DocGlobalHelper::handleClrException(funcName(), "@DocentricAX5:SavingXMLDocumentError");
        }
        catch
        {
            CodeAccessPermission::revertAssert();
            DocGlobalHelper::handleException(funcName(), "@DocentricAX5:SavingXMLDocumentError");
        }
    
        return xmlMemoryStream;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveXmlToContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the given XML document to a container.
    /// </summary>
    /// <param name="_xmlDocumentStr">XML document to be saved to a container.</param>
    /// <returns>Container with the given XML document (bytes).</returns>
    public static container saveXmlToContainer(str _xmlDocumentStr)
    {
        container xmlDocContainer;
        
        using (System.IO.MemoryStream xmlMemoryStream = DocGlobalHelper::saveXmlToMemoryStream(_xmlDocumentStr))
        {
            xmlDocContainer = DocGlobalHelper::convertBytesToContainer(xmlMemoryStream.ToArray());
        }

        return xmlDocContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysDictEnum_value2Index</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the index of the specified enum value.
    /// </summary>
    /// <param name = "_enumId">Enum Id</param>
    /// <param name = "_enumValueInt">Enum value</param>
    /// <returns>Index of the specified enum value</returns>
    public static int sysDictEnum_value2Index(EnumId _enumId, int _enumValueInt)
    {
        SysDictEnum sysDictEnum = new SysDictEnum(_enumId);
        Counter enumChoices = sysDictEnum.values();
        Counter idx;
    
        for (idx = 0; idx < enumChoices; idx++)
        {
            if (sysDictEnum.index2Symbol(idx) == sysDictEnum.value2Symbol(_enumValueInt))
            {
                return idx;
            }
        }
    
        return _enumValueInt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns list of email addresses. 
    /// Email addresses are trimmed, empty email addresses are omitted.
    /// </summary>
    /// <param name = "_emailList">Email addresses separated by specified delimiters.</param>
    /// <param name = "_delimiters">A string of delimiter characters.</param>
    /// <returns>List of email addresses</returns>
    public static List getEmailList(str _emailList, str _delimiters = ',;')
    {
        return DocGlobalHelper::strSplit(_emailList, _delimiters, DocStringSplitOptions::TrimEntries | DocStringSplitOptions::RemoveEmptyEntries);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEmail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the given email address.
    /// </summary>
    /// <param name="_emailAddress">Single email address to validate.</param>
    /// <param name="_useExtendedEmailAddressFilter">Flag indicating whether the extended email address filter should be used for email validation</param>
    /// <returns>True if the provided email address is valid; otherwise false.</returns>
    public static boolean validateEmail(str _emailAddress, boolean _useExtendedEmailAddressFilter = false)
    {
        /* This regex validates the following structure for an email address:
        a. Contains a '@' character
        b. Contains a period after '@'
        c. Has only one @ and at least one character before the @, before the period and after it
        */
        str emailAddressFilter = @"^[^@]+@[^@]+\.[^@]+$";
        if (_useExtendedEmailAddressFilter)
        {
            emailAddressFilter = @"^[\w]+([.-]?[\w]+)*@[\w]+([.-]?[\w]+)*\.[\w]+$";
        }

        if (!_emailAddress)
        {
            return false;
        }

        // Check if the input parameter is an email list or a single email.
        if (strFind(_emailAddress, ',;', 1, strLen(_emailAddress)))
        {
            return false;
        }

        System.Text.RegularExpressions.Regex regEx = new System.Text.RegularExpressions.Regex(emailAddressFilter);
        System.Text.RegularExpressions.Match regMatch = regEx.Match(_emailAddress);

        boolean isEmailValid = regMatch.get_Success();

        return isEmailValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEmailList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates given email addresses separated by commas or semicolons.
    /// </summary>
    /// <param name="_emailList">Email addresses to validate.</param>
    /// <param name="_useExtendedEmailAddressFilter">Flag indicating whether the extended email address filter should be used for email validation</param>
    /// <returns>True if all email addresses are valid; otherwise false.</returns>
    public static boolean validateEmailList(str _emailList, boolean _useExtendedEmailAddressFilter = false)
    {
        // If the email list is not provided, return false.
        if (!_emailList)
        {
            return false;
        }

        // Split the email address string and validate each email address
        List emailAddresses = DocGlobalHelper::getEmailList(_emailList);

        ListEnumerator enum = emailAddresses.getEnumerator();
        while (enum.moveNext())
        {
            str email = strLRTrim(enum.current());

            if (!email)
            {
                continue;
            }
            
            // If a single email address is invalid, then the whole email list is invalid.
            if (!DocGlobalHelper::validateEmail(email, _useExtendedEmailAddressFilter))
            {
                return false;
            }
        }
    
        // All email addresses in the provided email list are valid -> return true.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEmailListSkipPlaceholders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates given email addresses separated by commas or semicolons, but skips placeholders and email tokens.
    /// </summary>
    /// <param name="_emailList">Email addresses to validate.</param>
    /// <param name="_useExtendedEmailAddressFilter">Flag indicating whether the extended email address filter should be used for email validation</param>
    /// <returns>True if all email addresses, which are not placeholders or email tokens, are valid; otherwise false.</returns>
    public static boolean validateEmailListSkipPlaceholders(str _emailList, boolean _useExtendedEmailAddressFilter = false)
    {
        // If the email list is not provided, return false.
        if (!_emailList)
        {
            return false;
        }

        // Split the email address string and validate each email address
        List emailAddresses = DocGlobalHelper::getEmailList(_emailList);
    
        ListEnumerator enum = emailAddresses.getEnumerator();
        while (enum.moveNext())
        {
            str email = strLRTrim(enum.current());

            if (!email)
            {
                continue;
            }

            // If the first and last character is equal to '@', then the email address is a placeholder or email token, so skip it.
            if ((strCmp(subStr(email, 1, 1), DocConstantPlaceholder::PlaceholderStartSymbol) == 0) && 
                 strCmp(subStr(email, strLen(email), 1), DocConstantPlaceholder::PlaceholderEndSymbol) == 0)
            {
                continue;
            }

            // If a single email address is invalid, then the whole email list is invalid.
            if (!DocGlobalHelper::validateEmail(email, _useExtendedEmailAddressFilter))
            {
                return false;
            }
        }
    
        // All email addresses in the provided email list are valid -> return true.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateURL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a URL is valid.
    /// </summary>
    /// <param name="_url">The URL to validate.</param>
    /// <returns>True if the URL is valid; otherwise false.</returns>
    public static boolean validateURL(URL _url)
    {
        System.Uri      resultUri;
        str             resultUriStr;
        boolean         isValidUri, isValidHttpUri;
    
        #define.HttpScheme('http://')
        #define.HttpsScheme('https://')
    
        isValidUri = System.Uri::TryCreate(_url, System.UriKind::Absolute, byRef resultUri);
    
        isValidHttpUri = false;
        if (isValidUri)
        {
            resultUriStr = resultUri.ToString();
            if (strStartsWith(resultUriStr, #HttpScheme) || strStartsWith(resultUriStr, #HttpsScheme))
            {
                isValidHttpUri = true;
            }
        }
    
        return isValidHttpUri;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUrlToOpenInBrowser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends the parameter to the given url to open it in the web app.
    /// </summary>
    /// <param name = "_fileUrl">File url</param>
    /// <returns>URL to open in web app</returns>
    public static str getUrlToOpenInBrowser(str _fileUrl)
    {
        str url = _fileUrl;

        if (url && !strEndsWith(url, '?web=1') && strScan(url, '?', 1, strLen(url)) == 0)
        {
            // Append the parameter to open in the web app.
            url = url + '?web=1';
        }

        return url;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeToExceptionLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Write provided message to the Exception log.
    /// </summary>
    /// <param name="_msg">Message text.</param>
    /// <param name="_msgType">Exception::Error, Exception::Warning or Exception::Info</param>
    public static void writeToExceptionLog(SysInfoLogStr _msg, Exception _msgType = Exception::Error)
    {
        if (!_msg)
        {
            return;
        }
    
        switch (_msgType)
        {
            case Exception::Info:
            case Exception::Warning:
            case Exception::Error:
                break;
    
            default:
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:UnsupportedExceptionTypeError", _msgType));
        }
    
        // Write to the exceptions log.
        SysExceptionLog exceptionLog = new SysExceptionLog();
        exceptionlog.writeEntry(_msgType, _msg, DocConstant::DocentricModule);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocentricAxVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the version from Docentric.AX.dll.
    /// </summary>
    /// <returns>Version (Major.Minor.Build.Revision)</returns>
    public static str getDocentricAxVersion()
    {
        return Docentric.AX.Licensing.DocAxLicenseManager::ProductVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocentricAxModelVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the version from Docentric AX model.
    /// </summary>
    /// <returns>Version (Major.Minor.Build.Revision) or blank if not found</returns>
    public static str getDocentricAxModelVersion()
    {
        var moduleModels = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetModelsInModuleSortedByDisplayName(identifierStr(DocentricAX));
        var modelEnumerator = moduleModels.GetEnumerator();
        while (modelEnumerator.MoveNext())
        {
            Microsoft.Dynamics.AX.Metadata.MetaModel.ModelInfo modelInfo = modelEnumerator.get_Current();

            if (modelInfo.Name == DocConstant::DocentricAXModelName)
            {
                return strfmt('%1.%2.%3.%4', modelInfo.VersionMajor, modelInfo.VersionMinor, modelInfo.VersionBuild, modelInfo.VersionRevision);
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocentricAxReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Docentric AX product release date.
    /// </summary>
    /// <returns>The Docentric AX product release date</returns>
    public static date getDocentricAxReleaseDate()
    {
        return Docentric.AX.Licensing.DocAxLicenseManager::ProductReleaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRunningOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the code is executing on server.
    /// </summary>
    /// <returns>True if the code is executing on server; otherwise false</returns>
    public static boolean isRunningOnServer()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>scrubXmlFragment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes any invalid or hidden characters that may be present at the start of an XML element. 
    /// This can occur during the XML serialization of an object.
    /// </summary>
    /// <param name="xml">A string representation of the XML element.</param>
    /// <returns>The XML with any leading spaces or hidden characters removed.</returns>
    public static str scrubXmlFragment(str xml)
    {
        str xmlDeclaration = '<?xml';
        int charIndex;

        charIndex = strScan(xml, xmlDeclaration, 1, strLen(xml));

        if (charIndex > 0 )
        {
            xml = subStr(xml, charIndex, strLen(xml));
        }

        return xml;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleAsciiControlCharactersInString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles ASCII control characters from the string, which are not supported by XML v. 1.0, according to the ASCII control characters mode set.
    /// These are the ASCII characters [0 - 31], excluding 9 (horizontal tab), 10 (line feed) and 13 (carriage return).
    /// </summary>
    /// <param name = "_string">The string to sanitize.</param>
    /// <param name = "_asciiControlCharactersHandlingMode">The selected ASCII control characters handling mode.</param>
    /// <returns>Sanitized string without problematic ASCII control characters or the original string if the ASCII control characters handling mode is set to "No action".</returns>
    public static System.String handleAsciiControlCharactersInString (System.String _string, DocAsciiControlCharactersHandling _asciiControlCharactersHandlingMode)
    {
        if (_asciiControlCharactersHandlingMode == DocAsciiControlCharactersHandling::NoAction)
        {
            // If the ASCII control characters handling mode is set to no action, then just return the original string.
            // This should not occur, as it is better to not call this method at all if that is the case.
            return _string;
        }

        System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();
        System.CharEnumerator charEnumerator = _string.GetEnumerator();

        switch (_asciiControlCharactersHandlingMode)
        {
            case DocAsciiControlCharactersHandling::Removing:
            case DocAsciiControlCharactersHandling::Escaping:
                while (charEnumerator.MoveNext())
                {
                    System.Char c = charEnumerator.Current;

                    // Add only valid XML v. 1.0 characters to the return string.
                    if (c >= 32 || c == 9 || c == 10 || c == 13)
                    {
                        stringBuilder.Append(c);
                    }

                    // Add a replacement character if "Escaping" handling mode is enabled.
                    else if (_asciiControlCharactersHandlingMode == DocAsciiControlCharactersHandling::Escaping)
                    {
                        stringBuilder.Append('\u2610');
                    }
                }
                break;
        }
        
        return stringBuilder.ToString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonInteractiveSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the current session is a non-interactive session.
    /// </summary>
    /// <returns>True if the current session is non-interactive; otherwise false</returns>
    public static boolean isNonInteractiveSession()
    {
        return isRunningOnBatch() || !xGlobal::hasClient();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRunningInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the flag indicating whether the current session is running within a batch context.
    /// </summary>
    /// <returns>True if the execution is under a batch job; otherwise false</returns>
    public static boolean isRunningInBatch()
    {
        return Global::isRunningOnBatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentBatchTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current batch task.
    /// </summary>
    /// <returns>Current batch task</returns>
    public static Batch getCurrentBatchTask()
    {
        Batch batch;
        xSession session = new xSession();

        select firstonly batch 
            where batch.SessionIdx == session.sessionId()
               && batch.SessionLoginDateTime == session.loginDateTime() 
               && batch.Status == BatchStatus::Executing;

        return batch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStackTrace</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the stack trace.
    /// </summary>
    /// <returns>Stack trace as string</returns>
    public static str getStackTrace()
    {
        str stackTrace = System.Environment::StackTrace;
        return stackTrace;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the external ID for a user.
    /// </summary>
    /// <param name = "_userId">The Id of the user. If not specifed, the current user is used.</param>
    /// <returns>The current user's external ID</returns>
    public static str getExternalId(UserId _userId = curUserId())
    {
        UserInfo userInfo;

        select firstonly externalId from userInfo where userInfo.id == _userId;

        return userInfo.externalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentUserExternalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the external id of the current user.
    /// </summary>
    /// <returns>The current user's external id</returns>
    public static str getCurrentUserExternalId()
    {
        return DocGlobalHelper::getExternalId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUsersForRole</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of users associated with the specified security role.
    /// </summary>
    /// <param name = "_securityRoleAOTName">A security role</param>
    /// <returns>A comma-separated list of users</returns>
    public static str getUsersForRole(str _securityRoleAOTName)
    {
        UserInfo userInfo;
        SecurityRole securityRole;
        SecurityUserRole securityUserRole;

        str users = '';

        while select id
            from userInfo
                where userInfo.enable == NoYes::Yes
            exists join securityUserRole
                where securityUserRole.User == userInfo.id
                   && securityUserRole.AssignmentStatus == RoleAssignmentStatus::Enabled
                   && (securityUserRole.ValidFrom < DateTimeUtil::utcNow() || securityUserRole.ValidFrom == utcDateTimeNull())
                   && (securityUserRole.ValidTo > DateTimeUtil::utcNow() || securityUserRole.ValidTo == utcDateTimeNull())
            exists join securityRole
                where securityRole.RecId == securityUserRole.SecurityRole
                    && securityRole.AOTName == _securityRoleAOTName
        {
            // Concatenate the users
            users += (users ? ', ' : '') + userInfo.Id;
        }

        return users;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertStr2UtcDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the UTC datetime string to UTC datetime.
    /// </summary>
    /// <param name = "_utcDateTimeStr">UTC datetime string</param>
    /// <param name = "_languageId">Language Id</param>
    /// <returns>UTC datetime</returns>
    public static utcdatetime convertStr2UtcDateTime(str _utcDateTimeStr, LanguageId _languageId = DocGlobalHelper::getUserFormatLanguageId())
    {
        utcdatetime utcDateTimeValue;

        try
        {
            utcDateTimeValue = System.DateTime::Parse(_utcDateTimeStr, DocGlobalHelper::getCultureInfo(_languageId));
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), strFmt("@DocentricAX5:StringToUTCDateTimeConversionError", _utcDateTimeStr, _languageId));
        }

        return utcDateTimeValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertStr2Date</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the date string to date.
    /// </summary>
    /// <param name = "_dateStr">Date string</param>
    /// <param name = "_languageId">Language Id</param>
    /// <returns>Date</returns>
    public static date convertStr2Date(str _dateStr, LanguageId _languageId = DocGlobalHelper::getUserFormatLanguageId())
    {
        utcdatetime utcDateTimeValue = DocGlobalHelper::convertStr2UtcDateTime(_dateStr, _languageId);
        date dateValue = DateTimeUtil::date(utcDateTimeValue);
        return dateValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertDate2Str</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the date to date string.
    /// </summary>
    /// <param name = "_date">Date</param>
    /// <param name = "_languageId">Language Id</param>
    /// <returns>Date string</returns>
    public static str convertDate2Str(date _date, LanguageId _languageId = DocGlobalHelper::getUserFormatLanguageId())
    {
        System.DateTime dateTime = new System.DateTime(year(_date), mthOfYr(_date), dayOfMth(_date));
        str strDate = dateTime.ToString(DocGlobalHelper::getCultureInfo(_languageId).DateTimeFormat.ShortDatePattern);
        return strDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentUsersCurrentDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get current users' current date
    /// </summary>
    /// <returns>The current users' current date</returns>
    public static date getCurrentUsersCurrentDate()
    {
        return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSSRSScreenPrintDestinationVisible</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets information if SSRS screen print destination is visible.
    /// It happens under the following conditions:
    ///     1. Prior to D365FO version 10.0.3 PU27, SSRS screen print destination
    ///        was visible only on cloud environments.
    ///     2. With version 10.0.3, Microsoft introduced a new embedded PDF viewer,
    ///        which can be enabled or disabled. SSRS screen print destination
    ///        is still visible on cloud environments, while on on-premise environments
    ///        is visible if the PDF viewer is enabled.
    /// </summary>
    /// <returns>true if SSRS screen print destination should visible</returns>
    public static boolean isSSRSScreenPrintDestinationVisible()
    {
        boolean isVisible;

        SysDictClass dictClass = new SysDictClass(classNum(SrsReportRunUtil));
        str methodName = 'useReportPdfViewer';
        if (dictClass.hasStaticMethod(methodName))
        {
            // D365FO ver 10.0.3 PU27 and above.
            // Method SrsReportRunUtil::useReportPdfViewer() was introduced with this version,
            // so we will invoke it via reflection (in order to compile on lower D365FO versions).
            boolean useReportPdfViewer = dictClass.callStatic(methodName);
            isVisible = !DocConstantGlobal::isOnPremEnvironment() || useReportPdfViewer;
        }
        else
        {
            isVisible = !DocConstantGlobal::isOnPremEnvironment();
        }
        
        return isVisible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>conRemove</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes element from container.
    /// </summary>
    /// <param name = "_con">A container</param>
    /// <param name = "_element">An element to remove</param>
    /// <returns>Container without deleted element or original container if element not found</returns>
    public static container conRemove(container _con, anytype _element)
    {
        int pos = conFind(_con, _element);

        if (pos)
        {
            return conDel(_con, pos, 1);
        }
        return _con;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countDataSourceMarkedRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the count of marked records in the specified form data source.
    /// </summary>
    /// <param name = "_ds">Form data source</param>
    /// <returns>Count of marked records</returns>
    public static int countDataSourceMarkedRecords(FormDataSource _ds)
    {
        int ret = 0;
        for (Common rec = _ds.getFirst(1); rec.RecId; rec = _ds.getNext())
        {
            ret++;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>iif</Name>
				<Source><![CDATA[
    /// <summary>
    /// Alternative for (c ? a : b) that works also if a and b are of different type
    /// </summary>
    /// <param name = "_condition">A condition</param>
    /// <param name = "_trueValue">A value to return if the condition is true</param>
    /// <param name = "_falseValue">A value to return if the condition is false</param>
    /// <returns>Returns _trueValue if _condition is true and _falseValue otherwise</returns>
    public static anytype iif(boolean _condition, anytype _trueValue, anytype _falseValue)
    {
        if (_condition)
        {
            return _trueValue;
        }
        return _falseValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDotNetEnumValueForXppEnumValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a .NET enum value for provided X++ enum value.
    /// </summary>
    /// <param name = "_dotNetEnumType">.NET enum type</param>
    /// <param name = "_xppEnumId">X++ enum Id</param>
    /// <param name = "_xppEnumVal">X++ enum value</param>
    /// <returns>.NET enum value</returns>
    public static System.Enum getDotNetEnumValueForXppEnumValue(System.Type _dotNetEnumType, EnumId _xppEnumId, int _xppEnumVal)
    {
        System.Enum dotNetEnum;
        try
        {
            dotNetEnum = Docentric.AX.Framework.Extensions.EnumExtensions::Parse(_dotNetEnumType, enum2Symbol(_xppEnumId, _xppEnumVal), true);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX5:UnsupportedEnumValueError", enum2Symbol(_xppEnumId, _xppEnumVal), enumId2Name(_xppEnumId)));
        }
        return dotNetEnum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isUserAdminOrDocentricAdmin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified user is D365FO administrator or Docentric AX admin.
    /// </summary>
    /// <param name = "_userId">User Id</param>
    /// <returns>True if the specified user is FO or Docentric admin; otherwise false</returns>
    public static boolean isUserAdminOrDocentricAdmin(UserId _userId = curUserId())
    {
        SecurityUserRole securityUserRole;
        SecurityRole securityRole;
 
        select firstOnly securityUserRole
            where securityUserRole.User == _userId
               && securityUserRole.AssignmentStatus == RoleAssignmentStatus::Enabled
               && (securityUserRole.ValidFrom < DateTimeUtil::utcNow() || securityUserRole.ValidFrom == utcDateTimeNull())
               && (securityUserRole.ValidTo > DateTimeUtil::utcNow() || securityUserRole.ValidTo == utcDateTimeNull())
        exists join securityRole
            where securityRole.RecId == securityUserRole.SecurityRole
               && securityRole.AotName == roleStr(DocentricAXAdmin);

        return securityUserRole.RecId || isSystemAdministrator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUserSecurityPrivilege</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified user has a specified privilege.
    /// </summary>
    /// <param name = "_securityPrivilege">Privilege name</param>
    /// <param name = "_userId">User Id</param>
    /// <returns>True if the specified user has a spceified privilege; otherwise false</returns>
    public static boolean hasUserSecurityPrivilege(SecurityPrivilegeName _securityPrivilege, UserId _userId = curUserId())
    {
        SecurityRolePrivilegeExplodedGraph securityRolePrivilegeExplodedGraph;
        SecurityUserRole securityUserRole;
        SecurityPrivilege securityPrivilege;

        select firstonly securityPrivilege
            where securityPrivilege.Identifier == _securityPrivilege
        exists join securityRolePrivilegeExplodedGraph
            where securityRolePrivilegeExplodedGraph.SecurityPrivilege == securityPrivilege.RecId
        exists join securityUserRole
            where securityUserRole.SecurityRole == securityRolePrivilegeExplodedGraph.SecurityRole
               && securityUserRole.User == _userId
               && securityUserRole.AssignmentStatus == RoleAssignmentStatus::Enabled
               && (securityUserRole.ValidFrom < DateTimeUtil::utcNow() || securityUserRole.ValidFrom == utcDateTimeNull())
               && (securityUserRole.ValidTo > DateTimeUtil::utcNow() || securityUserRole.ValidTo == utcDateTimeNull());

        return securityPrivilege.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasUserSecurityDuty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified user has a specified duty.
    /// </summary>
    /// <param name = "_securityDuty">Duty name</param>
    /// <param name = "_userId">User Id</param>
    /// <returns>True if the specified user has a spceified duty; otherwise false</returns>
    public static boolean hasUserSecurityDuty(SecurityDutyName _securityDuty, UserId _userId = curUserId())
    {
        SecurityRoleDutyExplodedGraph securityRoleDutyExplodedGraph;
        SecurityUserRole securityUserRole;
        SecurityDuty securityDuty;

        select firstonly securityDuty
            where securityDuty.Identifier == _securityDuty
        exists join securityRoleDutyExplodedGraph
            where securityRoleDutyExplodedGraph.SecurityDuty == securityDuty.RecId
        exists join securityUserRole
            where securityUserRole.SecurityRole == securityRoleDutyExplodedGraph.SecurityRole
               && securityUserRole.User == _userId
               && securityUserRole.AssignmentStatus == RoleAssignmentStatus::Enabled
               && (securityUserRole.ValidFrom < DateTimeUtil::utcNow() || securityUserRole.ValidFrom == utcDateTimeNull())
               && (securityUserRole.ValidTo > DateTimeUtil::utcNow() || securityUserRole.ValidTo == utcDateTimeNull());

        return securityDuty.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isModelInstalled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified model is installed.
    /// </summary>
    /// <param name = "_modelName">Name of the model</param>
    /// <returns>True if the model is installed; otherwise false</returns>
    public static boolean isModelInstalled(str _modelName)
    {
        IEnumerable moduleList = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetInstalledModuleNamesInSortedOrder();
        if (moduleList != null)
        {
            IEnumerator moduleListEnum = moduleList.GetEnumerator();
            while (moduleListEnum.MoveNext())
            {
                str moduleName = moduleListEnum.Current;
                IEnumerable moduleModelList = Microsoft.Dynamics.Ax.Xpp.MetadataSupport::GetModelsInModuleSortedByDisplayName(moduleName);
                if (moduleModelList != null)
                {
                    IEnumerator moduleModelListEnum = moduleModelList.GetEnumerator();
                    while (moduleModelListEnum.MoveNext())
                    {
                        Microsoft.Dynamics.AX.Metadata.MetaModel.ModelInfo modelInfo = moduleModelListEnum.Current;
                        if (modelInfo.Name == _modelName)
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the defined query criteria for specified query.
    /// </summary>
    /// <param name = "_query">Query object</param>
    /// <param name = "_excludeEmptyCriteria">Should be empty criteria excluded</param>
    /// <param name = "_excludeHiddenCriteria">Should be hidden criteria excluded</param>
    /// <param name = "_excludeQueryRanges">Should be query ranges excluded</param>
    /// <param name = "_excludeQueryFilters">Should be query filters excluded</param>
    /// <returns>Defined query criteria as string</returns>
    public static str getQueryCriteria(
        Query _query,
        boolean _excludeEmptyCriteria = false,
        boolean _excludeHiddenCriteria = false,
        boolean _excludeQueryRanges = false,
        boolean _excludeQueryFilters = false)
    {
        str retVal = '';

        if (_query == null)
        {
            return retVal;
        }

        // Check if query ranges should be excluded
        if (!_excludeQueryRanges)
        {
            // Get defined query ranges
            for (int dsNumber = 1; dsNumber <= _query.dataSourceCount(); dsNumber++)
            {
                QueryBuildDatasource qbds = _query.dataSourceNo(dsNumber);
                if (qbds.enabled())
                {
                    for (int rangeNumber = 1; rangeNumber <= qbds.rangeCount(); rangeNumber++)
                    {
                        QueryBuildRange qbr = qbds.range(rangeNumber);

                        // Skip the hidden ranges
                        if (!(_excludeHiddenCriteria && qbr.status() == RangeStatus::Hidden) && (!_excludeEmptyCriteria || (_excludeEmptyCriteria && qbr.value())))
                        {
                            retVal += (retVal == '' ? '' : ', \n');
                            retVal += strFmt('%1.%2: %3',
                                            tableId2Pname(qbds.table()),
                                            fieldId2Pname(qbds.table(), qbr.field()),
                                            qbr.value() == '' ? DocConstant::EmptyReportParameter : qbr.value());
                        }
                    }
                }
            }
        }

        // Check if query filters should be excluded
        if (!_excludeQueryFilters)
        {
            // Get defined query filters
            for (int qfNumber = 1; qfNumber <= _query.queryFilterCount(); qfNumber++)
            {
                QueryFilter qf = _query.queryFilter(qfNumber);

                if (!_excludeEmptyCriteria || (_excludeEmptyCriteria && qf.value()))
                {
                    retVal += (retVal == '' ? '' : ', \n');
                    retVal += strFmt('%1.%2: %3',
                                    tableId2Pname(qf.dataSource().table()),
                                    fieldId2Pname(qf.dataSource().table(), fieldName2Id(qf.dataSource().table(), qf.field())),
                                    qf.value() == '' ? DocConstant::EmptyReportParameter : qf.value());
                }
            }
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>strSplit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits a string into a list of substrings delimited by elements in the specified delimiter string.
    /// This is done using the specified string splitting options, which can be:
    /// - None - the default mode, which doesn't trim the substrings nor omit empty substrings from the resulting list
    /// - RemoveEmptyEntries - omit all substrings that contain an empty string from the resulting list
    /// - TrimEntries - trim white-space characters from each substring in the result
    /// If RemoveEmptyEntries and TrimEntries are specified together, then substrings that consist only of
    /// white-space characters are also removed from the result.
    /// </summary>
    /// <param name = "_stringToSplit">The string to split into a list.</param>
    /// <param name = "_delimiters">A string of delimiter characters.</param>
    /// <param name = "_stringSplitOptions">
    /// A bitwise combination of the DocStringSplitOptions enum values that specifies whether to trim
    /// substrings and include empty substrings.
    /// </param>
    /// <returns>A list of substrings from the _stringToSplit parameter.</returns>
    /// <remarks>
    /// Each character in the _delimiter string is used to split the _stringToSplit parameter.
    /// The code is modified version of Global::strSplit() method.
    /// </remarks>
    public static List strSplit(str _stringToSplit, str _delimiters, int _stringSplitOptions = DocStringSplitOptions::None)
    {
        List list = new List(Types::String);
        int oldPos = 1;
        int pos;
        int strLength = strLen(_stringToSplit);

        do
        {
            // Find next position of the delimiter in the string
            pos = strFind(_stringToSplit, _delimiters, oldPos, strLength);
            if (!pos)
            {
                pos = strLength + 1;
            }

            // Get a substring from the string
            str s = subStr(_stringToSplit, oldPos, pos-oldPos);

            // Trim a substring depending on the string splitting options
            if (_stringSplitOptions & DocStringSplitOptions::TrimEntries)
            {
                s = strLRTrim(s);
            }

            // Add a substring to the list depending on the string splitting options
            if (!(s == '' && (_stringSplitOptions & DocStringSplitOptions::RemoveEmptyEntries)))
            {
                // Add a substring to the list
                list.addEnd(s);
            }
            oldPos = pos+1;
        }
        while (pos <= strLength);

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLengthyOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays progress indicator window during execution of custom code.
    /// </summary>
    /// <param name = "_waitCaption">Caption to display on the waiting user interface</param>
    public static void startLengthyOperation(str _waitCaption = '')
    {
        SysOperationSandbox::callStaticMethod(classNum(DocGlobalHelper), staticMethodStr(DocGlobalHelper, startLengthyOperationInternal), conNull(), _waitCaption);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLengthyOperationInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Internal static method called by the startLengthyOperation method to display the progress indicator window.
    /// </summary>
    /// <param name = "_parameters">Container of passed parameters to static method</param>
    private static void startLengthyOperationInternal(container _parameters = conNull()) { }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>