<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DocEmailTemplateManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Net.Mail;

/// <summary>
/// The DocEmailTemplateManager class is used as a manager for email templates.
/// </summary>
public class DocEmailTemplateManager
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>sendMail</Name>
				<Source><![CDATA[
    /*----------------------------------------------------------------------------------------*/
    /*  Instead of using the built-in SysEmailTable::sendMail() method method for replacing
        placeholders in an email’s body and subject before sending it, you can use the
        DocEmailTemplateManager::sendMail() method that offers you more options.              */
    /*----------------------------------------------------------------------------------------*/
    /// <summary>
    /// Use this method to send an email using the provided built-in email template to the given recipient.
    /// </summary>
    /// <param name = "_emailId">Email Template ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <param name = "_emailToAddr">Recipient e-mail address or list of e-mail addresses</param>
    /// <param name = "_mappings">
    /// Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a map of placeholders and their values used in the dynamic email body.
    /// If null, it will be created and filled using the corresponding ETH class (if such logic is provided).
    /// </param>
    /// <param name = "_lineMappings">
    /// List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a list of mappings for each line of the dynamic table within the email body.
    /// Use the _lineMappings parameter, if you have only one dynamic table in the email body.
    /// Use the _multipleLineMappings parameter, if you have multiple dynamic tables in the email body.
    /// If null, it will be created and filled using the corresponding ETH class (if such logic is provided).
    /// </param>
    /// <param name = "_contextInfo">Context info that can be provided for filling _mappings and _lineMappings with placeholders' values</param>
    /// <param name = "_emailCcAddr">Cc email address(es)</param>
    /// <param name = "_emailBccAddr">Bcc email address(es)</param>
    /// <param name = "_emailAttachmentFilename">Email attachment filename (optional)</param>
    /// <param name = "_emailAttachmentContent">Email attachment file content (optional)</param>
    /// <param name = "_emailAdditionalAttachments">Additional email attachments in a form: [ [attachmentName, [content]], [attachmentName, [content]], ...]</param>
    /// <param name = "_multipleLineMappings">
    /// Map(DynamicTableName (str) -> List of Map(PlaceholderName (str) -> PlaceholderValue (str))).
    /// This is a map of multiple LineMappings for each of the dynamic tables within the email body.
    /// Use the _lineMappings parameter, if you have only one dynamic table in the email body.
    /// Use the _multipleLineMappings parameter, if you have multiple dynamic tables in the email body.
    /// If null, it will be created and filled using the corresponding ETH class (if such logic is provided).
    /// </param>
    /// <param name = "_useEmailProcessing">Should the email be sent using email processing</param>
    /// <param name = "_emailProcessingParams">Email processing specific parameters</param>
    /// <param name = "_emailReplyToAddr">Reply-to email address(es)</param>
    /// <param name = "_emailBounceToAddr">Bounce-to email address</param>
    /// <returns>An instance of the DocSendMailResult class if email was sent successfully; otherwise an exception</returns>
    public static DocSendMailResult sendMail(SysEmailId _emailId, LanguageId _languageId,
                                             str _emailToAddr,
                                             Map _mappings = null,
                                             List _lineMappings = null,
                                             container _contextInfo = conNull(),
                                             str _emailCcAddr = '', str _emailBccAddr = '',
                                             str _emailAttachmentFilename = '', container _emailAttachmentContent = conNull(),
                                             container _emailAdditionalAttachments = conNull(),
                                             Map _multipleLineMappings = null,
                                             boolean _useEmailProcessing = false,
                                             DocEmailProcessingParams _emailProcessingParams = null,
                                             str _emailReplyToAddr = '', str _emailBounceToAddr = '')
    {
        DocSendMailResult sendMailResult = new DocSendMailResult();

        SysEmailTable emailTable;
        SysEmailMessageTable emailMessage;
        str languageId;

        DocEmailTemplateDelegates emailTemplateDelegates = DocEmailTemplateDelegates::instance();

        // -- Get the email table, message and language.
        [emailTable, emailMessage, languageId] = DocEmailTemplateManager::getSysEmailTableAndMessageTable(_emailId, _languageId);

        if (emailTable.RecId == 0)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailMessageNotFound", _emailId));
        }
        // Check if an email message exists. For alert emails, as of version 3.4.5 we allow that email message is an empty record or without body.
        if (!emailTable.IsUsedForAlert_DC && (emailMessage.RecId == 0 || !emailMessage.Mail)) // 
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailMsgContentNotFound", _emailId));
        }

        // -- Create the email message settings.
        DocEmailMessageSettings emailMsgSettings = DocEmailMessageSettings::createFromSysEmailTable(emailTable, emailMessage);

        // Set other email parameters.
        emailMsgSettings.parmEmailTo(_emailToAddr);
        emailMsgSettings.parmEmailCc(_emailCcAddr);
        emailMsgSettings.parmEmailBcc(_emailBccAddr);
        emailMsgSettings.parmEmailReplyTo(_emailReplyToAddr);
        emailMsgSettings.parmEmailBounceTo(_emailBounceToAddr);
        
        emailMsgSettings.deleteEmptyAndDuplicatedEmailAddresses();
        
        emailMsgSettings.parmEmailAttachmentName(_emailAttachmentFilename);
        emailMsgSettings.parmEmailAttachmentContent(_emailAttachmentContent);
        emailMsgSettings.parmEmailAdditionalAttachments(_emailAdditionalAttachments);

        // Instance the proper ETH class and additionally fill _mapping with
        // the standard and custom placeholders using emailId and languageId.
        Map mappings = _mappings;
        if (mappings == null)
        {
            mappings = new Map(Types::String, Types::String);  // Map(DocPlaceholderNameEx -> DocPlaceholderValue)
        }
        List lineMappings = _lineMappings;
        if (lineMappings == null)
        {
            lineMappings = new List(Types::Class);  // List of Map(DocPlaceholderNameEx -> DocPlaceholderValue)
        }
        Map multipleLineMappings = _multipleLineMappings;
        if (multipleLineMappings == null)
        {
            multipleLineMappings = new Map(Types::String, Types::Class);  // Map(DynamicTableName -> List of Map(DocPlaceholderNameEx -> DocPlaceholderValue))
        }
        
        // -- Fill mappings with placeholder values.
        DocEmailTemplateHandlerBase ethClassInstance;
        try
        {
            ethClassInstance = DocEmailTemplateHandlerBase::fillMappings(emailTable.EmailId, languageId, mappings, false, _contextInfo, lineMappings, multipleLineMappings);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:FillMappingsEthClassOrgTemplatesError", emailTable.EmailId));
        }

        // -- Update mappings for image placeholders.
        try
        {
            // For each image placeholder take its value (i.e. image content) and put it in another map (imageMap)
            // and then replace the placeholder value with its name (i.e. cid). Also remove all images unused in the email body.
            Map imageMap = DocEmailTemplateHelper::updateMappingsWithImagesForDocentricEmailing(mappings, lineMappings, multipleLineMappings, _emailId, _languageId, false);
            emailMsgSettings.parmEmailImages(imageMap);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:UpdateMappingsImagePlaceholdersOrgTemplatesError", emailTable.EmailId));
        }

        // -- Invoke delegate for changing the settings before replacing placeholders.
        emailTemplateDelegates.onBeforeReplacingPlaceholders(emailMsgSettings, _emailId, _languageId, NoYes::No, mappings, lineMappings, _contextInfo, multipleLineMappings, _useEmailProcessing, _emailProcessingParams);

        // -- Replace placeholders in the email body and subject, To, Cc and Bcc.
        DocEmailTemplateManager::processPlaceholdersInEmailSettings(emailMsgSettings, _emailId, _languageId, NoYes::No, mappings, lineMappings, multipleLineMappings);

        // -- If this is an alert email, handle attachments and change email processing parameters.
        DocEmailTemplateManager::processAlertEmail(emailMsgSettings, _emailProcessingParams, ethClassInstance, emailTable, emailMessage, _contextInfo);

        // -- Invoke the delegate for changing the settings after replacing placeholders and before sending the email.
        boolean useEmailProcessing = emailTemplateDelegates.onBeforeSendingEmail(emailMsgSettings, _emailId, _languageId, NoYes::No, mappings, lineMappings, _contextInfo, multipleLineMappings, _useEmailProcessing, _emailProcessingParams);

        if (useEmailProcessing)
        {
            // -- Save the email to the outgoing queue.
            SysOutgoingEmailTable outgoingEmailTable = DocEmailTemplateManager::saveToOutgoingEmailTable(emailMsgSettings, emailTable.EmailId, NoYes::No, _emailProcessingParams ? _emailProcessingParams : new DocEmailProcessingParams());
            sendMailResult.parmOutgoingEmailTable(outgoingEmailTable);
        }
        else
        {
            // -- Create and send the email message.
            DocEmailTemplateManager::createAndSendEmailMessage(emailMsgSettings, emailTable, emailMessage, mappings, lineMappings, _contextInfo, multipleLineMappings);
        }

        return sendMailResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSysEmailTableAndMessageTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the corresponding SysEmailTable and SysEmailMessageTable records
    /// for the given parameters and the resolved language ID.
    /// </summary>
    /// <param name = "_emailId">Email Template ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <returns>
    /// Returns container: [emailTable, emailMessage, languageId], where emailTable is the SysEmailTable record
    /// related to email ID, emailMessage is the SysEmailMessageTable record related to the given email ID and
    /// language ID, and language ID is the resolved language if the _languageId parameter is not provided.
    /// </returns>
    public static container getSysEmailTableAndMessageTable(SysEmailId _emailId, LanguageId _languageId)
    {
        SysEmailTable           emailTable;
        SysEmailMessageTable    emailMessage;
        str                     languageId;


        // SysEmailTable.
        emailTable = SysEmailTable::find(_emailId);
        
        if (_languageId)
        {
            languageId = _languageId;
        }
        else
        {
            languageId = emailTable.DefaultLanguage;
        }

        // SysEmailMessageTable.
        emailMessage = SysEmailMessageTable::find(_emailId, languageId);
        if (!emailMessage)
        {
            emailMessage = SysEmailMessageTable::find(_emailId, emailTable.DefaultLanguage);
            languageId = emailTable.DefaultLanguage;
        }
        if (!emailMessage)
        {
            emailMessage = SysEmailMessageTable::find(_emailId, '');
            languageId = currentUserLanguage();
        }
        if (!emailMessage)
        {
            emailMessage = SysEmailMessageTable::find(_emailId, currentUserLanguage());
            languageId = currentUserLanguage();
        }
        
        
        return [emailTable, emailMessage, languageId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndSendEmailMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create and send an email message.
    /// </summary>
    /// <param name = "_emailMsgSettings">Email message settings needed for sending an email</param>
    /// <param name = "_emailTable">The SysEmailTable record</param>
    /// <param name = "_emailMessageTable">The SysEmailMessageTable record</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_lineMappings">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_contextInfo">Context info that can be provided for filling _mappings and _lineMappings with placeholders' values</param>
    /// <param name = "_multipleLineMappings">Map(DynamicTableName (str) -> List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)))</param>
    public static void createAndSendEmailMessage(DocEmailMessageSettings _emailMsgSettings,
                                                 /* the following parameters are needed only for invoking the delegates */
                                                 SysEmailTable _emailTable = null,
                                                 SysEmailMessageTable _emailMessageTable = null,
                                                 Map _mappings = null,
                                                 List _lineMappings = null,
                                                 container _contextInfo = conNull(),
                                                 Map _multipleLineMappings = null)
    {
        try
        {
            // Set the default values.
            _emailMsgSettings.setDefaultParmValues();

            // Validate parameters.
            if (!_emailMsgSettings.validate())
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:InvalidEmailMsgSettings");
            }

            // Create the email message and send it.
            using (MailMessage mailMessage = DocEmailMngHelper::createEmailMessage(
                                                                    _emailMsgSettings.parmEmailFrom(),
                                                                    _emailMsgSettings.parmEmailSenderDisplayName(),
                                                                    _emailMsgSettings.parmEmailTo(),
                                                                    _emailMsgSettings.parmEmailCc(),
                                                                    _emailMsgSettings.parmEmailBcc(),
                                                                    _emailMsgSettings.parmEmailSubject(),
                                                                    _emailMsgSettings.parmEmailBody(),
                                                                    true,  // Is Html body
                                                                    _emailMsgSettings.parmEmailPriority(),
                                                                    _emailMsgSettings.parmEmailAttachmentName(),
                                                                    _emailMsgSettings.parmEmailAttachmentContent(),
                                                                    _emailMsgSettings.parmEmailAdditionalAttachments(),
                                                                    _emailMsgSettings.parmEmailImages(),
                                                                    _emailMsgSettings.parmEmailReplyTo(),
                                                                    _emailMsgSettings.parmEmailBounceTo()))
            {
                // Publish event that email has been created.
                DocEmailTemplateDelegates emailTemplateDelegates = DocEmailTemplateDelegates::instance();
                DocEventHandlerResult res = emailTemplateDelegates.onEmailMessageCreated(
                    mailMessage, _emailMsgSettings, _emailTable, _emailMessageTable, _mappings, _lineMappings, _contextInfo, _multipleLineMappings);
                if (res.cancelExecution())
                {
                    return;
                }

                // Send mail message using email provider set in Email parameters.
                DocEmailMngHelper::sendEmailMsgUsingEmailProvider(mailMessage);

                // Publish event that email has been sent.
                emailTemplateDelegates.onEmailMessageSent(mailMessage, _emailMsgSettings, _emailTable, _emailMessageTable, _mappings, _lineMappings, _contextInfo, _multipleLineMappings);
            }
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:FailedToCreateOrSendEmailMessage", "@DocentricAX4:Organization", _emailTable.EmailId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveToOutgoingEmailTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the outgoing email message to the SysOutgoingEmailTable table (Batch email sending status)
    /// in order to be sent out using email processing (Email distributor batch).
    /// </summary>
    /// <param name="_emailMsgSettings">Email message settings</param>
    /// <param name="_emailId">Email template ID</param>
    /// <param name="_isSystemEmail">NoYes::No, for Organization email template; NoYes::Yes for System email template</param>
    /// <param name="_emailProcessingParams">Email processing parameters</param>
    /// <returns>The SysOutgoingEmailTable record</returns>
    public static Common saveToOutgoingEmailTable(DocEmailMessageSettings _emailMsgSettings,
                                                  SysEmailId _emailId, NoYes _isSystemEmail,
                                                  DocEmailProcessingParams _emailProcessingParams = new DocEmailProcessingParams())
    {
        SysOutgoingEmailTable outgoingEmailTable;


        // Gets an email template description
        str getEmailTemplateDescription()
        {
            if (_isSystemEmail)
            {
                // This is a System email template.
                return SysEmailSystemTable::find(_emailId).Description;
            }
            else
            {
                // This is an Organization email template.
                return SysEmailTable::find(_emailId).Description;
            }
        }

        // Gets additional information if an email message was not successfully saved in the SysOutgoingEmailTable table
        str getAdditionalInfo()
        {
            str additionalInfo = _emailMsgSettings.toMessageInfo();
            str additionalInfoEmailProcessing = _emailProcessingParams.toString();

            if (additionalInfoEmailProcessing)
            {
                additionalInfo += (additionalInfo ? ', ' : '') + additionalInfoEmailProcessing;
            }

            if (additionalInfo)
            {
                additionalInfo = strFmt("@DocentricAX3:AdditionalInformation", additionalInfo);
            }

            return additionalInfo;
        }


        // Check input parameters        
        if (_emailMsgSettings == null || _emailProcessingParams == null)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParametersNotSet", strFmt('%1, %2', identifierStr(_emailMsgSettings), identifierStr(_emailProcessingParams))));
        }

        try
        {
            // Set the default values.
            _emailMsgSettings.setDefaultParmValues();

            // Validate parameters.
            if (!_emailMsgSettings.validate())
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:InvalidEmailMsgSettings");
            }

            // Save the mail message in SysOutgoingEmailTable.
            SysOutgoingEmailData    outgoingEmailData;
            RecordInsertList        outgoingEmailDataInsertList = new RecordInsertList(tableNum(SysOutgoingEmailData));
            Filename                filePath;
        
            ttsBegin;

            // (1) Insert email message data in the SysOutgoingEmailTable table.
            outgoingEmailTable.EmailItemId = EventInbox::nextEventId();
            outgoingEmailTable.TemplateId = _emailId;       // SysEmailTable/SysEmailSystemTable.EmailId
            outgoingEmailTable.IsSystemEmail = _isSystemEmail;

            outgoingEmailTable.Sender = _emailMsgSettings.parmEmailFrom();
            outgoingEmailTable.SenderName = _emailMsgSettings.parmEmailSenderDisplayName() ? _emailMsgSettings.parmEmailSenderDisplayName() : _emailMsgSettings.parmEmailFrom();
            outgoingEmailTable.Recipient = _emailMsgSettings.parmEmailTo();
            outgoingEmailTable.Origin = _emailProcessingParams.origin() ? _emailProcessingParams.origin() : getEmailTemplateDescription();
            outgoingEmailTable.Subject = _emailMsgSettings.parmEmailSubject();
            outgoingEmailTable.Message = _emailMsgSettings.parmEmailBody();
        
            outgoingEmailTable.Priority = _emailMsgSettings.parmEmailPriority();
            outgoingEmailTable.WithRetries = NoYes::Yes;
            outgoingEmailTable.RetryNum = 0;
            outgoingEmailTable.UserId = _emailProcessingParams.userId() ? _emailProcessingParams.userId() : curUserId();
            outgoingEmailTable.Status = SysEmailStatus::Unsent;

            // Fill Docentric fields.
            outgoingEmailTable.ContextInfo_DC = _emailProcessingParams.contextInformation();
            outgoingEmailTable.CompanyId_DC = curExt();
            outgoingEmailTable.EmailCc_DC = _emailMsgSettings.parmEmailCc();
            outgoingEmailTable.EmailBcc_DC = _emailMsgSettings.parmEmailBcc();
            outgoingEmailTable.EmailReplyTo_DC = _emailMsgSettings.parmEmailReplyTo();
            outgoingEmailTable.EmailBounceTo_DC = _emailMsgSettings.parmEmailBounceTo();
            
            // NOTE: These advanced parameters are currently not supported.
            /*
            outgoingEmailTable.EmailDeliveryReceiptCondition_DC = _emailMsgSettings.parmDeliveryReceiptCondition();
            // Resolve token @FROM_ADDRESS@ in Read receipt address.
            if (_emailMsgSettings.parmReadReceiptAddress() == DocConstant::EmailFromAddressPlaceholder)
            {
                outgoingEmailTable.EmailReadReceiptAddress_DC = _emailMsgSettings.parmEmailFrom();
            }
            else
            {
                outgoingEmailTable.EmailReadReceiptAddress_DC = _emailMsgSettings.parmReadReceiptAddress();
            }*/

            // Customer/Vendor account number
            outgoingEmailTable.AccountNum_DC = _emailProcessingParams.accountNum();
            // N/A, Vendor or Customer
            outgoingEmailTable.AccountType_DC = _emailProcessingParams.accountType();
            // Generated Report DocumentID
            outgoingEmailTable.DocumentId_DC = _emailProcessingParams.documentId();

            // (2) Insert email message attachments in the SysOutgoingEmailData table.
            SysEmailDataId newDataId = 1;
            
            // (2a) Embed images.
            if (_emailMsgSettings.parmEmailImages())
            {
                MapEnumerator e = _emailMsgSettings.parmEmailImages().getEnumerator();
                while (e.moveNext())
                {
                    str placeholderCode = e.currentKey();

                    // Skip used CIDs with missing parts.
                    while (strScan(outgoingEmailTable.Message, strFmt('src="cid:%1"', newDataId), 1, strLen(outgoingEmailTable.Message)))
                    {
                        newDataId++;
                    }

                    outgoingEmailTable.Message = strReplace(outgoingEmailTable.Message, strFmt('src="cid:%1"', placeholderCode), strFmt('src="cid:%1"', newDataId));

                    outgoingEmailData.clear();
                    outgoingEmailData.EmailItemId = outgoingEmailTable.EmailItemId;
                    outgoingEmailData.DataId = newDataId;
                    outgoingEmailData.EmailDataType = SysEmailDataType::Embedded;
                    outgoingEmailData.Data = e.currentValue();
                    outgoingEmailData.FileName = placeholderCode;       // Empty filename will cause an error on SysOutgoingEmailMessage form, so we just set one.

                    str contentType = DocGlobalHelper::getImageMIMEContentType(DocGlobalHelper::convertContainerToMemoryStream(outgoingEmailData.Data));
                    outgoingEmailData.FileExtension = (strStartsWith(contentType, 'image/') ? strReplace(contentType, 'image/', '.') : '.png');

                    outgoingEmailDataInsertList.add(outgoingEmailData);
                    newDataId++;
                }
            }

            // (2b) Attach the main attachment.
            if (_emailMsgSettings.parmEmailAttachmentContent())
            {
                outgoingEmailData.clear();
                outgoingEmailData.EmailItemId = outgoingEmailTable.EmailItemId;
                outgoingEmailData.DataId = newDataId;
                outgoingEmailData.EmailDataType = SysEmailDataType::Attachment;
                outgoingEmailData.Data = _emailMsgSettings.parmEmailAttachmentContent();
                [filePath, outgoingEmailData.FileName, outgoingEmailData.FileExtension] = Global::fileNameSplit(_emailMsgSettings.parmEmailAttachmentName());
                outgoingEmailData.insert();
                newDataId++;
            }

            // (2c) Attach additional attachments.
            container additionalAttachments =_emailMsgSettings.parmEmailAdditionalAttachments();
            for (int i=1; i <= conLen(additionalAttachments); i++)
            {
                str     attachmentName;
                Bitmap  attachmentContent;
            
                [attachmentName, attachmentContent] = conPeek(additionalAttachments, i);

                outgoingEmailData.clear();
                outgoingEmailData.EmailItemId = outgoingEmailTable.EmailItemId;
                outgoingEmailData.DataId = newDataId;
                outgoingEmailData.EmailDataType = SysEmailDataType::Attachment;
                outgoingEmailData.Data = attachmentContent;
                [filePath, outgoingEmailData.FileName, outgoingEmailData.FileExtension] = Global::fileNameSplit(attachmentName);
                outgoingEmailDataInsertList.add(outgoingEmailData);
                newDataId++;
            }

            // Insert all attachments to the database.
            outgoingEmailDataInsertList.insertDatabase();
       
            // Save and commit.
            outgoingEmailTable.LatestStatusChangeDateTime = DateTimeUtil::getSystemDateTime();
            outgoingEmailTable.insert();

            // Update the EmailId field in the EventInbox table
            EventInbox eventInbox = EventInbox::find(_emailProcessingParams.eventInboxId(), true);
            if (eventInbox)
            {
                eventInbox.EmailId = outgoingEmailTable.EmailItemId;
                eventInbox.update();
            }

            ttsCommit;
        }
        catch
        {
            str additionalInfo = getAdditionalInfo();
            str errorMsg = strFmt("@DocentricAX3:EmailTemplatesEmailProcessingErrorMsg", _emailId) + (additionalInfo ? ' ' + additionalInfo : '');
            
            DocGlobalHelper::handleException(funcName(), errorMsg);
        }

        return outgoingEmailTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendSysMail</Name>
				<Source><![CDATA[
    /*----------------------------------------------------------------------------------------*/
    /*  Instead of using the built-in SysEmailSystemTable::sendMail() method method for
        replacing placeholders in an email’s body and subject before sending it, you can
        use the DocEmailTemplateManager::sendMail() method that offers you more options.      */
    /*----------------------------------------------------------------------------------------*/
    /// <summary>
    /// Use this method to send an email using the provided built-in email template to the given recipient.
    /// </summary>
    /// <param name = "_emailId">Email Template ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <param name = "_emailToAddr">Recipient e-mail address or list of e-mail addresses</param>
    /// <param name = "_mappings">
    /// Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a map of placeholders and their values used in the dynamic email body.
    /// If null, it will be created and filled using the corresponding ETH class.
    /// </param>
    /// <param name = "_lineMappings">
    /// List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a list of mappings for each line of the dynamic table within the email body.
    /// If null, it will be created and filled using the corresponding ETH class.
    /// </param>
    /// <param name = "_contextInfo">Context info that can be provided for filling _mappings and _lineMappings with placeholders' values</param>
    /// <param name = "_emailCcAddr">Cc e-mail address(es)</param>
    /// <param name = "_emailBccAddr">Bcc e-mail address(es)</param>
    /// <param name = "_emailAttachmentFilename">Email attachment filename (optional)</param>
    /// <param name = "_emailAttachmentContent">Email attachment file content (optional)</param>
    /// <param name = "_emailAdditionalAttachments">Additional email attachments in a form: [ [attachmentName, [content]], [attachmentName, [content]], ...]</param>
    /// <param name = "_multipleLineMappings">
    /// Map(DynamicTableName (str) -> List of Map(PlaceholderName (str) -> PlaceholderValue (str))).
    /// This is a map of multiple LineMappings for each of the dynamic tables within the email body.
    /// Use the _lineMappings parameter, if you have only one dynamic table in the email body.
    /// Use the _multipleLineMappings parameter, if you have multiple dynamic tables in the email body.
    /// If null, it will be created and filled using the corresponding ETH class (if such logic is provided).
    /// </param>
    /// <param name = "_useEmailProcessing">Should the email be sent using email processing</param>
    /// <param name = "_emailProcessingParams">Email processing specific parameters</param>
    /// <param name = "_emailReplyToAddr">Reply-to email address(es)</param>
    /// <param name = "_emailBounceToAddr">Bounce-to email address</param>
    /// <returns>An instance of the DocSendMailResult class if email was sent successfully; otherwise an exception</returns>
    public static DocSendMailResult sendSysMail(SysEmailId _emailId, LanguageId _languageId,
                                                str _emailToAddr,
                                                Map _mappings = null,
                                                List _lineMappings = null,
                                                container _contextInfo = conNull(),
                                                str _emailCcAddr = '', str _emailBccAddr = '',
                                                str _emailAttachmentFilename = '', container _emailAttachmentContent = conNull(),
                                                container _emailAdditionalAttachments = conNull(),
                                                Map _multipleLineMappings = null,
                                                boolean _useEmailProcessing = false,
                                                DocEmailProcessingParams _emailProcessingParams = null,
                                                str _emailReplyToAddr = '', str _emailBounceToAddr = '')
    {
        DocSendMailResult sendMailResult = new DocSendMailResult();

        SysEmailSystemTable emailSysTable;
        SysEmailMessageSystemTable emailSysMessage;
        str languageId;

        DocEmailTemplateDelegates       emailTemplateDelegates = DocEmailTemplateDelegates::instance();


        // Get the email table, message and language.
        [emailSysTable, emailSysMessage, languageId] = DocEmailTemplateManager::getSysEmailSystemTableAndMessageTable(_emailId, _languageId);

        if (emailSysTable.RecId == 0)
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailMessageNotFound", _emailId));
        }
        // Check if an email message exists. For alert emails, as of version 3.4.5 we allow that email message is an empty record or without body.
        if (!emailSysTable.IsUsedForAlert_DC && (emailSysMessage.RecId == 0 || !emailSysMessage.Mail))
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailMsgContentNotFound", _emailId));
        }
        
        // Create the email message settings.
        DocEmailMessageSettings emailMsgSettings = DocEmailMessageSettings::createFromSysEmailSystemTable(emailSysTable, emailSysMessage);

        // Set other email parameters.
        emailMsgSettings.parmEmailTo(_emailToAddr);
        emailMsgSettings.parmEmailCc(_emailCcAddr);
        emailMsgSettings.parmEmailBcc(_emailBccAddr);
        emailMsgSettings.parmEmailReplyTo(_emailReplyToAddr);
        emailMsgSettings.parmEmailBounceTo(_emailBounceToAddr);
        
        emailMsgSettings.deleteEmptyAndDuplicatedEmailAddresses();
        
        emailMsgSettings.parmEmailAttachmentName(_emailAttachmentFilename);
        emailMsgSettings.parmEmailAttachmentContent(_emailAttachmentContent);
        emailMsgSettings.parmEmailAdditionalAttachments(_emailAdditionalAttachments);

        // Instance the proper ETH class and additionally fill _mapping with
        // the standard and custom placeholders using emailId and languageId.
        Map mappings = _mappings;
        if (mappings == null)
        {
            mappings = new Map(Types::String, Types::String);   // Map(DocPlaceholderNameEx -> DocPlaceholderValue)
        }
        List lineMappings = _lineMappings;
        if (lineMappings == null)
        {
            lineMappings = new List(Types::Class);   // List of Map(DocPlaceholderNameEx -> DocPlaceholderValue)
        }
        Map multipleLineMappings = _multipleLineMappings;
        if (multipleLineMappings == null)
        {
            multipleLineMappings = new Map(Types::String, Types::Class);  // Map(DynamicTableName -> List of Map(DocPlaceholderNameEx -> DocPlaceholderValue))
        }
        
        // -- Fill mappings with placeholder values.
        DocEmailTemplateHandlerBase ethClassInstance;
        try
        {
            ethClassInstance = DocEmailTemplateHandlerBase::fillMappings(emailSysTable.EmailId, languageId, mappings, true, _contextInfo, lineMappings, multipleLineMappings);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Failed to fill mappings with placeholder values for the system email template (%1)', emailSysTable.EmailId));
        }

        // -- Update mappings for image placeholders.
        try
        {
            // For each image placeholder take its value (i.e. image content) and put it in another map (imageMap)
            // and then replace the placeholder value with its name (i.e. cid). Also remove all images unused in the email body.
            Map imageMap = DocEmailTemplateHelper::updateMappingsWithImagesForDocentricEmailing(mappings, lineMappings, multipleLineMappings, _emailId, _languageId, true);
            emailMsgSettings.parmEmailImages(imageMap);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt('Failed to update mappings for image placeholders for the system email template (%1)', emailSysTable.EmailId));
        }

        // -- Invoke delegate for changing the settings before replacing placeholders.
        emailTemplateDelegates.onBeforeReplacingPlaceholders(emailMsgSettings, _emailId, _languageId, NoYes::Yes, mappings, lineMappings, _contextInfo, multipleLineMappings, _useEmailProcessing, _emailProcessingParams);

        // -- Replace placeholders in the email body and subject, To, Cc and Bcc.
        DocEmailTemplateManager::processPlaceholdersInEmailSettings(emailMsgSettings, _emailId, _languageId, NoYes::Yes, mappings, lineMappings, multipleLineMappings);

        // -- If this is an alert email, handle attachments and change email processing parameters.
        DocEmailTemplateManager::processAlertEmail(emailMsgSettings, _emailProcessingParams, ethClassInstance, emailSysTable, emailSysMessage, _contextInfo);

        // -- Invoke the delegate for changing the settings after replacing placeholders and before sending the email.
        boolean useEmailProcessing = emailTemplateDelegates.onBeforeSendingEmail(emailMsgSettings, _emailId, _languageId, NoYes::Yes, mappings, lineMappings, _contextInfo, multipleLineMappings, _useEmailProcessing, _emailProcessingParams);

        if (useEmailProcessing)
        {
            // -- Save the email to the outgoing queue.
            SysOutgoingEmailTable outgoingEmailTable = DocEmailTemplateManager::saveToOutgoingEmailTable(emailMsgSettings, emailSysTable.EmailId, NoYes::Yes, _emailProcessingParams ? _emailProcessingParams : new DocEmailProcessingParams());
            sendMailResult.parmOutgoingEmailTable(outgoingEmailTable);
        }
        else
        {
            // -- Create and send the email message.
            DocEmailTemplateManager::createAndSendEmailSystemMessage(emailMsgSettings, emailSysTable, emailSysMessage, mappings, lineMappings, _contextInfo);
        }

        return sendMailResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSysEmailSystemTableAndMessageTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the corresponding SysEmailSystemTable and SysEmailMessageSystemTable records
    /// for the given parameters and the resolved language ID.
    /// </summary>
    /// <param name = "_emailId">Email Template ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <returns>
    /// Returns container: [emailSysTable, emailSysMessage, languageId], where emailTable is the SysEmailSystemTable record
    /// related to email ID, emailMessage is the SysEmailMessageSystemTable record related to the given email ID and
    /// language ID, and language ID is the resolved language if the _languageId parameter is not provided.
    /// </returns>
    public static container getSysEmailSystemTableAndMessageTable(SysEmailId _emailId, LanguageId _languageId)
    {
        SysEmailSystemTable           emailSysTable;
        SysEmailMessageSystemTable    emailSysMessage;
        str                           languageId;


        // SysEmailTable.
        emailSysTable = SysEmailSystemTable::find(_emailId);
        
        if (_languageId)
        {
            languageId = _languageId;
        }
        else
        {
            languageId = emailSysTable.DefaultLanguage;
        }

        // SysEmailMessageTable.
        emailSysMessage = SysEmailMessageSystemTable::find(_emailId, languageId);
        if (!emailSysMessage)
        {
            emailSysMessage = SysEmailMessageSystemTable::find(_emailId, emailSysTable.DefaultLanguage);
            languageId = emailSysTable.DefaultLanguage;
        }
        if (!emailSysMessage)
        {
            emailSysMessage = SysEmailMessageSystemTable::find(_emailId, '');
            languageId = currentUserLanguage();
        }
        if (!emailSysMessage)
        {
            emailSysMessage = SysEmailMessageSystemTable::find(_emailId, currentUserLanguage());
            languageId = currentUserLanguage();
        }
        
        
        return [emailSysTable, emailSysMessage, languageId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndSendEmailSystemMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create and send an email message.
    /// </summary>
    /// <param name = "_emailMsgSettings">Email message settings needed for sending an email</param>
    /// <param name = "_emailSysTable">The SysEmailTable record</param>
    /// <param name = "_emailMessageSysTable">The SysEmailMessageTable record</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_lineMappings">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_contextInfo">Context info that can be provided for filling _mappings and _lineMappings with placeholders' values</param>
    public static void createAndSendEmailSystemMessage(DocEmailMessageSettings _emailMsgSettings,
                                                       /* the following parameters are needed only for invoking the delegates */
                                                       SysEmailSystemTable _emailSysTable = null,
                                                       SysEmailMessageSystemTable _emailMessageSysTable = null,
                                                       Map _mappings = null,
                                                       List _lineMappings = null,
                                                       container _contextInfo = conNull())
    {
        try
        {
            // Set the default values.
            _emailMsgSettings.setDefaultParmValues();

            // Validate parameters.
            if (!_emailMsgSettings.validate())
            {
                DocGlobalHelper::handleException(funcName(), "@DocentricAX:InvalidEmailMsgSettings");
            }

            // Create the email message and send it.
            using (MailMessage mailMessage = DocEmailMngHelper::createEmailMessage(
                                                                    _emailMsgSettings.parmEmailFrom(),
                                                                    _emailMsgSettings.parmEmailSenderDisplayName(),
                                                                    _emailMsgSettings.parmEmailTo(),
                                                                    _emailMsgSettings.parmEmailCc(),
                                                                    _emailMsgSettings.parmEmailBcc(),
                                                                    _emailMsgSettings.parmEmailSubject(),
                                                                    _emailMsgSettings.parmEmailBody(),
                                                                    true,  // Is Html body
                                                                    _emailMsgSettings.parmEmailPriority(),
                                                                    _emailMsgSettings.parmEmailAttachmentName(),
                                                                    _emailMsgSettings.parmEmailAttachmentContent(),
                                                                    _emailMsgSettings.parmEmailAdditionalAttachments(),
                                                                    _emailMsgSettings.parmEmailImages()))
            {
                // Publish event that email has been created.
                DocEmailTemplateDelegates emailTemplateDelegates = DocEmailTemplateDelegates::instance();
                DocEventHandlerResult res = emailTemplateDelegates.onEmailSysMessageCreated(
                    mailMessage, _emailMsgSettings, _emailSysTable, _emailMessageSysTable, _mappings, _lineMappings, _contextInfo);
                if (res.cancelExecution())
                {
                    return;
                }

                // Send mail message using email provider set in Email parameters.
                DocEmailMngHelper::sendEmailMsgUsingEmailProvider(mailMessage);

                // Publish event that email has been sent.
                emailTemplateDelegates.onEmailSysMessageSent(mailMessage, _emailMsgSettings, _emailSysTable, _emailMessageSysTable, _mappings, _lineMappings, _contextInfo);
            }
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:FailedToCreateOrSendEmailMessage", "@DocentricAX4:System", _emailSysTable.EmailId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPlaceholdersInEmailSettings</Name>
				<Source><![CDATA[
    /*---------------------------------------------*/
    /*  Processing placeholders in email settings  */
    /*---------------------------------------------*/
    /// <summary>
    /// Replaces placeholders in the email body and subject, To, Cc and Bcc.
    /// </summary>
    /// <param name = "_emailMsgSettings">Email message settings needed for sending an email</param>
    /// <param name = "_emailId">Email Template ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <param name = "_isSystemEmail">True, if the provided _emailId is the ID of a System email template; otherwise the ID of an Organization email template.</param>
    /// <param name = "_mappings">
    /// Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a map of placeholders and their values used in the dynamic email body.
    /// If null, it will be created and filled using the corresponding ETH class.
    /// </param>
    /// <param name = "_lineMappings">
    /// List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)). This is a list of mappings for each line of the dynamic table within the email body.
    /// If null, it will be created and filled using the corresponding ETH class.
    /// </param>
    /// <param name = "_multipleLineMappings">
    /// Map(DynamicTableName (str) -> List of Map(PlaceholderName (str) -> PlaceholderValue (str))).
    /// This is a map of multiple LineMappings for each of the dynamic tables within the email body.
    /// Use the _lineMappings parameter, if you have only one dynamic table in the email body.
    /// Use the _multipleLineMappings parameter, if you have multiple dynamic tables in the email body.
    /// If null, it will be created and filled using the corresponding ETH class (if such logic is provided).
    /// </param>
    public static void processPlaceholdersInEmailSettings(DocEmailMessageSettings _emailMsgSettings,
                                                          SysEmailId _emailId,
                                                          LanguageId _languageId,
                                                          NoYes _isSystemEmail,
                                                          Map _mappings = null,
                                                          List _lineMappings = null,
                                                          Map _multipleLineMappings = null)
    {
        // -- Replace placeholders in the email body and subject.
        str emailBodyWithReplacedPlaceholders, emailSubjectWithReplacedPlaceholders;
        try
        {
            [emailBodyWithReplacedPlaceholders, emailSubjectWithReplacedPlaceholders] =
                DocEmailTemplateManager::generateEmailBodyAndSubjectWithDynamicLines(
                    _emailMsgSettings.parmEmailBody(), _emailMsgSettings.parmEmailSubject(), _mappings, _lineMappings, _multipleLineMappings);
            _emailMsgSettings.parmEmailBody(emailBodyWithReplacedPlaceholders);
            _emailMsgSettings.parmEmailSubject(emailSubjectWithReplacedPlaceholders);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt("@DocentricAX4:ReplacePlaceholdersInBodySubjectEmailTemplatesError", _isSystemEmail ? "@DocentricAX4:System" : "@DocentricAX4:Organization", _emailId, _languageId));
        }

        // -- Replace placeholders in the email To, Cc and Bcc.
        try
        {
            _emailMsgSettings.parmEmailTo(DocEmailTemplateManager::replacePlaceholders(DocEmailTemplateHelper::replacePlaceholdersUserGroup(DocEmailTemplateHelper::replacePlaceholdersUser(_emailMsgSettings.parmEmailTo())), _mappings, false));
            _emailMsgSettings.parmEmailCc(DocEmailTemplateManager::replacePlaceholders(DocEmailTemplateHelper::replacePlaceholdersUserGroup(DocEmailTemplateHelper::replacePlaceholdersUser(_emailMsgSettings.parmEmailCc())), _mappings, false));
            _emailMsgSettings.parmEmailBcc(DocEmailTemplateManager::replacePlaceholders(DocEmailTemplateHelper::replacePlaceholdersUserGroup(DocEmailTemplateHelper::replacePlaceholdersUser(_emailMsgSettings.parmEmailBcc())), _mappings, false));
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(),
                strFmt("@DocentricAX4:ReplacePlaceholdersInToCcBccEmailTemplatesError", _isSystemEmail ? "@DocentricAX4:System" : "@DocentricAX4:Organization", _emailId, _languageId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEmailBody</Name>
				<Source><![CDATA[
    /*-------------------------------------------*/
    /*  Generate Email Body and Subject Methods  */
    /*-------------------------------------------*/
    /// <summary>
    /// Replaces placeholders in the given email body using the provided _mappings Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_emailBodyWithPlaceholders">Email message template with placeholders</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <returns>Generated email body with the replaced placeholders</returns>
    public static str generateEmailBody(str _emailBodyWithPlaceholders,
                                        Map _mappings = null  /* Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */)
    {
        // Replace placeholders in the email body.
        str emailBodyWithReplacedPlaceholders = DocEmailTemplateManager::replacePlaceholders(_emailBodyWithPlaceholders, _mappings, true);

        return emailBodyWithReplacedPlaceholders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEmailBodyAndSubject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces placeholders in the given email body and subject using the provided _mappings Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_emailBodyWithPlaceholders">Email message template with placeholders</param>
    /// <param name = "_emailSubjectWithPlaceholders">Email message subject with placeholders</param>
    /// <param name = "_mappings">Map(PlaceholderName (str) -> PlaceholderValue (str))</param>
    /// <returns>Generated email body and subject in a form of container [emailBody, emailSubject]</returns>
    public static container generateEmailBodyAndSubject(str _emailBodyWithPlaceholders,
                                                        str _emailSubjectWithPlaceholders,
                                                        Map _mappings = null  /* Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */)
    {
        // Replace placeholders in the email body.
        str emailBodyWithReplacedPlaceholders = DocEmailTemplateManager::replacePlaceholders(_emailBodyWithPlaceholders, _mappings, true);
        
        // Replace placeholders in the email subject.
        str emailSubjectWithReplacedPlaceholders = DocEmailTemplateManager::replacePlaceholders(_emailSubjectWithPlaceholders, _mappings, false);

        return [emailBodyWithReplacedPlaceholders, emailSubjectWithReplacedPlaceholders];
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEmailBodyWithDynamicLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces placeholders in the given email body with dynamic lines using the provided _mappings Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))
    /// and expand lines and replace placeholders using the provided _mappingsForLines: List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_emailBodyWithPlaceholders">Email message template with placeholders</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_lineMappings">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_multipleLineMappings">Map(DynamicTableName (str) -> List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)))</param>
    /// <returns>Generated email body with the replaced placeholders</returns>
    public static str generateEmailBodyWithDynamicLines(str _emailBodyWithPlaceholders,
                                                        Map _mappings = null       /* Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */,
                                                        List _lineMappings = null  /* List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */,
                                                        Map _multipleLineMappings = null  /* Map(DynamicTableName (str) -> List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))) */)
    {
        if ((_lineMappings == null || _lineMappings.empty()) &&
            (_multipleLineMappings == null || _multipleLineMappings.empty()))
        {
            return DocEmailTemplateManager::generateEmailBody(_emailBodyWithPlaceholders, _mappings);
        }

        Map mappings = _mappings;
        if (mappings == null)
        {
            mappings = new Map(Types::String, Types::String);
        }
        
        // Replace placeholders in the email body.
        str emailBodyWithReplacedPlaceholders = _emailBodyWithPlaceholders;
        
        if (_lineMappings != null && !_lineMappings.empty())
        {
            emailBodyWithReplacedPlaceholders = DocEmailTemplateManager::replacePlaceholdersIncludingLines(_emailBodyWithPlaceholders, mappings, _lineMappings);
        }

        if (_multipleLineMappings != null && !_multipleLineMappings.empty())
        {
            MapEnumerator mapEnum = _multipleLineMappings.getEnumerator();
            str emailBodyProcessing = emailBodyWithReplacedPlaceholders;
            while (mapEnum.moveNext())
            {
                str dynamicTableName = mapEnum.currentKey();
                List lineMappings = DocEmailTemplateHelper::tryGetLineMappings(mapEnum);
                if (lineMappings != null)
                {
                    emailBodyProcessing = DocEmailTemplateManager::replacePlaceholdersInLines(emailBodyProcessing, lineMappings, dynamicTableName);
                }
            }

            // Replace placeholders for the header and footer, i.e. perform replacing for the rest of the email body template.
            emailBodyWithReplacedPlaceholders = DocEmailTemplateManager::stringExpand(emailBodyProcessing, mappings, true);
        }

        return emailBodyWithReplacedPlaceholders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEmailBodyAndSubjectWithDynamicLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces placeholders in the given email body with dynamic lines and subject using the provided _mappings Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))
    /// and expand lines and replace placeholders using the provided _mappingsForLines: List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_emailBodyWithPlaceholders">Email message template with placeholders</param>
    /// <param name = "_emailSubjectWithPlaceholders">Email message subject with placeholders</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_lineMappings">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_multipleLineMappings">Map(DynamicTableName (str) -> List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)))</param>
    /// <returns>Generated email body and subject in a form of container [emailBody, emailSubject]</returns>
    public static container generateEmailBodyAndSubjectWithDynamicLines(str _emailBodyWithPlaceholders,
                                                                        str _emailSubjectWithPlaceholders,
                                                                        Map _mappings = null,       /* Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */
                                                                        List _lineMappings = null,  /* List of Map(PDocPlaceholderNameEx (str) -> DocPlaceholderValue (str)) */
                                                                        Map _multipleLineMappings = null  /* Map(DynamicTableName (str) -> List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))) */)
    {
        // Replace placeholders for the header/footer and lines, i.e. perform replacing for the rest of the email body template.
        str emailBodyWithReplacedPlaceholders =
            DocEmailTemplateManager::generateEmailBodyWithDynamicLines(_emailBodyWithPlaceholders, _mappings, _lineMappings, _multipleLineMappings);

        // Replace placeholders in the email subject.
        str emailSubjectWithReplacedPlaceholders = DocEmailTemplateManager::replacePlaceholders(_emailSubjectWithPlaceholders, _mappings, false);

        return [emailBodyWithReplacedPlaceholders, emailSubjectWithReplacedPlaceholders];
    }

]]></Source>
			</Method>
			<Method>
				<Name>replacePlaceholders</Name>
				<Source><![CDATA[
    /*--------------------------------*/
    /*  Replace Placeholders Methods  */
    /*--------------------------------*/
    /// <summary>
    /// Replaces placeholders in the input string using the provided _mappings Map(DocPlaceholderNameEx -> DocPlaceholderValue).
    /// </summary>
    /// <param name = "_s">Input string with placeholders</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_htmlEncode">Should the placeholder values from _mappings be HTML encoded</param>
    /// <returns>String with the replaced placeholders</returns>
    public static str replacePlaceholders(str _s, Map _mappings, boolean _htmlEncode = true)
    {
        if (_mappings == null || _mappings.empty())
        {
            return _s;
        }

        str stringWithReplacedPlaceholders = DocEmailTemplateManager::stringExpand(_s, _mappings, _htmlEncode);
        return stringWithReplacedPlaceholders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replacePlaceholdersIncludingLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces placeholders in the input string using the provided _mappings: Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)))
    /// and expand lines and replace placeholders using the provided _mappingsForLines: List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_s">Input string with placeholders</param>
    /// <param name = "_mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_mappingsForLines">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <returns>String with the replaced placeholders including expanded lines</returns>
    public static str replacePlaceholdersIncludingLines(str _s,
        Map _mappings /* Header DocPlaceholderNameEx (str) -> DocPlaceholderValue (str) */,
        List _mappingsForLines /* List of Maps for each line: DocPlaceholderNameEx (str) -> DocPlaceholderValue (str) */)
    {
        // Replace placeholders for dynamic table.
        str messageBody = DocEmailTemplateManager::replacePlaceholdersInLines(_s, _mappingsForLines);

        // Replace placeholders for the header and footer, i.e. perform replacing for the rest of the email body template.
        messageBody = DocEmailTemplateManager::stringExpand(messageBody, _mappings, true);
        
        return messageBody;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replacePlaceholdersInLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces placeholders in the input string using the provided _mappings: Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))
    /// and expand lines and replace placeholders using the provided _mappingsForLines: List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)).
    /// </summary>
    /// <param name = "_s">Input string with placeholders</param>
    /// <param name = "_mappingsForLines">List of Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name = "_dynamicTableName">A dynamic table name</param>
    /// <returns>String with the replaced placeholders including expanded lines</returns>
    public static str replacePlaceholdersInLines(str _s,
        List _mappingsForLines /* List of Maps for each line: DocPlaceholderNameEx (str) -> DocPlaceholderValue (str) */,
        str _dynamicTableName = '')
    {
        str generateTableLine(str _lineTemplate)
        {
            str generatedTableLine = '';

            // Replace placeholders for each line, using the same 'template line'.
            ListEnumerator listEnum = _mappingsForLines.getEnumerator();
            while (listEnum.moveNext())
            {
                Map lineMappings;

                try
                {
                    lineMappings = listEnum.current();  // Mappings for the current line DocPlaceholderNameEx (str) -> DocPlaceholderValue (str)
                }
                catch
                {
                    DocGlobalHelper::handleException(funcName(), 'Parameter _mappingsForLines is not in the form of List of Maps for each line: DocPlaceholderNameEx -> DocPlaceholderValue');
                }
                if (lineMappings == null)
                {
                    DocGlobalHelper::handleException(funcName(), 'Parameter _mappingsForLines is not in the form of List of Maps for each line: DocPlaceholderNameEx -> DocPlaceholderValue');
                }

                // Replace placeholders for the current line.
                generatedTableLine += DocEmailTemplateManager::stringExpand(_lineTemplate, lineMappings, true);
            }

            return generatedTableLine;
        }


        // Validate parameters.
        if (_mappingsForLines == null)
        {
            DocGlobalHelper::handleException(funcName(), 'Parameter _mappingsForLines is not set');
        }

        str   messageBody, lineTableTemplate;
        int   lineTablePosBegin, lineTablePosEnd;
        str   plhTableBegin = _dynamicTableName ? strFmt('<!--\%%1.%2\%-->', DocConstantPlaceholderET::PlaceholderTableBegin, _dynamicTableName) : DocConstantPlaceholderET::HiddenPlaceholderTableBeginTag;
        str   plhTableEnd   = _dynamicTableName ? strFmt('<!--\%%1.%2\%-->', DocConstantPlaceholderET::PlaceholderTableEnd, _dynamicTableName) : DocConstantPlaceholderET::HiddenPlaceholderTableEndTag;

        messageBody = _s;

        lineTablePosBegin = strScan(messageBody, plhTableBegin, 1, strLen(messageBody));
        lineTablePosEnd = strScan(messageBody, plhTableEnd, 1, strLen(messageBody)) + strLen(plhTableEnd);

        if ((lineTablePosEnd - lineTablePosBegin) > strLen(plhTableBegin) + strLen(plhTableEnd))
        {
            lineTableTemplate = subStr(messageBody,
                                       lineTablePosBegin + strLen(plhTableBegin),
                                       lineTablePosEnd - lineTablePosBegin - strLen(plhTableBegin) - strLen(plhTableEnd));

            messageBody = subStr(messageBody, 1, lineTablePosBegin - 1) + generateTableLine(lineTableTemplate) + subStr(messageBody, lineTablePosEnd, strLen(messageBody));
        }

        return messageBody;
    }

]]></Source>
			</Method>
			<Method>
				<Name>stringExpand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replaces e-mail related placeholders with the actual subject, message etc.
    /// </summary>
    /// <param name="s">The string with placeholders to expand</param>
    /// <param name="mappings">Map(DocPlaceholderNameEx (str) -> DocPlaceholderValue (str))</param>
    /// <param name="_htmlEncode">Should the placeholder value be HTML encoded.</param>
    /// <returns>Expanded string</returns>
    /// <remarks>
    /// If the message has special delimiters then the embedded urls will get resolved.
    /// NOTE: Copied from the original SysEmailMessage::stringExpand() method.
    /// </remarks>
    public static str stringExpand(str s, Map mappings, boolean _htmlEncode = true)
    {
        TextBuffer tb = new TextBuffer();
        MapEnumerator mapEnum;

        #define.Message('message')


        if (!mappings)
        {
            return s;
        }

        tb.setText(s);

        // <Docentric>
        // Replace a hidden comment used only in the pre-handler of the built-in SysEmailMessage::stringExpand() method.
        tb.replace(DocConstant::DocentricHtmlComment, '');
        // </Docentric>

        mapEnum = mappings.getEnumerator();

        while (mapEnum && mapEnum.moveNext())
        {
            // <Docentric> - the difference comparing to the original SysEmailMessage::stringExpand() method.
            DocPlaceholderNameEx    placeholderNameEx = mapEnum.currentKey();
            DocPlaceholderDefinition placeholderDef = new DocPlaceholderDefinition(placeholderNameEx);
            DocPlaceholderValue     placeholderValue = mapEnum.currentValue();

            if ((placeholderDef.type() != DocPlaceholderType::HTML) && _htmlEncode)
            {
                // Encode the value.
                placeholderValue = System.Web.HttpUtility::HtmlEncode(placeholderValue);
            }

            if (placeholderNameEx == #Message)  // WF - Message (%message%) placeholder
            {
                placeholderValue = SysEmailMessage::resolveUrls(placeholderValue, true);
                placeholderValue = strReplace(placeholderValue, '\n', '<br>');
            }
            // </Docentric>

            tb.replace('%' + placeholderDef.name() + '%', placeholderValue);
        }

        return tb.getText();
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPlaceholder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find given placeholder in the given string.
    /// </summary>
    /// <param name = "_s">Input string</param>
    /// <param name = "_placeholderName">Placeholder name without starting and ending symbol (%) and without ?Image...</param>
    /// <returns>Position of the first occurrence of the given placeholder within the input string; 0 if the placeholder is not found</returns>
    public static int findPlaceholder(str _s, DocPlaceholderName _placeholderName)
    {
        str placeholder = DocConstantPlaceholderET::PlaceholderStartSymbol + _placeholderName + DocConstantPlaceholderET::PlaceholderEndSymbol;
        int pos = strScan(_s, placeholder, 1, strLen(_s));
        return pos;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmailBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the given email ID and language ID, returns the email body if exists.
    /// </summary>
    /// <param name = "_emailId">Email ID</param>
    /// <param name = "_languageId">Language ID</param>
    /// <param name = "_isSystem">Is system email template</param>
    /// <returns>Email message body</returns>
    public static str getEmailBody(str _emailId, str _languageId, boolean _isSystem)
    {
        str languageId;

        if (_isSystem)
        {
            SysEmailSystemTable emailSysTable;
            SysEmailMessageSystemTable emailSysMessage;

            [emailSysTable, emailSysMessage, languageId] = DocEmailTemplateManager::getSysEmailSystemTableAndMessageTable(_emailId, _languageId);

            return emailSysMessage.Mail;
        }
        else
        {
            SysEmailTable emailTable;
            SysEmailMessageTable emailMessage;

            [emailTable, emailMessage, languageId] = DocEmailTemplateManager::getSysEmailTableAndMessageTable(_emailId, _languageId);

            return emailMessage.Mail;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendAlertEmailNotifications</Name>
				<Source><![CDATA[
    /*-------------------------------------------*/
    /*          ALERT RELATED METHODS            */
    /*-------------------------------------------*/
    /*  NOTE:
        Before Microsoft's redesign of Alerts, the same framework was used for both Workflow and Alert notifications and emails,
        which uses SysEmailTable::sendMail()/SysEmailSystemTable::sendMail() to send workflow and alert emails via Batch email sending status.
        After the redesign of Alerts was done, alert emails are sent only via Email provider without using Email templates.
        We created an extension which re-enabled using of Email templates, introduced ETH classes that support custom placeholders in the
        email body, subject and email recipients, adding email attachments, and uses the DocEmailTemplateManager::sendMail()/sendSysMail() methods
        for sending alert emails. This means that alert emails can be sent via both Email provider and Batch email sending status.
    */    
    
    /// <summary>
    /// Sends alert email notification.
    /// </summary>
    /// <param name = "_eventRule">The EventRule table buffer</param>
    /// <param name = "_eventType">An instance of the EventType class</param>
    /// <param name = "_alertTable">The alert table buffer - for which the alert rule is defined</param>
    /// <param name = "_eventInbox">The EventInbox table buffer</param>
    /// <param name = "_linkToBusinessData">The url link to business data related to event action</param>
    /// <returns>An instance of the DocSendAlertEmailNotificationsResult class if alert email was sent successfully; otherwise an exception</returns>
    public static DocSendAlertEmailNotificationsResult sendAlertEmailNotifications(
        EventRule _eventRule,
        EventType _eventType,
        Common _alertTable,
        EventInbox _eventInbox,
        System.Uri _linkToBusinessData)
    {
        DocSendAlertEmailNotificationsResult sendAlertEmailNotificationsResult = new DocSendAlertEmailNotificationsResult();

        SysEmailId emailId = _eventRule.EmailId_DC;
        boolean isSystemEmailTemplate = _eventRule.CompanyId == '';


        // Validate the parameters
        DocEmailTemplateHandlerBase validateParameters()
        {
            if (!_eventRule || !_eventType || !_eventInbox)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParametersNotSet", strFmt('%1, %2, %3', identifierStr(_eventRule), identifierStr(_eventType), identifierStr(_eventInbox))));
            }

            if (!_linkToBusinessData)  // The provided URI has to be at least empty.
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParameterNotSetOrInvalid", identifierStr(_linkToBusinessData)));
            }
        
            if (!DocEmailTemplateHelper::isDocentricImprovedEmailTemplatesTurnedOn(emailId, isSystemEmailTemplate))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:NotUsedEmailTemplateWithDocentricError", isSystemEmailTemplate ? "@DocentricAX4:System" : "@DocentricAX4:Organization", emailId));
            }

            DocEmailTemplateHandlerBase eth = DocEmailTemplateHandlerBase::constructFromEmailId(emailId, isSystemEmailTemplate);
            if (eth.getEventNotificationSource() != DocEmailTemplateEventNotificationSource::Alert)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:NotUsedEmailTemplateForAlertsError", isSystemEmailTemplate ? "@DocentricAX4:System" : "@DocentricAX4:Organization", emailId));
            }

            return eth;
        }
        

        // Create the email processing params
        DocEmailProcessingParams createEmailProcessingParams()
        {
            // Create and set email processing parameters. By setting up the properties of this class
            // we will ensure that the fields added to SysOutgoingEmailTable by Docentric get populated.
            DocEmailProcessingParams emailPP = new DocEmailProcessingParams();

            // Set Account type and Account ID
            DocAccountRole accountType;
            DocAccountNum accountNum;
            [accountType, accountNum] = DocDirPartyHelper::getAccountData(_alertTable);
            emailPP.accountType(accountType);
            emailPP.accountNum(accountNum);

            // Set Event inboxId
            emailPP.eventInboxId(_eventInbox.InboxId);
            // Set Event rule Id
            emailPP.eventRuleId(_eventRule.RuleId);
            // Set context information
            emailPP.contextInformation(strFmt('%1.%2 (%3)', tableId2Name(_eventInbox.AlertTableId), _eventInbox.AlertFieldId ? fieldId2Name(_eventInbox.AlertTableId, _eventInbox.AlertFieldId) : _eventInbox.AlertFieldLabel, _eventInbox.AlertFieldLabel));
            // Set user ID
            emailPP.userId(_eventInbox.UserId);

            return emailPP;
        }


        /***  VALIDATION  ***/
        DocEmailTemplateHandlerBase ethClassInstance = validateParameters();


        /***  PREPARE PARAMETERS ***/
        // Create alertContextInfo object.
        DocEmailTemplateAlertContextInfoParams alertContextInfo = DocEmailTemplateAlertContextInfoParams::construct(_eventRule, _eventType, _alertTable, _eventInbox, _linkToBusinessData.ToString());

        // Create a context info container for alert email.
        container alertContextInfoContainer = DocEmailTemplateAlertContextInfoParams::createAlertContextInfoContainer(alertContextInfo);

        str emailToAddr = _eventRule.EmailRecipients;
        str emailCcAddr = _eventRule.EmailCc_DC;
        str emailBccAddr = _eventRule.EmailBcc_DC;

        boolean useEmailProcessing = _eventRule.EmailSendingMode_DC == DocEmailSendingMode::EmailProcessing;
        DocEmailProcessingParams emailProcessingParams = null;
        if (useEmailProcessing)
        {
            emailProcessingParams = createEmailProcessingParams();
        }

        // Get the language from the company in the alert rule
        LanguageId languageId = CompanyInfo::findDataArea(_eventRule.CompanyId ? _eventRule.CompanyId : curExt()).LanguageId;
        if (!languageId)
        {
            // Get the system language
            languageId = SystemParameters::find().SystemLanguageId;
        }
        if (!languageId)
        {
            // Get the language from the current user
            languageId = xUserInfo::find(false, curUserId()).language;
        }

        // Give a chance to subscriber to change the event rule user language.
        languageId = DocEmailTemplateDelegates::instance().publishEventChangeLanguageForAlertEmail(alertContextInfo, languageId);


        /***  FILL _MAPPINGS WITH STANDARD PLACEHOLDER VALUES  ***/
        // Create a map with standard placeholders and their values for alert email.
        Map mappings = DocEmailTemplateManager::createAlertStandardPlaceholderMap(alertContextInfo, languageId);


        /***  SEND ALERT EMAIL  ***/
        DocSendMailResult sendMailResult;
        try
        {
            // Send alert email based on Organization email template.
            if (!isSystemEmailTemplate)
            {
                sendMailResult = DocEmailTemplateManager::sendMail(
                    emailId,
                    languageId,
                    emailToAddr,
                    mappings,
                    null,
                    alertContextInfoContainer,
                    emailCcAddr,
                    emailBccAddr,
                    '',
                    conNull(),
                    conNull(),
                    null,
                    useEmailProcessing,
                    emailProcessingParams,
                    '',
                    ''
                );
            }

            // Send alert email based on System email template.
            else
            {
                sendMailResult = DocEmailTemplateManager::sendSysMail(
                    emailId,
                    languageId,
                    emailToAddr,
                    mappings,
                    null,
                    alertContextInfoContainer,
                    emailCcAddr,
                    emailBccAddr,
                    '',
                    conNull(),
                    conNull(),
                    null,
                    useEmailProcessing,
                    emailProcessingParams,
                    '',
                    ''
                );
            }
            sendAlertEmailNotificationsResult.parmSendMailResult(sendMailResult);
        }

        /***  DISPOSE ETH CLASS  ***/
        finally
        {
            // Important only if the DocEmailTemplateAdvancedHandlerWFAL class is used -> to remove EventInboxId from CallContext.
            ethClassInstance.finalize();
        }

        return sendAlertEmailNotificationsResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendAlertSummaryEmailNotifications</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sends alert summary email notification.
    /// </summary>
    /// <param name = "_eventInboxList">List of alerts to be sent</param>
    /// <param name = "_emailId">System email template Id</param>
    /// <param name = "_emailToAddr">Recipient e-mail address or list of e-mail addresses</param>
    /// <param name = "_alertSummaryEmailContextInfo">An instance of the DocAlertSummaryEmailContextInfoParams class</param>
    /// <returns>An instance of the DocSendAlertEmailNotificationsResult class if alert email was sent successfully; otherwise an exception</returns>
    public static DocSendAlertEmailNotificationsResult sendAlertSummaryEmailNotifications(
        List _eventInboxList,
        SysEmailId _emailId,
        str _emailToAddr,
        DocAlertSummaryEmailContextInfoParams _alertSummaryEmailContextInfo)
    {
        DocSendAlertEmailNotificationsResult sendAlertEmailNotificationsResult = new DocSendAlertEmailNotificationsResult();


        // Validate the parameters
        DocEmailTemplateHandlerBase validateParameters()
        {
            if (_eventInboxList == null || !_emailId || !_emailToAddr || _alertSummaryEmailContextInfo == null)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:ParametersNotSet", strFmt('%1, %2, %3, %4', 
                    identifierStr(_eventInboxList), identifierStr(_emailId), identifierStr(_emailToAddr), identifierStr(_alertSummaryEmailContextInfo))));
            }
        
            if (!DocEmailTemplateHelper::isDocentricImprovedEmailTemplatesTurnedOn(_emailId, true))
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:NotUsedEmailTemplateWithDocentricError", "@DocentricAX4:System", _emailId));
            }

            DocEmailTemplateHandlerBase eth = DocEmailTemplateHandlerBase::constructFromEmailId(_emailId, true);
            if (eth.getEventNotificationSource() != DocEmailTemplateEventNotificationSource::Alert)
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX4:NotUsedEmailTemplateForAlertSummaryError", "@DocentricAX4:System", _emailId));
            }

            return eth;
        }


        // Create the email processing params
        DocEmailProcessingParams createEmailProcessingParams()
        {
            // Create and set email processing parameters. By setting up the properties of this class
            // we will ensure that the fields added to SysOutgoingEmailTable by Docentric get populated.
            DocEmailProcessingParams emailPP = new DocEmailProcessingParams();

            // Set origin
            emailPP.origin(_alertSummaryEmailContextInfo.parmEmailProcessingDesc());
            // Set context information
            emailPP.contextInformation(_alertSummaryEmailContextInfo.parmEmailContextInfo());
            // Set user ID
            emailPP.userId(curUserId());

            return emailPP;
        }


        /***  VALIDATION  ***/
        DocEmailTemplateHandlerBase ethClassInstance = validateParameters();

        /***  PREPARE PARAMETERS ***/
        boolean useEmailProcessing = _alertSummaryEmailContextInfo.parmEmailSendingMode() == DocEmailSendingMode::EmailProcessing;
        DocEmailProcessingParams emailProcessingParams = null;
        if (useEmailProcessing)
        {
            emailProcessingParams = createEmailProcessingParams();
        }

        // Create a context info container for alert summary email.
        container alertSummaryEmailContextInfoContainer = DocAlertSummaryEmailContextInfoParams::createAlertSummaryEmailContextInfoContainer(_alertSummaryEmailContextInfo);

        // Get the language from the company
        LanguageId languageId = CompanyInfo::findDataArea(curExt()).LanguageId;
        if (!languageId)
        {
            // Get the system language
            languageId = SystemParameters::find().SystemLanguageId;
        }
        if (!languageId)
        {
            // Get the language from the current user
            languageId = xUserInfo::find(false, curUserId()).language;
        }

        // Give a chance to subscriber to change the language.
        languageId = DocEmailTemplateDelegates::instance().publishEventChangeLanguageForAlertSummaryEmail(_alertSummaryEmailContextInfo, languageId);

        /*** PREPARE LINE MAPPINGS ***/
        List lineMappings = new List(Types::Class);
        ListEnumerator eventInboxListEnum = _eventInboxList.getEnumerator();

        while (eventInboxListEnum.moveNext())
        {
            EventInbox eventInbox = eventInboxListEnum.current() as EventInbox;
            EventRule eventRule = EventRule::find(eventInbox.RuleId);

            Common alertTable;
            CompanyId companyId = eventInbox.CompanyId ? eventInbox.CompanyId : curExt();
            changecompany(companyId) 
            {
                alertTable = SysDictTable::findFromKeyData(eventInbox.AlertTableId, eventInbox.keyFieldData());
            }

            str linkToBusinessData = '';
            int infologLine = infologLine();
            try
            {
                Map fieldNameValueMap = new Map(Types::String, Types::String);
                if (alertTable)
                {
                    fieldNameValueMap.insert(identifierStr(RecId), int642Str(alertTable.RecId));
                }
                linkToBusinessData = DocGlobalHelper::generateRecordUrl(
                    eventRule.MenuItemName, eventRule.MenuItemType, tableId2Name(eventInbox.AlertTableId), fieldNameValueMap, companyId);
            }
            catch
            {
                infolog.cut(infologLine + 1); 
            }

            EventInboxData inboxData = EventInboxData::find(eventInbox.InboxId, EventInboxDataType::TypeData);
            SysDictClass dictClass = new SysDictClass(eventInbox.TypeId);
            EventType eventType;
            if (dictClass != null)
            {
                eventType = dictClass.makeObject();
                eventType.parmTypeTrigger(eventInbox.TypeTrigger);
                eventType.unpack(inboxData.Data);
            }

            /***  PREPARE PARAMETERS ***/
            // Create alertContextInfo object.
            DocEmailTemplateAlertContextInfoParams alertContextInfo = DocEmailTemplateAlertContextInfoParams::construct(eventRule, eventType, alertTable, eventInbox, linkToBusinessData);

            /***  FILL MAPPINGS WITH STANDARD PLACEHOLDER VALUES  ***/
            // Create a map with standard placeholders and their values for alert email.
            Map mappings = DocEmailTemplateManager::createAlertStandardPlaceholderMap(alertContextInfo, languageId);

            lineMappings.addEnd(mappings);
        }

        /***  SEND ALERT EMAIL  ***/
        try
        {
            // Send alert email based on System email template.
            DocSendMailResult sendMailResult = DocEmailTemplateManager::sendSysMail(
                _emailId,
                languageId,
                _emailToAddr,
                null,
                lineMappings,
                alertSummaryEmailContextInfoContainer,
                _alertSummaryEmailContextInfo.parmEmailCcAddr(),
                _alertSummaryEmailContextInfo.parmEmailBccAddr(),
                '',
                conNull(),
                conNull(),
                null,
                useEmailProcessing,
                emailProcessingParams,
                '',
                ''
            );
            sendAlertEmailNotificationsResult.parmSendMailResult(sendMailResult);
        }

        /***  DISPOSE ETH CLASS  ***/
        finally
        {
            // Important only if the DocEmailTemplateAdvancedHandlerWFAL class is used -> to remove EventInboxId from CallContext.
            ethClassInstance.finalize();
        }

        return sendAlertEmailNotificationsResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAlertStandardPlaceholderMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a map with standard placeholders and their values for alert email.
    /// </summary>
    /// <param name = "_alertContextInfo">Alert context info containg the EventRule and EventInbox records, alert table buffer, EventType class instance, Url to alert entity</param>
    /// <param name = "_languageId">Language to use for formatting numbers and dates</param>
    /// <returns>A map with alert standard placeholder values: Map(placeholderName (str), placeholderValue (str))</returns>
    private static Map createAlertStandardPlaceholderMap(DocEmailTemplateAlertContextInfoParams _alertContextInfo, LanguageId _languageId)
    {   
        Map mappings;
          
        str errorMsg = strFmt("@DocentricAX4:FillAlertStandardPlaceholderValuesError", 
                                _alertContextInfo.parmEventRule().CompanyId == '' ? "@DocentricAX4:System" : "@DocentricAX4:Organization",
                                _alertContextInfo.parmEventRule().EmailId_DC);
        try
        {
            // Get link to alert rule (LinkToAlertRule)
            Map fieldNameValueMap = new Map(Types::String, Types::String);
            fieldNameValueMap.insert(fieldStr(EventRule, RuleId), _alertContextInfo.parmEventRule().RuleId);
            str linkToAlertRule = DocGlobalHelper::generateRecordUrl(
                menuItemDisplayStr(DocEventRule), MenuItemType::Display, tableStr(EventRule), fieldNameValueMap, _alertContextInfo.parmEventRule().CompanyId);

            // Get link to alert (LinkToAlert)
            fieldNameValueMap = new Map(Types::String, Types::String);
            fieldNameValueMap.insert(fieldStr(EventInbox, InboxId), int642Str(_alertContextInfo.parmEventInbox().InboxId));
            str linkToAlert = DocGlobalHelper::generateRecordUrl(
                menuItemDisplayStr(DocEventAlertInbox), MenuItemType::Display, tableStr(EventInbox), fieldNameValueMap, _alertContextInfo.parmEventInbox().CompanyId);
        
            // Get previous value (BeforeValue), current value (AfterValue) and data (Data)
            var cultureInfo = DocGlobalHelper::getCultureInfo(_languageId);
            str previousValue = '';
            str currentValue = '';
            str data = '';
            if (_alertContextInfo.parmEventType() && SysDictClass::isEqualOrSuperclass(_alertContextInfo.parmEventInbox().TypeId, classnum(EventTypeCUD)) &&
                   _alertContextInfo.parmEventInbox().TypeTrigger == EventTypeTrigger::FieldChanged)
            {
                SysDictField dictField = new SysDictField(_alertContextInfo.parmEventInbox().AlertTableId, _alertContextInfo.parmEventInbox().AlertFieldId);
                if (dictField.enumId() == 0)
                {
                    if (dictField.isSurrogateForeignKey())
                    {
                        previousValue = EventType::surrogateValue(dictField.tableName(), dictField.name(), _alertContextInfo.parmEventType().parmOriginalValue());
                        currentValue = EventType::surrogateValue(dictField.tableName(), dictField.name(), _alertContextInfo.parmEventType().parmCurrentValue());
                    }
                    else
                    {
                        previousValue = DocGlobalHelper::formatData(_alertContextInfo.parmEventType().parmOriginalValue(), cultureInfo, DocApplyTimeZone::CompanyTimeZone);
                        currentValue = DocGlobalHelper::formatData(_alertContextInfo.parmEventType().parmCurrentValue(), cultureInfo, DocApplyTimeZone::CompanyTimeZone);
                    }
                }
                else
                {
                    SysDictEnum dictEnum = new SysDictEnum(dictField.enumId());
                    previousValue = dictEnum.value2Label(_alertContextInfo.parmEventType().parmOriginalValue());
                    currentValue = dictEnum.value2Label(_alertContextInfo.parmEventType().parmCurrentValue());
                }

                data = strfmt('%1: %2; %3: %4', "@SYS69521", previousVAlue, "@SYS91541", currentValue);
            }

            // Get X value (XValue)
            str xValue = '';
            if (_alertContextInfo.parmEventType() && _alertContextInfo.parmEventType().isRequiringX() && _alertContextInfo.parmEventType().parmXValue())
            {
                if (_alertContextInfo.parmEventType().xValueEnumId())
                {
                    SysDictEnum dictEnum = new SysDictEnum(_alertContextInfo.parmEventType().xValueEnumId());
                    xValue = dictEnum.value2Label(_alertContextInfo.parmEventType().parmXValue());
                }
                else
                {
                    xValue = DocGlobalHelper::formatData(_alertContextInfo.parmEventType().parmXValue(), cultureInfo, DocApplyTimeZone::CompanyTimeZone);
                }
            }

            // Get created by (CreatedUser) and modified by user (ModifiedUser)
            CreatedBy createdUser = '';
            ModifiedBy modifiedUser = '';
            if (_alertContextInfo.parmAlertTable())
            {
                // Check if the createdBy field exists in the table 
                FieldId createdByField = fieldName2Id(_alertContextInfo.parmAlertTable().TableId, identifierStr(createdBy));
                if (createdByField)
                {
                    // Get the value of the createdBy field
                    createdUser = _alertContextInfo.parmAlertTable().(createdByField);
                }

                // Check if the modifiedBy field exists in the table
                FieldId modifiedByField = fieldName2Id(_alertContextInfo.parmAlertTable().TableId, identifierStr(modifiedBy));
                if (modifiedByField)
                {
                    // Get the value of the modifiedBy field
                    modifiedUser = _alertContextInfo.parmAlertTable().(modifiedByField);
                }
            }

            // Create a map with standard placeholders and their values for alert
            mappings = new Map(Types::String, Types::String);
            mappings.insert('Occurred', DocGlobalHelper::formatData(_alertContextInfo.parmEventInbox().AlertCreatedDateTime, cultureInfo, DocApplyTimeZone::CompanyTimeZone));
            mappings.insert('For', _alertContextInfo.parmEventInbox().AlertedFor);
            mappings.insert('Company', _alertContextInfo.parmEventInbox().CompanyId ? _alertContextInfo.parmEventInbox().CompanyId : "@SYS314900");
            mappings.insert('Subject', _alertContextInfo.parmEventInbox().Subject);
            mappings.insert('Message', _alertContextInfo.parmEventInbox().Message);
            mappings.insert('LinkToBusinessData', _alertContextInfo.parmLinkToBusinessData());
            mappings.insert('LinkToAlertRule', linkToAlertRule);
            mappings.insert('LinkToAlert', linkToAlert);
            mappings.insert('BeforeValue', previousValue);
            mappings.insert('AfterValue', currentValue);
            mappings.insert('XValue', xValue);
            mappings.insert('Data', data);
            mappings.insert('Event', DocEmailTemplateHelper::buildSubject(_alertContextInfo.parmEventInbox(), _alertContextInfo.parmEventType(), cultureInfo));
            mappings.insert('Alertid', int642Str(_alertContextInfo.parmEventInbox().InboxId));
            mappings.insert('CreatedUser', createdUser);
            mappings.insert('ModifiedUser', modifiedUser);
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), errorMsg);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), errorMsg);
        }
        
        // Give a chance to a subscriber to change the _mappings.
        DocEmailTemplateDelegates::instance().publishEventChangeAlertStandardPlaceholderMappings(mappings, _alertContextInfo, _languageId);

        return mappings;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processAlertEmail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process alert emails:
    ///  - Adds email body and subject from the standard alert email if they are not defined in the email template.
    ///  - Adds all attachments tagged with the configured Attachment tags in Email template setup.
    ///  - Allows changing of Email processing parameters, if the provided ETH class implements IDocEmailTemplateAlerts.
    /// </summary>
    /// <param name = "_emailMsgSettings">Email message settings</param>
    /// <param name = "_emailProcessingParams">Email processing parameters</param>
    /// <param name = "_ethClassInstance">ETH class instance</param>
    /// <param name = "_emailTableMap">The SysEmailTable or SysEmailSystemTable table record</param>
    /// <param name = "_emailMessageMap">The SysEmailMessageTable or SysEmailMessageSystemTable table record</param>
    /// <param name = "_alertContextInfoContainer">Contains the EventRule and EventInbox records, alert table buffer, EventType class instance, Url to alert entity.</param>
    private static void processAlertEmail(
        DocEmailMessageSettings _emailMsgSettings,
        DocEmailProcessingParams _emailProcessingParams, 
        DocEmailTemplateHandlerBase _ethClassInstance,
        DocSysEmailTableMap _emailTableMap, 
        DocSysEmailMessageMap _emailMessageMap, 
        container _alertContextInfoContainer)
    {
        DocEmailTemplateAlertContextInfoParams alertContextInfo;

        // This method is applicable only for alert emails.
        if (_ethClassInstance.getEventNotificationSource() != DocEmailTemplateEventNotificationSource::Alert)
        {
            return;
        }
        
        // (1) Handle email subject and email body if they are not defined in the email template.
        //     For alert emails, as of version 3.4.5 we allow that email message is an empty record or without body.
        if (_emailTableMap.IsUsedForAlert_DC && (_emailMessageMap.RecId == 0 || !_emailMessageMap.Mail))
        {
            try
            {
                str emailBody = '';
                // Get the email body and subject defined for the standard alert email
                DictClass eventActionAlertDictClass = new DictClass(className2Id(identifierStr(EventActionAlert)));
                if (eventActionAlertDictClass)
                {
                    var eventActionAlert = eventActionAlertDictClass.makeObject();
                    if (eventActionAlert)
                    {
                        alertContextInfo = DocEmailTemplateAlertContextInfoParams::createFromAlertContextInfoContainer(_alertContextInfoContainer);
                        if (alertContextInfo != null)
                        {
                            str emailSubject = alertContextInfo.parmEventInbox().Subject;
                            emailBody = eventActionAlertDictClass.callObject(identifierStr(getEmailBody), eventActionAlert, 
                                alertContextInfo.parmEventInbox(), alertContextInfo.parmEventRule(), alertContextInfo.parmAlertTable());

                            // Set the email subject if it is not already set
                            if (!_emailMsgSettings.parmEmailSubject())
                            {
                                _emailMsgSettings.parmEmailSubject(emailSubject);
                            }
                            _emailMsgSettings.parmEmailBody(emailBody);
                        }
                    }
                }
                if (!emailBody)
                {
                    throw Exception::Error;
                }
            }
            catch
            {
                DocGlobalHelper::handleException(funcName(), strFmt("@DocentricAX:EmailMsgContentNotFound", _emailTableMap.EmailId));
            }
        }

        // Check if the corresponding ETH class implements the DocEmailTemplateEmailProcessingActions interface that affects further processing regarding (1) and (2).
        IDocEmailTemplateAlerts ethETA = _ethClassInstance as IDocEmailTemplateAlerts;

        str errorMsg = strFmt("@DocentricAX4:AlertAttachmentsError", _ethClassInstance.parmIsSystem() ? "@DocentricAX4:System" : "@DocentricAX4:Organization",  _ethClassInstance.emailId());

        // (2) Handle attachments. Works also for the DocEmailTemplateHandlerBase class.
        try
        {
            if (_emailTableMap.AddEmailAttachments_DC)
            {
                // Handle attachments as implemented in the ETH class and check if the standard handling should be skipped.
                boolean skipAttachmentHandlingFromSetup = ethETA != null && ethETA.handleAlertAttachments(_emailMsgSettings) == false;
                if (!skipAttachmentHandlingFromSetup)
                {
                    // Handle attachments as configured in the Email templates form -> add all attachments tagged with the configured Attachment tags.
                    Common alertTable;
                    if (ethETA != null)
                    {
                        alertTable = ethETA.getAttachmentsContextRecord();
                    }
                    else
                    {
                        alertContextInfo = DocEmailTemplateAlertContextInfoParams::createFromAlertContextInfoContainer(_alertContextInfoContainer);
                        alertTable = alertContextInfo.parmAlertTable();
                    }
                    
                    DocuRefSearch docuRefSearch = DocuRefSearch::newCommon(alertTable);
                    while (docuRefSearch.next())
                    {
                        DocuRef docuRef = docuRefSearch.docuRef();
                        
                        if (docuRef.docuAction().canArchive() && docuRef.isValueAttached() &&                                   // Consider only Attachment documents
                            docuRef.active_DC() &&                                                                              // which are active 
                           (docuRef.LanguageId_DC == '' || docuRef.LanguageId_DC == _ethClassInstance.parmLanguageId()) &&      // language-neutral or in the alert language
                            DocGlobalHelper::containsTags(docuRef.Tags_DC, _emailTableMap.EmailAttachmentTags_DC, true))        // with all specified tags.
                        {
                            container additionalAttachmentFileContent = DocumentManagement::getAttachmentAsContainer(docuRef);
                            str additionalAttachmentFileName = strFmt('%1.%2', DocFileMngHelper::replaceInvalidCharsForFileName(docuRef.Name), docuRef.fileType());
                            _emailMsgSettings.addAdditionalAttachment(additionalAttachmentFileName, additionalAttachmentFileContent);
                        }
                    }
                }
            }
        }
        catch (Exception::CLRError)
        {
            DocGlobalHelper::handleClrException(funcName(), errorMsg);
        }
        catch
        {
            DocGlobalHelper::handleException(funcName(), errorMsg);
        }

        errorMsg = strFmt("@DocentricAX4:AlertEmailProcessingParamsError", _ethClassInstance.parmIsSystem() ? "@DocentricAX4:System" : "@DocentricAX4:Organization",  _ethClassInstance.emailId());

        // (3) Change email processing parameters. Works only for the DocEmailTemplateAdvancedHandlerWFAL class or its child classes.
        if (ethETA)
        {
            try
            {
                ethETA.changeAlertEmailProcessingParams(_emailProcessingParams);
            }
            catch (Exception::CLRError)
            {
                DocGlobalHelper::handleClrException(funcName(), errorMsg);
            }
            catch
            {
                DocGlobalHelper::handleException(funcName(), errorMsg);
            }
        }

        /****** TRACING ******/
        if (DocTrace::isTraceCategoryEnabled(DocConstantDiagnostics::TraceAlerts))
        {
            DocTraceContextAlerts traceContext = DocTraceContextAlerts::constructForEmail(_emailMsgSettings, _emailProcessingParams, _ethClassInstance, _emailTableMap, _alertContextInfoContainer);
            DocTrace::info(DocConstantDiagnostics::TraceAlerts, DocConstantDiagnostics::TraceAlertsDocentricEmailing, traceContext.getTraceMessage(), traceContext);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>